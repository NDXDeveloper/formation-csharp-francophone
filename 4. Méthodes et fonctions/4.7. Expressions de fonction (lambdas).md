# 4.7. Expressions de fonction (lambdas)

Les expressions lambda sont une fonctionnalité fondamentale du langage C# qui permet de créer des fonctions anonymes de manière concise. Elles sont disponibles aussi bien dans .NET Framework 4.7.2 que dans .NET 8, avec quelques améliorations dans les versions récentes. Cette section explore en détail la syntaxe des lambdas, leur utilisation comme délégués et expressions, ainsi que le concept important de capture de variables.

## 4.7.1. Syntaxe des expressions lambda

Les expressions lambda en C# sont définies par une liste de paramètres suivie du symbole `=>` (appelé opérateur lambda) et d'une expression ou d'un bloc d'instructions.

### Syntaxe de base

```textmate
// Syntaxe générale: (paramètres) => expression ou bloc
```


#### Expressions lambda avec un seul paramètre

```textmate
// Un seul paramètre sans parenthèses
x => x * x

// Un seul paramètre avec parenthèses
(x) => x * x

// Un seul paramètre avec type explicite
(int x) => x * x
```


#### Expressions lambda avec plusieurs paramètres

```textmate
// Plusieurs paramètres (les parenthèses sont obligatoires)
(x, y) => x + y

// Plusieurs paramètres avec types explicites
(int x, double y) => x + y
```


#### Expressions lambda sans paramètre

```textmate
// Sans paramètre
() => DateTime.Now
```


#### Expression lambda vs bloc d'instructions

Les lambdas peuvent être définies comme une expression simple ou un bloc d'instructions :

```textmate
// Expression lambda (retourne implicitement le résultat)
x => x * x

// Lambda avec bloc d'instructions (nécessite 'return' explicite pour les valeurs de retour)
x => {
    var résultat = x * x;
    return résultat;
}

// Lambda void avec bloc d'instructions
x => {
    Console.WriteLine($"Valeur: {x}");
    // Pas de return nécessaire pour les lambdas void
}
```


### Inférence de type

Le compilateur C# peut généralement inférer les types des paramètres lambda en fonction du contexte :

```textmate
// Le type de 'nombre' est inféré comme int
List<int> nombres = new List<int> { 1, 2, 3, 4, 5 };
var nombresPairs = nombres.Where(nombre => nombre % 2 == 0);

// Le type de 'c' est inféré comme Customer
List<Customer> clients = GetCustomers();
var clientsActifs = clients.Where(c => c.Statut == StatutClient.Actif);
```


### Types de retour explicites (.NET 7+)

Dans les versions récentes de C# (C# 10+), vous pouvez spécifier explicitement le type de retour d'une lambda :

```textmate
// Disponible dans .NET 7+ (C# 10+), pas dans .NET Framework 4.7.2
var calculerCube = double (double x) => x * x * x;
```


### Paramètres avec attributs (.NET 6+)

Les paramètres lambda peuvent avoir des attributs dans les versions récentes de C# :

```textmate
// Disponible dans .NET 6+ (C# 10+), pas dans .NET Framework 4.7.2
var parser = ([NotNull] string text) => int.Parse(text);
```


### Commentaires et lisibilité

Pour améliorer la lisibilité, vous pouvez utiliser des noms de paramètres significatifs et des commentaires :

```textmate
// Noms de paramètres explicites
(client, commande) => client.Id == commande.ClientId

// Avec types et noms explicites pour une meilleure lisibilité
(Client client, Commande commande) => {
    // Vérifie si la commande appartient au client
    return client.Id == commande.ClientId;
}
```


## 4.7.2. Lambdas comme délégués et expressions

Les expressions lambda sont utilisées dans deux contextes principaux : comme délégués (représentant des méthodes) et comme expressions d'arbre (représentant du code sous forme de structure de données).

### Lambdas comme délégués

Les lambdas peuvent être assignées à des types délégués, permettant de passer des fonctions comme paramètres ou de les stocker dans des variables :

#### Types délégués prédéfinis

```textmate
// Action - délégué void sans valeur de retour
Action afficherMessage = () => Console.WriteLine("Bonjour");
Action<string> afficherNom = nom => Console.WriteLine($"Bonjour {nom}");
Action<int, int> afficherSomme = (a, b) => Console.WriteLine($"Somme: {a + b}");

// Func - délégué avec valeur de retour (le dernier type est le type de retour)
Func<int, int> carré = x => x * x;
Func<int, int, int> addition = (a, b) => a + b;
Func<string, bool> estVide = s => string.IsNullOrEmpty(s);

// Predicate - délégué spécialisé qui retourne toujours bool
Predicate<int> estPair = nombre => nombre % 2 == 0;
```


#### Utilisation avec les méthodes prenant des délégués

```textmate
List<int> nombres = new List<int> { 1, 2, 3, 4, 5 };

// Where prend un Func<T, bool> comme paramètre
var nombresPairs = nombres.Where(n => n % 2 == 0);

// Select prend un Func<T, TResult> comme paramètre
var carrés = nombres.Select(n => n * n);

// ForEach prend une Action<T> comme paramètre
nombres.ForEach(n => Console.WriteLine(n));

// Find prend un Predicate<T> comme paramètre
var premierPair = nombres.Find(n => n % 2 == 0);
```


#### Délégués personnalisés

```textmate
// Définition d'un délégué personnalisé
public delegate decimal CalculPrix(Produit produit, int quantité);

// Utilisation avec lambda
CalculPrix calcul = (produit, quantité) => {
    decimal prixBase = produit.Prix * quantité;

    // Appliquer une remise par quantité
    if (quantité > 10)
        return prixBase * 0.9m; // 10% de remise
    else if (quantité > 5)
        return prixBase * 0.95m; // 5% de remise

    return prixBase;
};

// Utilisation du délégué
decimal prixTotal = calcul(produit, 12);
```


### Lambdas comme expressions d'arbre

Les expressions lambda peuvent également être converties en expressions d'arbre (`Expression<T>`), qui représentent le code sous forme de structure de données plutôt que de code exécutable.

#### Création d'expressions d'arbre

```textmate
// Lambda convertie en délégué (code exécutable)
Func<int, bool> estPairFunc = x => x % 2 == 0;

// Lambda convertie en expression d'arbre (structure de données)
Expression<Func<int, bool>> estPairExpr = x => x % 2 == 0;
```


#### Utilisation avec LINQ to Entities/SQL

Les expressions d'arbre sont particulièrement utiles avec les fournisseurs LINQ qui doivent traduire le code C# en un autre langage, comme SQL :

```textmate
// Utilisation avec Entity Framework (fonctionne dans .NET Framework 4.7.2 et .NET 8)
using (var context = new MaBaseDeDonnéesContext())
{
    // La lambda est convertie en expression d'arbre, puis en SQL
    var clientsActifs = context.Clients
        .Where(c => c.Statut == "Actif" && c.DateDernierAchat > DateTime.Now.AddDays(-30))
        .OrderBy(c => c.Nom)
        .ToList();

    // Génère quelque chose comme:
    // SELECT * FROM Clients
    // WHERE Statut = 'Actif' AND DateDernierAchat > @date
    // ORDER BY Nom
}
```


#### Manipulation d'expressions d'arbre

Les expressions d'arbre peuvent être inspectées et modifiées dynamiquement :

```textmate
Expression<Func<int, bool>> estPairExpr = x => x % 2 == 0;

// Inspection de l'expression
Console.WriteLine(estPairExpr.Body.NodeType);  // Equal ou Modulo
Console.WriteLine(estPairExpr.Parameters[0].Name);  // x

// Compilation de l'expression en délégué exécutable
Func<int, bool> compilé = estPairExpr.Compile();
bool résultat = compilé(4);  // true
```


### Différences clés entre délégués et expressions d'arbre

```textmate
// Lambda comme délégué: compilée en code IL exécutable
Func<int, int> fonctionCarré = x => x * x;
int résultat = fonctionCarré(5);  // Exécution directe

// Lambda comme expression d'arbre: représentée comme structure de données
Expression<Func<int, int>> expressionCarré = x => x * x;
// expressionCarré(5);  // Erreur de compilation - ne peut pas être invoquée directement

// Pour exécuter une expression, elle doit d'abord être compilée
Func<int, int> fonctionCompilée = expressionCarré.Compile();
int résultatCompilé = fonctionCompilée(5);  // 25
```


## 4.7.3. Capture de variables (closures)

L'une des fonctionnalités les plus puissantes des expressions lambda est leur capacité à capturer des variables de leur contexte environnant, créant ce qu'on appelle une "fermeture" (closure). Cette fermeture permet à une lambda d'accéder aux variables même après que la méthode contenante ait terminé son exécution.

### Principe de base des fermetures

```textmate
public Func<int, int> CréerMultiplicateur(int facteur)
{
    // La lambda capture la variable 'facteur' de la méthode contenante
    return x => x * facteur;
}

// Utilisation
var multiplierPar2 = CréerMultiplicateur(2);
var multiplierPar10 = CréerMultiplicateur(10);

Console.WriteLine(multiplierPar2(5));  // 10 (5 * 2)
Console.WriteLine(multiplierPar10(5)); // 50 (5 * 10)
```


Dans cet exemple, la lambda `x => x * facteur` capture la variable `facteur` de la méthode contenante. Même après que `CréerMultiplicateur` ait terminé son exécution, les lambdas retournées conservent accès à la valeur de `facteur` avec laquelle elles ont été créées.

### Capture de variables de différentes portées

Les lambdas peuvent capturer des variables locales, des paramètres, et même des variables d'instance de la classe contenante :

```textmate
public class Compteur
{
    // Variable d'instance
    private int _compteGlobal = 0;

    public Func<int, int> CréerCompteurAvecDécalage(int décalage)
    {
        // Variable locale
        int compteLocal = 0;

        // La lambda capture _compteGlobal (variable d'instance),
        // décalage (paramètre), et compteLocal (variable locale)
        return x => {
            _compteGlobal++;
            compteLocal++;
            return x + décalage + compteLocal + _compteGlobal;
        };
    }

    public int ObtenirCompteGlobal() => _compteGlobal;
}

// Utilisation
var compteur = new Compteur();
var fonction1 = compteur.CréerCompteurAvecDécalage(10);
var fonction2 = compteur.CréerCompteurAvecDécalage(20);

Console.WriteLine(fonction1(5));  // 5 + 10 + 1 + 1 = 17
Console.WriteLine(fonction1(5));  // 5 + 10 + 2 + 2 = 19
Console.WriteLine(fonction2(5));  // 5 + 20 + 1 + 3 = 29
Console.WriteLine(compteur.ObtenirCompteGlobal());  // 3
```


### Variables capturées partagées

Lorsque plusieurs lambdas capturent la même variable, elles partagent une référence à cette variable :

```textmate
public class ExempleCapturePartagée
{
    public (Action, Action, Func<int>) CréerFonctions()
    {
        int compteur = 0;

        // Toutes ces lambdas partagent la même variable 'compteur'
        Action incrémenter = () => compteur++;
        Action décrémenter = () => compteur--;
        Func<int> obtenir = () => compteur;

        return (incrémenter, décrémenter, obtenir);
    }
}

// Utilisation
var exemple = new ExempleCapturePartagée();
var (incrémenter, décrémenter, obtenir) = exemple.CréerFonctions();

Console.WriteLine(obtenir());  // 0
incrémenter();
incrémenter();
Console.WriteLine(obtenir());  // 2
décrémenter();
Console.WriteLine(obtenir());  // 1
```


### Modification des variables capturées

Les lambdas peuvent non seulement lire mais aussi modifier les variables capturées, ce qui peut parfois créer des comportements inattendus :

```textmate
public List<Func<int>> CréerFonctionsAvecBoucle()
{
    var fonctions = new List<Func<int>>();

    for (int i = 0; i < 5; i++)
    {
        // Problème: toutes les lambdas capturent la même variable 'i'
        fonctions.Add(() => i);
    }

    return fonctions;
}

// Utilisation (comportement probablement non désiré)
var fonctions = CréerFonctionsAvecBoucle();
foreach (var f in fonctions)
{
    Console.WriteLine(f());  // Affiche 5, 5, 5, 5, 5 (et non 0, 1, 2, 3, 4)
}
```


#### Solution avec variable locale

```textmate
public List<Func<int>> CréerFonctionsAvecBoucleCorrigé()
{
    var fonctions = new List<Func<int>>();

    for (int i = 0; i < 5; i++)
    {
        // Solution: créer une copie locale de 'i' pour chaque itération
        int capturedI = i;  // Chaque lambda capture une variable différente
        fonctions.Add(() => capturedI);
    }

    return fonctions;
}

// Utilisation (comportement attendu)
var fonctionsCorrigées = CréerFonctionsAvecBoucleCorrigé();
foreach (var f in fonctionsCorrigées)
{
    Console.WriteLine(f());  // Affiche 0, 1, 2, 3, 4
}
```


### Différence dans C# 5+ (foreach)

À partir de C# 5, les variables d'itération dans les boucles `foreach` sont traitées différemment et ne nécessitent pas cette solution :

```textmate
public List<Func<string>> CréerFonctionsAvecForeach()
{
    var fonctions = new List<Func<string>>();
    string[] noms = { "Alice", "Bob", "Charlie" };

    foreach (var nom in noms)
    {
        // Dans C# 5+, chaque itération crée une nouvelle variable 'nom'
        // Donc chaque lambda capture une variable différente
        fonctions.Add(() => $"Bonjour {nom}");
    }

    return fonctions;
}

// Utilisation (dans C# 5+, y compris .NET Framework 4.7.2 et .NET 8)
var fonctionsForeach = CréerFonctionsAvecForeach();
foreach (var f in fonctionsForeach)
{
    Console.WriteLine(f());  // Affiche "Bonjour Alice", "Bonjour Bob", "Bonjour Charlie"
}
```


### Différence dans C# 16+ (for)

Dans C# 16+, les variables des boucles `for` sont également traitées par itération, une nouvelle variable est créée dans chaque itération :

```textmate
// Dans C# 16+ (.NET 8, pas .NET Framework 4.7.2)
public List<Func<int>> CréerFonctionsAvecBoucleNouveauC#()
{
    var fonctions = new List<Func<int>>();

    for (int i = 0; i < 5; i++)
    {
        // Dans C# 16+, chaque itération crée une nouvelle variable 'i'
        // Donc chaque lambda capture une variable différente
        fonctions.Add(() => i);
    }

    return fonctions;
}

// Utilisation en C# 16+
var fonctionsNouveauCS = CréerFonctionsAvecBoucleNouveauC#();
foreach (var f in fonctionsNouveauCS)
{
    Console.WriteLine(f());  // Affiche 0, 1, 2, 3, 4
}
```


### Considérations de performance et mémoire

Les fermetures créent des classes anonymes générées par le compilateur pour stocker les variables capturées, ce qui peut avoir un impact sur la performance et la mémoire :

```textmate
public Func<int, int> CréerAdditionneur(int valeur)
{
    // Le compilateur génère une classe pour stocker 'valeur'
    return x => x + valeur;
}

// Sans capture (plus efficace)
public int Additionner(int x, int valeur)
{
    return x + valeur;
}
```


#### Implications de performance

```textmate
// Création de nombreuses fermetures - peut créer beaucoup d'objets
public void TraiterListeAvecLambdas(List<int> nombres)
{
    for (int i = 0; i < 1000; i++)
    {
        int facteur = i;
        // Chaque itération crée une nouvelle fermeture capturant 'facteur'
        nombres.Select(n => n * facteur).ToList();
    }
}

// Approche plus efficace - pas de fermeture
public void TraiterListeEfficace(List<int> nombres)
{
    for (int i = 0; i < 1000; i++)
    {
        TraiterAvecFacteur(nombres, i);
    }
}

private List<int> TraiterAvecFacteur(List<int> nombres, int facteur)
{
    var résultat = new List<int>();
    foreach (var n in nombres)
    {
        résultat.Add(n * facteur);
    }
    return résultat;
}
```


### Fermetures et durée de vie des objets

Les fermetures peuvent prolonger la durée de vie des objets capturés, car les objets restent accessibles tant que la lambda existe :

```textmate
public class GrosseRessource
{
    public byte[] Données { get; } = new byte[100_000_000]; // 100 Mo

    // Finalizer pour vérification
    ~GrosseRessource()
    {
        Console.WriteLine("GrosseRessource libérée");
    }
}

public Func<int, int> CréerFonctionProblématique()
{
    var ressource = new GrosseRessource();

    // La lambda capture 'ressource' mais n'en a pas besoin
    return x => x * 2;
}

public Func<int, int> CréerFonctionEfficient()
{
    var ressource = new GrosseRessource();

    // Pas de capture, la ressource peut être collectée
    return x => x * 2;
}
```


### Fermetures et threads

Les variables capturées dans les fermetures peuvent être accédées depuis différents threads, ce qui peut conduire à des problèmes de concurrence :

```textmate
public void ExempleConcurrence()
{
    int compteur = 0;
    var tâches = new List<Task>();

    for (int i = 0; i < 100; i++)
    {
        tâches.Add(Task.Run(() => {
            // Problème: plusieurs threads accèdent à 'compteur' simultanément
            compteur++;
        }));
    }

    Task.WhenAll(tâches).Wait();
    Console.WriteLine(compteur);  // Probablement moins que 100
}

public void ExempleConcurrenceSécurisé()
{
    int compteur = 0;
    var tâches = new List<Task>();
    var verrou = new object();

    for (int i = 0; i < 100; i++)
    {
        tâches.Add(Task.Run(() => {
            // Solution: utiliser un verrou pour synchroniser l'accès
            lock (verrou)
            {
                compteur++;
            }
        }));
    }

    Task.WhenAll(tâches).Wait();
    Console.WriteLine(compteur);  // 100
}
```


### Meilleures pratiques avec les lambdas et les fermetures

#### 1. Minimiser la capture de variables

```textmate
// À éviter: capture accidentelle d'une grande liste
public Func<int, bool> CréerFonctionDeFiltre(List<int> grandeCollection, int seuil)
{
    // Capture toute la 'grandeCollection' même si seul 'seuil' est nécessaire
    return x => x > seuil && !grandeCollection.Contains(x);
}

// Préférable: extraire uniquement ce qui est nécessaire
public Func<int, bool> CréerFonctionDeFiltre(List<int> grandeCollection, int seuil)
{
    // Extraire les valeurs essentielles
    var valeursExclues = grandeCollection.Where(n => n > seuil).ToHashSet();

    // Ne capture que 'valeursExclues' et 'seuil'
    return x => x > seuil && !valeursExclues.Contains(x);
}
```


#### 2. Être attentif à la durée de vie des objets capturés

```textmate
public class ServiceNotification
{
    private readonly List<Action> _abonnements = new List<Action>();

    public void S'abonner(object abonné, Action action)
    {
        // Risque: si 'action' capture 'abonné', cela peut créer une fuite de mémoire
        _abonnements.Add(action);
    }

    // Solution: permettre l'annulation de l'abonnement
    public void DésAbonner(Action action)
    {
        _abonnements.Remove(action);
    }
}
```


#### 3. Utiliser les méthodes locales dans certaines situations

Pour des fonctions auxiliaires qui n'ont pas besoin de capturer des variables, les méthodes locales peuvent être plus efficaces que les lambdas :

```textmate
// Lambda - crée une fermeture même si elle ne capture rien
public void ExempleLambda(List<int> nombres)
{
    Func<int, bool> estPair = x => x % 2 == 0;
    var nombresPairs = nombres.Where(estPair).ToList();
}

// Méthode locale - pas de fermeture créée
public void ExempleMethodeLocale(List<int> nombres)
{
    bool EstPair(int x) => x % 2 == 0;
    var nombresPairs = nombres.Where(EstPair).ToList();
}
```


#### 4. Utiliser des méthodes locales statiques en .NET Core 3.0+ / .NET 8

```textmate
// Disponible dans .NET Core 3.0+ et .NET 8, pas dans .NET Framework 4.7.2
public void ExempleMethodeLocaleStatique(List<int> nombres)
{
    int facteur = 10;

    // Méthode locale statique - ne peut pas capturer de variables
    static bool EstPair(int x) => x % 2 == 0;

    // Méthode locale normale - peut capturer 'facteur'
    int Multiplier(int x) => x * facteur;

    var nombresPairs = nombres.Where(EstPair).Select(Multiplier).ToList();
}
```


### Différences entre .NET Framework 4.7.2 et .NET 8

Les fermetures (closures) fonctionnent de manière similaire dans .NET Framework 4.7.2 et .NET 8, mais il existe quelques différences notables :

| Fonctionnalité | .NET Framework 4.7.2 | .NET 8 |
|----------------|----------------------|--------|
| Capture de variables de base | ✅ | ✅ |
| Variables foreach capturées séparément | ✅ | ✅ |
| Variables for capturées séparément | ❌ | ✅ (C# 16+) |
| Optimisations de performance des closures | Limitées | Améliorées |
| Lambdas statiques (évitant les captures) | ❌ | ✅ (C# 9+) |

### Exemples pratiques de capture de variables

#### 1. Filtres personnalisés avec critères configurables

```textmate
public class FiltrePersonnalisé
{
    public Func<Produit, bool> CréerFiltreProduit(string catégorie, decimal prixMinimum, bool enStock)
    {
        return produit =>
            (string.IsNullOrEmpty(catégorie) || produit.Catégorie == catégorie) &&
            produit.Prix >= prixMinimum &&
            (!enStock || produit.QuantitéEnStock > 0);
    }
}

// Utilisation
var filtre = new FiltrePersonnalisé();
var filtreÉlectronique = filtre.CréerFiltreProduit("Électronique", 100m, true);
var produitsFiltres = listeProduits.Where(filtreÉlectronique).ToList();
```


#### 2. Configuration d'événements avec contexte

```textmate
public class GestionnaireÉvénements
{
    public void ConfigurerBoutons(List<Button> boutons, string contexte)
    {
        foreach (var bouton in boutons)
        {
            // Chaque lambda capture 'bouton' et 'contexte'
            bouton.Click += (sender, e) => {
                Console.WriteLine($"Bouton {bouton.Name} cliqué dans le contexte: {contexte}");
                // Traitement spécifique...
            };
        }
    }
}
```


#### 3. Mémorisation (memoization) avec fermetures

```textmate
public class Mémoïsation
{
    public Func<int, int> CréerCalculateurMémoïsé(Func<int, int> fonctionCoûteuse)
    {
        // La fermeture capture et stocke le cache
        var cache = new Dictionary<int, int>();

        return n => {
            if (cache.TryGetValue(n, out int résultat))
                return résultat;

            résultat = fonctionCoûteuse(n);
            cache[n] = résultat;
            return résultat;
        };
    }
}

// Utilisation
var calculateur = new Mémoïsation();
Func<int, int> fibonacci = null;

// Définition récursive avec mémoïsation
fibonacci = calculateur.CréerCalculateurMémoïsé(n => {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
});

// Calcul efficace même pour de grandes valeurs
Console.WriteLine(fibonacci(40)); // Rapide grâce au cache
```


#### 4. État privé et encapsulation

```textmate
public class CompteurPersonnalisé
{
    public Func<int> CréerCompteur(int valeurInitiale, int incrément)
    {
        int valeurCourante = valeurInitiale;

        // La fermeture maintient un état privé non accessible de l'extérieur
        return () => {
            int valeurActuelle = valeurCourante;
            valeurCourante += incrément;
            return valeurActuelle;
        };
    }
}

// Utilisation
var fabriqueCompteur = new CompteurPersonnalisé();
var compteur1 = fabriqueCompteur.CréerCompteur(0, 1);
var compteur2 = fabriqueCompteur.CréerCompteur(10, 5);

Console.WriteLine(compteur1()); // 0
Console.WriteLine(compteur1()); // 1
Console.WriteLine(compteur1()); // 2

Console.WriteLine(compteur2()); // 10
Console.WriteLine(compteur2()); // 15
```


#### 5. Middleware et traitement en chaîne

```textmate
public class ChaîneTraitement
{
    public delegate Task<string> MiddlewareHandler(string entrée, Func<string, Task<string>> suivant);

    public Func<string, Task<string>> ConstruireChaîne(IEnumerable<MiddlewareHandler> middleware)
    {
        // Le dernier middleware retourne simplement l'entrée
        Func<string, Task<string>> dernièreÉtape = input => Task.FromResult(input);

        // Construire la chaîne de l'arrière vers l'avant
        var chaîne = middleware
            .Reverse()
            .Aggregate(dernièreÉtape, (suivant, étapeCourante) => {
                // Chaque fermeture capture 'suivant' et 'étapeCourante'
                return async entrée => await étapeCourante(entrée, suivant);
            });

        return chaîne;
    }
}

// Utilisation
var constructeur = new ChaîneTraitement();
var chaîne = constructeur.ConstruireChaîne(new ChaîneTraitement.MiddlewareHandler[] {
    // Logger
    async (entrée, suivant) => {
        Console.WriteLine($"Avant: {entrée}");
        var résultat = await suivant(entrée);
        Console.WriteLine($"Après: {résultat}");
        return résultat;
    },

    // Convertir en majuscules
    async (entrée, suivant) => {
        return await suivant(entrée.ToUpper());
    },

    // Ajouter un préfixe
    async (entrée, suivant) => {
        return await suivant($"Processus: {entrée}");
    }
});

// Exécuter la chaîne
var résultat = await chaîne("test");
// Affiche:
// Avant: test
// Avant: Processus: TEST
// Après: Processus: TEST
// Après: Processus: TEST
```


### Comprendre comment les fermetures sont implémentées

Pour mieux comprendre les fermetures, il est utile de savoir comment elles sont implémentées par le compilateur. En interne, le compilateur crée une classe anonyme pour contenir les variables capturées :

```textmate
// Code source
public Func<int, int> CréerMultiplicateur(int facteur)
{
    return x => x * facteur;
}

// Équivalent approximatif de ce que génère le compilateur
public Func<int, int> CréerMultiplicateur(int facteur)
{
    // Le compilateur crée une classe comme celle-ci:
    var fermeture = new ClasseFermetureGénérée
    {
        facteur = facteur
    };

    return fermeture.MéthodeGénérée;
}

// Classe générée par le compilateur (invisible dans votre code)
private class ClasseFermetureGénérée
{
    // Variable capturée stockée comme champ
    public int facteur;

    // Méthode qui devient le délégué
    public int MéthodeGénérée(int x)
    {
        return x * facteur;
    }
}
```


Cette compréhension aide à expliquer plusieurs aspects du comportement des fermetures, notamment pourquoi les variables capturées sont partagées et pourquoi les lambdas peuvent prolonger la durée de vie des objets.

Les captures de variables (closures) dans les expressions lambda offrent une flexibilité et une puissance exceptionnelles au langage C#. Elles permettent de créer des fonctions qui encapsulent non seulement un comportement mais aussi un état, ouvrant la voie à des modèles de programmation élégants et expressifs.

Que vous utilisiez .NET Framework 4.7.2 ou .NET 8, les fermetures fonctionnent de manière similaire, mais les versions plus récentes de C# offrent des améliorations comme les lambdas statiques et un meilleur traitement des variables de boucle. En comprenant les mécanismes sous-jacents et en suivant les bonnes pratiques, vous pouvez exploiter tout le potentiel des fermetures tout en évitant les pièges courants liés à la performance, à la gestion de la mémoire et à la concurrence.

Utilisées judicieusement, les fermetures sont l'un des outils les plus puissants dans la boîte à outils du développeur C#, permettant d'écrire un code plus concis, plus lisible et plus maintenable.

--

Les expressions lambda représentent l'une des fonctionnalités les plus élégantes et puissantes du langage C#. Elles ont transformé la façon dont nous écrivons du code en permettant d'exprimer des fonctions anonymes de manière concise et expressive.
À travers cette section, nous avons exploré trois aspects fondamentaux des expressions lambda :
Premièrement, la syntaxe des expressions lambda nous offre une manière compacte d'écrire des fonctions anonymes, réduisant considérablement la verbosité du code. La flexibilité syntaxique permet d'adapter les lambdas à différents contextes, qu'il s'agisse d'expressions simples avec un paramètre unique ou de blocs d'instructions plus complexes avec plusieurs paramètres typés.
Deuxièmement, nous avons vu comment les lambdas s'utilisent comme délégués et expressions d'arbre. En tant que délégués, elles permettent de passer des comportements comme arguments à d'autres méthodes, servant de fondement à des paradigmes comme la programmation fonctionnelle et réactive. En tant qu'expressions d'arbre, elles offrent une représentation structurée du code qui peut être analysée, transformée et compilée dynamiquement, comme c'est le cas avec LINQ to SQL ou Entity Framework.
Troisièmement, la capacité des lambdas à capturer des variables de leur contexte environnant (closures) constitue une fonctionnalité particulièrement puissante. Cette capacité permet aux lambdas de maintenir un état au-delà de la portée dans laquelle elles ont été définies, ouvrant la voie à des modèles de conception sophistiqués comme la mémoisation, les générateurs d'usines de fonctions, et les calculs différés.
Les expressions lambda sont devenues un outil indispensable dans le développement C# moderne. Elles sont au cœur de nombreuses API du framework .NET, notamment LINQ, la programmation asynchrone, la gestion d'événements, et les modèles de conception orientés fonctionnels. Leur intégration profonde dans le langage a significativement influencé l'évolution de C# vers un langage multi-paradigme qui combine élégamment les approches orientées objet et fonctionnelles.
Bien qu'elles soient disponibles aussi bien dans .NET Framework 4.7.2 que dans .NET 8, les expressions lambda ont bénéficié d'améliorations continues au fil des versions. Les versions récentes de C# ont apporté des fonctionnalités comme les types de retour explicites, les lambdas statiques, et un meilleur traitement des variables capturées dans les boucles, rendant cette fonctionnalité encore plus puissante et flexible.
En maîtrisant les expressions lambda, les développeurs C# acquièrent un outil qui améliore non seulement la concision et la lisibilité du code, mais qui ouvre également la porte à des modèles de programmation plus expressifs et à une meilleure abstraction des comportements. Que vous développiez sur .NET Framework 4.7.2 ou sur .NET 8, les expressions lambda demeurent une compétence fondamentale pour tout développeur C# souhaitant exploiter pleinement les capacités du langage.
À mesure que C# continue d'évoluer, nous pouvons nous attendre à voir les expressions lambda s'enrichir davantage, renforçant encore la position de C# comme un langage polyvalent et expressif adapté aussi bien à la programmation orientée objet traditionnelle qu'aux approches fonctionnelles modernes.
