 
# 4.1. Définition et appel de méthodes

Les méthodes sont des blocs de code qui exécutent une tâche spécifique et constituent les éléments fondamentaux d'un programme C#. Elles permettent d'organiser le code, de le rendre réutilisable et plus facile à maintenir. Dans cette section, nous allons explorer comment définir et appeler des méthodes en C#.

## 4.1.1. Signature de méthode

La signature d'une méthode est composée de plusieurs éléments qui la définissent de manière unique dans une classe :

- **Modificateurs d'accès** : définissent la visibilité de la méthode (`public`, `private`, `protected`, `internal`)
- **Type de retour** : indique le type de données que la méthode renvoie
- **Nom** : identifiant unique pour la méthode (suit les conventions de nommage PascalCase)
- **Paramètres** : données d'entrée que la méthode peut accepter
- **Corps de la méthode** : contient le code à exécuter

### Syntaxe de base

```textmate
[modificateurs] [type_retour] [nom_méthode]([paramètres])
{
    // Corps de la méthode
    // Instructions à exécuter
}
```


### Exemples de signatures

```textmate
// Méthode publique sans paramètre retournant un entier
public int CalculerAge()

// Méthode privée acceptant deux paramètres et retournant une chaîne
private string FormatNomComplet(string prénom, string nom)

// Méthode protégée acceptant un paramètre de type complexe sans valeur de retour
protected void TraiterCommande(Commande commande)
```


### Paramètres de méthode

Les paramètres permettent de passer des données à une méthode. C# offre plusieurs façons de définir des paramètres :

#### Paramètres standards

```textmate
public double CalculerMontantTTC(double montantHT, double tauxTVA)
{
    return montantHT * (1 + tauxTVA);
}

// Appel
double total = CalculerMontantTTC(100.0, 0.20);
```


#### Paramètres nommés (disponibles dans toutes les versions)

```textmate
// Appel avec paramètres nommés
double total = CalculerMontantTTC(montantHT: 100.0, tauxTVA: 0.20);

// L'ordre n'a plus d'importance
double total = CalculerMontantTTC(tauxTVA: 0.20, montantHT: 100.0);
```


#### Paramètres optionnels

```textmate
public double CalculerMontantTTC(double montantHT, double tauxTVA = 0.20)
{
    return montantHT * (1 + tauxTVA);
}

// Appel sans spécifier le taux TVA (utilise la valeur par défaut)
double total = CalculerMontantTTC(100.0);
```


#### Paramètres de sortie (out)

```textmate
public bool TryParse(string input, out int result)
{
    try
    {
        result = int.Parse(input);
        return true;
    }
    catch
    {
        result = 0;
        return false;
    }
}

// Utilisation dans .NET Framework 4.7.2
int nombre;
if (TryParse("123", out nombre))
{
    Console.WriteLine($"Conversion réussie : {nombre}");
}

// Utilisation simplifiée dans .NET 8
if (TryParse("123", out int nombre))
{
    Console.WriteLine($"Conversion réussie : {nombre}");
}
```


#### Paramètres de référence (ref)

```textmate
public void Permuter(ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}

// Utilisation
int x = 5, y = 10;
Permuter(ref x, ref y);
// Après l'appel : x = 10, y = 5
```


#### Nombre variable de paramètres (params)

```textmate
public double Calculer(string opération, params double[] valeurs)
{
    switch (opération)
    {
        case "somme":
            return valeurs.Sum();
        case "moyenne":
            return valeurs.Average();
        default:
            return 0;
    }
}

// Appels
double somme = Calculer("somme", 1, 2, 3, 4, 5);
double moyenne = Calculer("moyenne", 10, 20, 30);
```


### Différences entre .NET Framework 4.7.2 et .NET 8

Dans .NET 8, C# a introduit de nouvelles fonctionnalités pour les paramètres :

```textmate
// .NET 8 - Déclaration de variable dans l'instruction out
bool succès = int.TryParse("123", out int résultat);

// .NET Framework 4.7.2 - Doit déclarer la variable séparément
int résultat;
bool succès = int.TryParse("123", out résultat);
```


## 4.1.2. Valeurs de retour et void

En C#, une méthode peut retourner une valeur d'un type spécifique ou aucune valeur (void).

### Méthodes retournant une valeur

```textmate
public int Additionner(int a, int b)
{
    return a + b;
}

public string ObtenirNomComplet(string prénom, string nom)
{
    return $"{prénom} {nom}";
}

public bool EstMajeur(int âge)
{
    return âge >= 18;
}

public List<string> FiltrerListe(List<string> liste, string filtre)
{
    return liste.Where(item => item.Contains(filtre)).ToList();
}
```


Une méthode qui déclare un type de retour doit utiliser l'instruction `return` pour renvoyer une valeur compatible avec ce type.

### Méthodes void (sans valeur de retour)

```textmate
public void AfficherMessage(string message)
{
    Console.WriteLine(message);
    // Pas de return nécessaire
}

public void EnregistrerJournal(string événement)
{
    File.AppendAllText("journal.log", $"{DateTime.Now}: {événement}\n");
}
```


L'instruction `return` peut être utilisée dans une méthode void pour sortir prématurément :

```textmate
public void TraiterDonnées(string[] données)
{
    if (données == null || données.Length == 0)
    {
        return; // Sort de la méthode
    }

    // Suite du traitement...
}
```


### Retour de plusieurs valeurs

#### Utilisation des tuples (.NET Framework 4.7.2)

```textmate
// Avec classes auxiliaires
public class StatistiquesRésultat
{
    public double Moyenne { get; set; }
    public double Minimum { get; set; }
    public double Maximum { get; set; }
}

public StatistiquesRésultat CalculerStatistiques(double[] valeurs)
{
    return new StatistiquesRésultat
    {
        Moyenne = valeurs.Average(),
        Minimum = valeurs.Min(),
        Maximum = valeurs.Max()
    };
}

// Utilisation
var stats = CalculerStatistiques(new double[] { 1, 2, 3, 4, 5 });
Console.WriteLine($"Moyenne: {stats.Moyenne}, Min: {stats.Minimum}, Max: {stats.Maximum}");
```


#### Utilisation des tuples (.NET 8)

```textmate
public (double Moyenne, double Minimum, double Maximum) CalculerStatistiques(double[] valeurs)
{
    return (
        valeurs.Average(),
        valeurs.Min(),
        valeurs.Max()
    );
}

// Utilisation
var stats = CalculerStatistiques(new double[] { 1, 2, 3, 4, 5 });
Console.WriteLine($"Moyenne: {stats.Moyenne}, Min: {stats.Minimum}, Max: {stats.Maximum}");

// Ou avec décomposition
var (moy, min, max) = CalculerStatistiques(new double[] { 1, 2, 3, 4, 5 });
Console.WriteLine($"Moyenne: {moy}, Min: {min}, Max: {max}");
```


## 4.1.3. Méthodes statiques vs d'instance

En C#, les méthodes peuvent être définies comme statiques ou d'instance, ce qui influence la façon dont elles sont appelées et les données auxquelles elles ont accès.

### Méthodes d'instance

Les méthodes d'instance sont liées à une instance spécifique d'une classe et peuvent accéder aux champs et propriétés de cette instance.

```textmate
public class Compte
{
    private decimal solde;

    public Compte(decimal soldeInitial)
    {
        solde = soldeInitial;
    }

    // Méthode d'instance
    public void Déposer(decimal montant)
    {
        if (montant <= 0)
            throw new ArgumentException("Le montant doit être positif");

        solde += montant;
    }

    // Méthode d'instance
    public bool Retirer(decimal montant)
    {
        if (montant > solde)
            return false;

        solde -= montant;
        return true;
    }

    // Méthode d'instance
    public decimal ObtenirSolde()
    {
        return solde;
    }
}

// Utilisation
Compte monCompte = new Compte(1000);
monCompte.Déposer(500);
bool succès = monCompte.Retirer(200);
decimal soldeActuel = monCompte.ObtenirSolde(); // 1300
```


Les méthodes d'instance :
- Sont appelées sur une instance spécifique d'une classe
- Peuvent accéder aux membres non-statiques de la classe
- Ne peuvent pas être appelées sans une instance de la classe
- Ont accès au mot-clé `this` qui fait référence à l'instance actuelle

### Méthodes statiques

Les méthodes statiques appartiennent à la classe elle-même, et non à une instance spécifique. Elles sont généralement utilisées pour des opérations qui ne nécessitent pas d'état d'instance.

```textmate
public class CalculateurFinancier
{
    // Méthode statique
    public static decimal CalculerIntérêts(decimal principal, decimal taux, int années)
    {
        return principal * taux * années;
    }

    // Méthode statique
    public static decimal CalculerMensualité(decimal montantEmprunt, decimal tauxAnnuel, int nombreMois)
    {
        decimal tauxMensuel = tauxAnnuel / 12;
        return montantEmprunt * tauxMensuel * (decimal)Math.Pow((double)(1 + tauxMensuel), nombreMois) /
               ((decimal)Math.Pow((double)(1 + tauxMensuel), nombreMois) - 1);
    }
}

// Utilisation
decimal intérêts = CalculateurFinancier.CalculerIntérêts(10000, 0.05m, 3);
decimal mensualité = CalculateurFinancier.CalculerMensualité(200000, 0.03m, 240);
```


Les méthodes statiques :
- Sont appelées directement sur la classe, sans créer d'instance
- Ne peuvent pas accéder aux membres non-statiques de la classe
- Ne peuvent pas utiliser le mot-clé `this`
- Sont souvent utilisées pour des fonctions utilitaires ou des opérations indépendantes de l'état
- Sont chargées en mémoire à la première utilisation de la classe

### Classes d'extension

À partir de C# 3.0, il est possible de créer des méthodes d'extension qui ajoutent des fonctionnalités à des types existants sans les modifier directement.

```textmate
// Classe statique contenant des méthodes d'extension
public static class StringExtensions
{
    // Méthode d'extension pour le type string
    public static bool EstNullOuVide(this string valeur)
    {
        return string.IsNullOrEmpty(valeur);
    }

    // Méthode d'extension avec paramètres
    public static string TronquerTexte(this string texte, int longueurMax)
    {
        if (texte == null) return null;

        if (texte.Length <= longueurMax)
            return texte;

        return texte.Substring(0, longueurMax) + "...";
    }
}

// Utilisation
string message = "Bonjour le monde";
bool estVide = message.EstNullOuVide(); // false
string texteTronqué = message.TronquerTexte(7); // "Bonjour..."
```


Les méthodes d'extension :
- Sont définies dans des classes statiques
- Doivent être elles-mêmes statiques
- Utilisent le mot-clé `this` comme premier paramètre pour indiquer le type étendu
- Sont appelées comme des méthodes d'instance sur le type étendu
- Sont particulièrement utiles pour ajouter des fonctionnalités à des types que vous ne pouvez pas modifier
- Sont largement utilisées dans LINQ (Language Integrated Query)

### Choix entre méthodes statiques et d'instance

Le choix entre une méthode statique et une méthode d'instance dépend principalement de :

1. **Dépendance à l'état** : Si la méthode dépend de l'état de l'instance, elle devrait être une méthode d'instance.
2. **Logique utilitaire** : Si la méthode fournit une fonctionnalité utilitaire indépendante, elle peut être statique.
3. **Testabilité** : Les méthodes d'instance sont généralement plus faciles à mocker pour les tests unitaires.
4. **Performance** : Les méthodes statiques peuvent être légèrement plus performantes car elles évitent le lookup d'instance.

### Différences entre .NET Framework 4.7.2 et .NET 8

Les principes fondamentaux des méthodes statiques et d'instance sont identiques entre .NET Framework 4.7.2 et .NET 8. Cependant, .NET 8 introduit quelques améliorations syntaxiques et fonctionnelles :

- Support amélioré pour les méthodes d'extension génériques
- Performances optimisées pour les appels de méthodes
- Support des méthodes d'interface statiques (à partir de C# 8.0)

```textmate
// Exemple de méthode d'interface statique (disponible uniquement dans .NET Core/.NET)
public interface IConvertissable<T>
{
    static abstract T Convertir(string valeur);
}

public class Entier : IConvertissable<int>
{
    public static int Convertir(string valeur)
    {
        return int.Parse(valeur);
    }
}
```


En résumé, la compréhension des méthodes, de leurs signatures, types de retour et nature (statique ou d'instance) constitue une base fondamentale pour structurer efficacement le code en C#. Ces concepts sont applicables dans toutes les versions de C# avec quelques différences syntaxiques entre .NET Framework 4.7.2 et .NET 8 pour les fonctionnalités les plus récentes.
