# 4.2. Paramètres et valeurs de retour

La gestion des paramètres et des valeurs de retour est un aspect fondamental de la conception de méthodes en C#. Cette section explore les différentes façons de passer des données aux méthodes et de récupérer les résultats, avec un accent sur les fonctionnalités disponibles dans les versions .NET Framework 4.7.2 et .NET 8.

## 4.2.1. Passage par valeur vs référence (ref, out)

En C#, les paramètres peuvent être passés à une méthode de différentes manières, ce qui affecte la façon dont les modifications apportées aux paramètres dans la méthode sont répercutées à l'extérieur.

### Passage par valeur (comportement par défaut)

Par défaut, C# passe les paramètres par valeur, ce qui signifie qu'une copie de la variable est transmise à la méthode.

```textmate
public void IncrémenterNombre(int nombre)
{
    nombre += 1; // Modifie uniquement la copie locale
    Console.WriteLine($"Dans la méthode: {nombre}");
}

// Utilisation
int x = 5;
IncrémenterNombre(x);
Console.WriteLine($"Après l'appel: {x}"); // Affiche toujours 5, car la valeur d'origine n'est pas modifiée
```


Points importants sur le passage par valeur :
- Pour les types valeur (int, double, struct, etc.), une copie complète des données est créée
- Pour les types référence (objets, tableaux, etc.), une copie de la référence est passée, mais pas l'objet lui-même
- Les modifications à la référence elle-même (réaffectation) ne sont pas visibles à l'extérieur, mais les modifications au contenu de l'objet le sont

```textmate
public void ModifierListe(List<int> liste)
{
    liste.Add(42); // Modifie le contenu de l'objet - visible à l'extérieur
    liste = new List<int>(); // Réassigne la référence - visible uniquement dans la méthode
}

// Utilisation
var nombres = new List<int> { 1, 2, 3 };
ModifierListe(nombres);
Console.WriteLine(string.Join(", ", nombres)); // Affiche "1, 2, 3, 42"
```


### Passage par référence (ref)

Le mot-clé `ref` permet de passer une variable par référence, ce qui signifie que la méthode opère directement sur la variable d'origine, et non sur une copie.

```textmate
public void IncrémenterNombre(ref int nombre)
{
    nombre += 1; // Modifie la variable d'origine
}

// Utilisation
int x = 5;
IncrémenterNombre(ref x);
Console.WriteLine(x); // Affiche 6
```


Pour utiliser un paramètre `ref` :
- La variable doit être initialisée avant d'être passée à la méthode
- Le mot-clé `ref` doit apparaître à la fois dans la déclaration de la méthode et lors de l'appel

Exemple plus complexe - permutation de deux variables :

```textmate
public void Permuter<T>(ref T a, ref T b)
{
    T temp = a;
    a = b;
    b = temp;
}

// Utilisation
string premier = "Bonjour";
string second = "Monde";
Permuter(ref premier, ref second);
Console.WriteLine($"{premier} {second}"); // Affiche "Monde Bonjour"
```


### Paramètres de sortie (out)

Le mot-clé `out` est similaire à `ref`, mais avec deux différences clés :
1. La variable n'a pas besoin d'être initialisée avant l'appel
2. La méthode doit assigner une valeur au paramètre avant de se terminer

```textmate
public bool DiviserSansException(int dividende, int diviseur, out int résultat)
{
    if (diviseur == 0)
    {
        résultat = 0; // Doit être assigné même en cas d'erreur
        return false;
    }

    résultat = dividende / diviseur;
    return true;
}

// Utilisation dans .NET Framework 4.7.2
int quotient;
if (DiviserSansException(10, 2, out quotient))
{
    Console.WriteLine($"Résultat: {quotient}"); // Affiche "Résultat: 5"
}

// Utilisation dans .NET 8 avec déclaration inline
if (DiviserSansException(10, 2, out int résultat))
{
    Console.WriteLine($"Résultat: {résultat}"); // Affiche "Résultat: 5"
}
```


Le pattern TryParse est un exemple classique d'utilisation de `out` dans le framework .NET :

```textmate
// Conversion sécurisée de chaîne en nombre
if (int.TryParse("123", out int nombre))
{
    Console.WriteLine($"Conversion réussie: {nombre}");
}
else
{
    Console.WriteLine("Échec de la conversion");
}
```


### Paramètres in (C# 7.2+)

Disponible à partir de C# 7.2 (compatible avec .NET Framework 4.7.2 et .NET 8), le mot-clé `in` passe un paramètre par référence mais empêche sa modification :

```textmate
public void AfficherCoordonnées(in Point point)
{
    // point.X = 5; // Erreur de compilation - ne peut pas modifier un paramètre in
    Console.WriteLine($"X: {point.X}, Y: {point.Y}");
}

// Utilisation
var position = new Point(10, 20);
AfficherCoordonnées(in position);
```


Le mot-clé `in` est utile pour :
- Éviter la copie des structures volumineuses
- Garantir qu'une méthode ne modifiera pas un paramètre
- Améliorer les performances pour les grandes structures

## 4.2.2. Paramètres de tableau params

Le mot-clé `params` permet à une méthode d'accepter un nombre variable d'arguments du même type, ce qui rend l'API plus flexible et intuitive.

```textmate
public int Additionner(params int[] nombres)
{
    int somme = 0;
    foreach (int nombre in nombres)
    {
        somme += nombre;
    }
    return somme;
}

// Utilisation
int total1 = Additionner(1, 2);
int total2 = Additionner(1, 2, 3, 4, 5);
int total3 = Additionner(); // Tableau vide

// Ou avec un tableau existant
int[] valeurs = { 10, 20, 30 };
int total4 = Additionner(valeurs);
```


Règles importantes pour `params` :
- Doit être le dernier paramètre de la méthode
- Une méthode ne peut avoir qu'un seul paramètre `params`
- Un tableau vide est créé si aucun argument n'est fourni
- Compatible avec les tableaux multidimensionnels et les types génériques

```textmate
// Exemple plus complexe avec plusieurs paramètres
public string Formater(string format, params object[] arguments)
{
    return string.Format(format, arguments);
}

// Utilisation
string message = Formater("Bonjour {0}, vous avez {1} messages", "Marie", 5);
```


## 4.2.3. Tuples comme valeurs de retour (C# 7+)

Les tuples facilitent le retour de plusieurs valeurs depuis une méthode sans créer une classe ou une structure dédiée.

### Tuples sans noms (forme de base)

```textmate
// Retourne un tuple de deux entiers
public (int, int) DivisionEtReste(int dividende, int diviseur)
{
    int quotient = dividende / diviseur;
    int reste = dividende % diviseur;
    return (quotient, reste);
}

// Utilisation dans .NET Framework 4.7.2 et .NET 8
var résultat = DivisionEtReste(10, 3);
Console.WriteLine($"Quotient: {résultat.Item1}, Reste: {résultat.Item2}");
```


### Tuples nommés (plus lisibles)

```textmate
// Retourne un tuple avec des éléments nommés
public (int Quotient, int Reste) DivisionEtReste(int dividende, int diviseur)
{
    return (dividende / diviseur, dividende % diviseur);
}

// Utilisation avec les noms
var résultat = DivisionEtReste(10, 3);
Console.WriteLine($"Quotient: {résultat.Quotient}, Reste: {résultat.Reste}");
```


### Décomposition des tuples

```textmate
// Décomposition lors de l'assignation
var (quotient, reste) = DivisionEtReste(10, 3);
Console.WriteLine($"Quotient: {quotient}, Reste: {reste}");

// Décomposition avec des variables existantes
int q, r;
(q, r) = DivisionEtReste(20, 6);
```


### Tuples et types génériques

```textmate
public (T Max, T Min, double Average) CalculerStatistiques<T>(IEnumerable<T> valeurs)
    where T : IComparable<T>
{
    T max = valeurs.Max();
    T min = valeurs.Min();
    double avg = valeurs.OfType<IConvertible>()
                        .Average(v => Convert.ToDouble(v));
    return (max, min, avg);
}

// Utilisation
var nombres = new[] { 1, 5, 3, 9, 2 };
var stats = CalculerStatistiques(nombres);
Console.WriteLine($"Max: {stats.Max}, Min: {stats.Min}, Moyenne: {stats.Average:F2}");
```


### Compatibilité

Les tuples nommés sont disponibles à partir de C# 7.0, compatible avec :
- .NET Framework 4.7.2 (avec le package NuGet `System.ValueTuple`)
- .NET Core 2.0 et versions ultérieures
- .NET 5/6/7/8

## 4.2.4. Discards (C# 7+)

Les discards (représentés par le caractère `_`) permettent d'ignorer certaines valeurs de retour lorsqu'elles ne sont pas nécessaires.

### Ignorer des valeurs de retour de tuples

```textmate
// On ne s'intéresse qu'au quotient
var (quotient, _) = DivisionEtReste(10, 3);
Console.WriteLine($"Quotient: {quotient}");

// On ne s'intéresse qu'au reste
var (_, reste) = DivisionEtReste(10, 3);
Console.WriteLine($"Reste: {reste}");
```


### Discards avec out

```textmate
// Dans .NET Framework 4.7.2
int nombre;
// Ignorer le booléen de retour si on est certain que la conversion réussira
int.TryParse("123", out nombre);

// Dans .NET 8
// Ignorer complètement la valeur de retour
int.TryParse("123", out _);

// Ou simplement vérifier si la conversion est possible
bool estValide = int.TryParse("123", out _);
```


### Discards multiples

```textmate
// Retourne des statistiques complètes
public (int Min, int Max, double Moyenne, int Médiane) AnalyserDonnées(int[] données)
{
    return (
        données.Min(),
        données.Max(),
        données.Average(),
        données.OrderBy(x => x).ElementAt(données.Length / 2)
    );
}

// Utilisation - on ignore plusieurs valeurs
var (minimum, maximum, _, _) = AnalyserDonnées(new[] { 1, 5, 3, 9, 2 });
Console.WriteLine($"Plage: {minimum} à {maximum}");
```


### Cas d'utilisation des discards

1. **Simplification du code** : Lorsque certaines valeurs de retour ne sont pas nécessaires
2. **Méthodes avec plusieurs valeurs out** : Pour ignorer certaines valeurs out non utilisées
3. **Pattern matching** : Pour ignorer certaines parties dans les expressions de pattern matching

```textmate
// Pattern matching avec discard (.NET 8)
object valeur = "test";
if (valeur is string { Length: > 0 } _)
{
    Console.WriteLine("C'est une chaîne non vide");
}
```


### Variables anonymes vs discards

Attention à ne pas confondre les discards avec l'utilisation de variables nommées `_` :

```textmate
// Ceci est un discard - la valeur est vraiment ignorée
_ = Console.ReadLine();

// Ceci est une variable nommée "_" - la valeur est stockée et peut être réutilisée
string _ = Console.ReadLine();
Console.WriteLine(_); // Utilise la variable nommée "_"
```


### Compatibilité

Les discards sont disponibles à partir de C# 7.0, supportés dans :
- .NET Framework 4.7.2 et versions ultérieures
- .NET Core 2.0 et versions ultérieures
- .NET 5/6/7/8

## Résumé et bonnes pratiques

### Quand utiliser les différents types de paramètres

- **Valeur (par défaut)** : Pour les types simples et lorsque la méthode ne doit pas modifier les paramètres
- **ref** : Lorsque la méthode doit modifier la variable passée en paramètre
- **out** : Lorsque la méthode doit retourner plusieurs valeurs, et que le caller n'a pas besoin d'initialiser les variables
- **in** : Pour les structures volumineuses qui ne doivent pas être modifiées
- **params** : Pour simplifier l'API lorsqu'une méthode accepte un nombre variable d'arguments du même type

### Recommandations pour les valeurs de retour

- Pour une seule valeur, utilisez un type de retour simple
- Pour 2-3 valeurs fortement liées, les tuples sont appropriés
- Pour plus de 3 valeurs ou une structure complexe, créez une classe ou une structure dédiée
- Utilisez les discards pour améliorer la lisibilité lorsque certaines valeurs de retour sont ignorées

### Différences entre .NET Framework 4.7.2 et .NET 8

La plupart des fonctionnalités présentées sont disponibles dans les deux versions, avec quelques différences :

- Dans .NET Framework 4.7.2, les tuples nommés nécessitent le package NuGet `System.ValueTuple`
- .NET 8 offre des améliorations de performances pour les tuples et ref struct
- La syntaxe de déclaration inline avec out (ex: `out int x`) est disponible dans les deux versions mais plus couramment utilisée dans .NET 8
- .NET 8 prend en charge des fonctionnalités plus récentes comme les ref structs readonly et les ref returns non disponibles dans .NET Framework 4.7.2

Les paramètres et valeurs de retour constituent un domaine où C# a connu des évolutions significatives, offrant aux développeurs des outils plus expressifs et performants pour concevoir des API élégantes et intuitives.
