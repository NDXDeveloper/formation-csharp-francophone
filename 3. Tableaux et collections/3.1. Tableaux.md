# 3.1. Tableaux

![Tableaux en C#](https://via.placeholder.com/600x150?text=Tableaux+en+C%23)

Les tableaux constituent l'une des structures de données fondamentales en C#. Ils permettent de stocker des collections d'éléments de même type dans un espace mémoire contigu, offrant un accès rapide à n'importe quel élément via son index.

## 3.1.1. Tableaux unidimensionnels

Les tableaux unidimensionnels sont les tableaux les plus simples, représentant une séquence linéaire d'éléments.

### Déclaration et initialisation

```
// Déclaration sans initialisation
int[] nombres;

// Déclaration avec allocation (crée un tableau de 5 entiers, tous initialisés à 0)
int[] scores = new int[5];

// Déclaration et initialisation avec des valeurs spécifiques
int[] valeurs = new int[] { 10, 20, 30, 40, 50 };

// Syntaxe abrégée (inférence de type par le compilateur)
int[] prix = { 15, 25, 35, 45 };

// Tableau vide
int[] vide = new int[0];
// ou plus efficacement en mémoire
int[] vide2 = Array.Empty<int>();
```


### Accès aux éléments

```
int[] scores = { 85, 92, 78, 95, 88 };

// Accès par index (les indices commencent à 0)
int premierScore = scores[0];      // 85
int troisièmeScore = scores[2];    // 78

// Modification d'un élément
scores[1] = 94;                    // Le tableau devient { 85, 94, 78, 95, 88 }

// Propriété Length (nombre d'éléments)
int taille = scores.Length;        // 5

// Accès au dernier élément
int dernierScore = scores[scores.Length - 1];  // 88

// UNIQUEMENT dans .NET Core 3.0+ et .NET 8 (pas disponible en .NET Framework 4.7.2)
// Accès avec les nouveaux opérateurs Index et Range
// int dernierIndex = scores[^1];     // 88 (dernier élément)
// int avantDernier = scores[^2];     // 95 (avant-dernier élément)
// int[] sousTableau = scores[1..4];  // { 94, 78, 95 } (du 2ème au 4ème, exclusif)
```


### Parcours d'un tableau

```
int[] nombres = { 10, 20, 30, 40, 50 };

// Parcours avec une boucle for
for (int i = 0; i < nombres.Length; i++)
{
    Console.WriteLine($"nombres[{i}] = {nombres[i]}");
}

// Parcours avec foreach (lecture seule)
foreach (int nombre in nombres)
{
    Console.WriteLine(nombre);
}

// Parcours avec LINQ
nombres.ToList().ForEach(nombre => Console.WriteLine(nombre));
```


### Tableaux de différents types

```
// Tableau de types valeur
int[] entiers = { 1, 2, 3 };
double[] decimaux = { 1.1, 2.2, 3.3 };
bool[] booléens = { true, false, true };

// Tableau de types référence
string[] noms = { "Alice", "Bob", "Charlie" };
object[] objets = { "texte", 123, true, 3.14 };

// Tableau de types définis par l'utilisateur
// Supposons qu'une classe Person soit définie
Person[] personnes = new Person[3];
personnes[0] = new Person("Alice", 30);
personnes[1] = new Person("Bob", 25);
personnes[2] = new Person("Charlie", 35);
```


### Tableau comme paramètre et valeur de retour

```
// Tableau comme paramètre de méthode
void AfficherTableau(int[] tableau)
{
    foreach (int valeur in tableau)
    {
        Console.WriteLine(valeur);
    }
}

// Appel avec tableau existant
int[] nombres = { 1, 2, 3, 4, 5 };
AfficherTableau(nombres);

// Appel avec création à la volée
AfficherTableau(new int[] { 10, 20, 30 });
// ou
AfficherTableau(new[] { 10, 20, 30 });

// Utilisation du mot-clé params
void AfficherNombres(params int[] nombres)
{
    foreach (int n in nombres)
    {
        Console.WriteLine(n);
    }
}

// Appel avec liste d'arguments variable
AfficherNombres(1, 2, 3);
AfficherNombres(10, 20);

// Méthode retournant un tableau
int[] CréerTableau(int taille, int valeurInitiale)
{
    int[] résultat = new int[taille];

    for (int i = 0; i < taille; i++)
    {
        résultat[i] = valeurInitiale;
    }

    return résultat;
}

// Utilisation
int[] nouveauTableau = CréerTableau(5, 10);  // [10, 10, 10, 10, 10]
```


## 3.1.2. Tableaux multidimensionnels

Les tableaux multidimensionnels permettent de représenter des données sous forme de matrices ou de structures à plusieurs dimensions.

### Tableaux rectangulaires (dimensions fixes)

```
// Déclaration d'un tableau 2D (3 lignes, 4 colonnes)
int[,] matrice = new int[3, 4];

// Initialisation avec des valeurs
int[,] grille = new int[,]
{
    { 1, 2, 3, 4 },
    { 5, 6, 7, 8 },
    { 9, 10, 11, 12 }
};

// Syntaxe abrégée
int[,] tableau2D = {
    { 1, 2, 3 },
    { 4, 5, 6 }
};

// Accès aux éléments
int valeur = grille[1, 2];  // 7 (2ème ligne, 3ème colonne)
grille[0, 3] = 42;          // Modification d'un élément

// Propriétés
int dimensions = grille.Rank;       // 2 (nombre de dimensions)
int tailleTotal = grille.Length;    // 12 (nombre total d'éléments)
int lignes = grille.GetLength(0);   // 3 (nombre de lignes)
int colonnes = grille.GetLength(1); // 4 (nombre de colonnes)

// Parcours avec boucles imbriquées
for (int i = 0; i < grille.GetLength(0); i++)
{
    for (int j = 0; j < grille.GetLength(1); j++)
    {
        Console.Write($"{grille[i, j]}\t");
    }
    Console.WriteLine();
}
```


### Tableaux à 3 dimensions ou plus

```
// Tableau 3D (2 x 3 x 4)
int[,,] cube = new int[2, 3, 4];

// Initialisation
int[,,] petit = new int[,,]
{
    {
        { 1, 2 },
        { 3, 4 },
        { 5, 6 }
    },
    {
        { 7, 8 },
        { 9, 10 },
        { 11, 12 }
    }
};  // 2 x 3 x 2

// Accès
int valeur = petit[1, 0, 1];  // 8 (2ème "plan", 1ère ligne, 2ème colonne)

// Parcours
for (int i = 0; i < petit.GetLength(0); i++)
{
    for (int j = 0; j < petit.GetLength(1); j++)
    {
        for (int k = 0; k < petit.GetLength(2); k++)
        {
            Console.WriteLine($"petit[{i}, {j}, {k}] = {petit[i, j, k]}");
        }
    }
}
```


## 3.1.3. Tableaux en dents de scie (jagged arrays)

Les tableaux en dents de scie (ou tableaux irréguliers) sont des tableaux de tableaux. Contrairement aux tableaux multidimensionnels, chaque "ligne" peut avoir une longueur différente.

### Création et initialisation

```
// Déclaration d'un tableau de tableaux
int[][] tableau = new int[3][];

// Initialisation de chaque "ligne"
tableau[0] = new int[] { 1, 2, 3 };
tableau[1] = new int[] { 4, 5 };
tableau[2] = new int[] { 6, 7, 8, 9 };

// Initialisation directe
int[][] nombres = new int[][]
{
    new int[] { 1, 2, 3 },
    new int[] { 4, 5 },
    new int[] { 6, 7, 8, 9 }
};

// Syntaxe abrégée
int[][] valeurs = {
    new[] { 10, 20 },
    new[] { 30, 40, 50 },
    new[] { 60 }
};
```


### Accès aux éléments

```
int[][] triangle = new int[][]
{
    new int[] { 1 },
    new int[] { 1, 1 },
    new int[] { 1, 2, 1 },
    new int[] { 1, 3, 3, 1 }
};

// Accès à un élément
int milieu = triangle[2][1];  // 2 (3ème ligne, 2ème élément)

// Modification d'un élément
triangle[1][0] = 5;  // La 2ème ligne devient { 5, 1 }

// Propriétés et dimensions
int lignes = triangle.Length;                // 4 (nombre de lignes)
int élémentsLigne3 = triangle[2].Length;     // 3 (nombre d'éléments dans la 3ème ligne)

// Parcours complet
for (int i = 0; i < triangle.Length; i++)
{
    for (int j = 0; j < triangle[i].Length; j++)
    {
        Console.Write($"{triangle[i][j]} ");
    }
    Console.WriteLine();
}

// Avec foreach
foreach (int[] ligne in triangle)
{
    foreach (int élément in ligne)
    {
        Console.Write($"{élément} ");
    }
    Console.WriteLine();
}
```


### Tableaux en dents de scie vs rectangulaires

```
// Comparaison des deux approches

// 1. Tableau rectangulaire (toutes les lignes ont la même longueur)
int[,] rectangulaire = new int[3, 4]
{
    { 1, 2, 3, 4 },
    { 5, 6, 7, 8 },
    { 9, 10, 11, 12 }
};

// 2. Tableau en dents de scie (les lignes peuvent avoir des longueurs différentes)
int[][] dentsDeScie = new int[][]
{
    new int[] { 1, 2, 3, 4 },
    new int[] { 5, 6 },
    new int[] { 7, 8, 9 }
};

// Avantages des tableaux rectangulaires:
// - Plus compacts en mémoire
// - Syntaxe plus simple pour les dimensions uniformes
// - Plus faciles à parcourir uniformément

// Avantages des tableaux en dents de scie:
// - Flexibilité pour des lignes de longueurs variables
// - Possibilité d'ajouter/supprimer des lignes entières
// - Chaque ligne est un tableau standard utilisable avec des méthodes Array

// Cas d'utilisation typiques:
// - Tableaux rectangulaires: matrices mathématiques, grilles de jeu, images
// - Tableaux en dents de scie: données avec structure variable, triangle de Pascal
```


### Tableaux en dents de scie à plusieurs niveaux

```
// Tableau à trois niveaux
int[][][] triplement = new int[2][][];

triplement[0] = new int[3][];
triplement[0][0] = new int[] { 1, 2 };
triplement[0][1] = new int[] { 3 };
triplement[0][2] = new int[] { 4, 5, 6 };

triplement[1] = new int[2][];
triplement[1][0] = new int[] { 7, 8, 9 };
triplement[1][1] = new int[] { 10 };

// Accès
int valeur = triplement[0][2][1];  // 5

// Parcours à trois niveaux
for (int i = 0; i < triplement.Length; i++)
{
    for (int j = 0; j < triplement[i].Length; j++)
    {
        for (int k = 0; k < triplement[i][j].Length; k++)
        {
            Console.WriteLine($"triplement[{i}][{j}][{k}] = {triplement[i][j][k]}");
        }
    }
}
```


## 3.1.4. Méthodes utiles pour manipuler des tableaux

La classe `Array` fournit de nombreuses méthodes statiques pour travailler avec des tableaux.

### Tri et recherche

```
// Tableau de démonstration
int[] nombres = { 23, 12, 86, 32, 15, 89, 45, 76 };
string[] noms = { "Zoe", "Alice", "Bob", "Charlie", "David" };

// Tri d'un tableau
Array.Sort(nombres);  // [12, 15, 23, 32, 45, 76, 86, 89]

// Tri d'un tableau avec un comparateur personnalisé
Array.Sort(noms, StringComparer.OrdinalIgnoreCase);  // ["Alice", "Bob", "Charlie", "David", "Zoe"]

// Tri avec deux tableaux (le premier contrôle le tri, le second suit)
int[] âges = { 30, 25, 40, 20, 35 };
string[] personnes = { "Alice", "Bob", "Charlie", "David", "Eve" };
Array.Sort(âges, personnes);  // Trie les deux tableaux selon les âges

// Recherche dans un tableau trié (retourne l'index)
int index = Array.BinarySearch(nombres, 45);  // Plus rapide que IndexOf sur un tableau trié

// Recherche linéaire (fonctionne sur des tableaux non triés)
int position = Array.IndexOf(noms, "Charlie");
int dernière = Array.LastIndexOf(noms, "Bob");

// Recherche avec prédicat
int premier = Array.FindIndex(nombres, n => n > 50);  // Index du premier élément > 50
int[] grands = Array.FindAll(nombres, n => n > 50);   // Tous les éléments > 50

// Vérification
bool tousPositifs = Array.TrueForAll(nombres, n => n > 0);
bool auMoinsUn = Array.Exists(nombres, n => n % 2 == 0);
```


### Modification de tableaux

```
int[] valeurs = { 1, 2, 3, 4, 5 };

// Copie de tableau
int[] copie = new int[valeurs.Length];
Array.Copy(valeurs, copie, valeurs.Length);

// Copie avec décalage
int[] destination = new int[10];  // Tableau plus grand
Array.Copy(valeurs, 0, destination, 2, valeurs.Length);
// destination = [0, 0, 1, 2, 3, 4, 5, 0, 0, 0]

// Création d'une copie exacte
int[] clone = (int[])valeurs.Clone();

// Remplissage d'un tableau
int[] zéros = new int[5];
Array.Fill(zéros, 0);  // [0, 0, 0, 0, 0]

// Remplissage partiel
Array.Fill(zéros, 9, 1, 3);  // [0, 9, 9, 9, 0]

// Inverser un tableau
Array.Reverse(valeurs);  // [5, 4, 3, 2, 1]

// Inverser une portion
Array.Reverse(valeurs, 1, 3);  // [5, 2, 3, 4, 1]

// Redimensionnement (crée un nouveau tableau)
Array.Resize(ref valeurs, 7);  // [5, 2, 3, 4, 1, 0, 0]
Array.Resize(ref valeurs, 3);  // [5, 2, 3]
```


### Méthodes d'extension LINQ

Les tableaux implémentent `IEnumerable<T>`, ce qui permet d'utiliser les puissantes méthodes d'extension LINQ.

```
int[] données = { 5, 2, 9, 1, 5, 6, 3, 8, 4, 7 };

// Filtrage
int[] supérieursA5 = données.Where(x => x > 5).ToArray();  // [9, 6, 8, 7]

// Projection
int[] carrés = données.Select(x => x * x).ToArray();  // [25, 4, 81, 1, 25, 36, 9, 64, 16, 49]

// Tri
int[] triés = données.OrderBy(x => x).ToArray();  // [1, 2, 3, 4, 5, 5, 6, 7, 8, 9]
int[] triésDesc = données.OrderByDescending(x => x).ToArray();  // [9, 8, 7, 6, 5, 5, 4, 3, 2, 1]

// Aggrégation
int somme = données.Sum();  // 50
double moyenne = données.Average();  // 5.0
int min = données.Min();  // 1
int max = données.Max();  // 9
int compteur = données.Count();  // 10
int compteurPair = données.Count(x => x % 2 == 0);  // 5

// Autres opérations
bool tousPairs = données.All(x => x % 2 == 0);  // false
bool auMoinsUnPair = données.Any(x => x % 2 == 0);  // true
int[] distincts = données.Distinct().ToArray();  // [5, 2, 9, 1, 6, 3, 8, 4, 7]
int[] prémiers3 = données.Take(3).ToArray();  // [5, 2, 9]
int[] sauf3premiers = données.Skip(3).ToArray();  // [1, 5, 6, 3, 8, 4, 7]

// Combinaison d'opérations
int[] résultat = données
    .Where(x => x % 2 == 0)     // Garder les pairs
    .OrderBy(x => x)            // Trier croissant
    .Skip(1)                    // Sauter le premier
    .Take(2)                    // Prendre les 2 suivants
    .ToArray();                 // [4, 6]
```


### Comparaison entre .NET Framework 4.7.2 et .NET 8

```
// Fonctionnalités disponibles uniquement dans .NET Core/.NET 8 (pas en .NET Framework 4.7.2)

// 1. Index et Range
int[] données = { 1, 2, 3, 4, 5 };

// Disponible dans .NET Core 3.0+ et .NET 8
// Index index = ^1;              // Dernier élément
// int dernier = données[index];  // 5
// Range plage = 1..4;            // Du deuxième au quatrième (exclusif)
// int[] milieu = données[plage]; // [2, 3, 4]

// 2. Span<T> (disponible en .NET Standard 2.1, .NET Core 2.0+ et .NET 8)
// Span<int> section = données.AsSpan(1, 3);  // Vue sur [2, 3, 4]
// section[0] = 10;                           // Modifie l'original: [1, 10, 3, 4, 5]

// 3. Méthodes d'extension utiles (ajoutées en versions récentes)

// Available in .NET Standard 2.1+, .NET Core 2.1+ or .NET 8
// indexOf = données.AsSpan().IndexOf(3);    // 2
```


### Cas d'utilisation courants

```
// 1. Manipulation d'image (tableau 2D)
byte[,] image = new byte[height, width];  // Image en niveaux de gris

// Application d'un filtre
for (int y = 1; y < height - 1; y++)
{
    for (int x = 1; x < width - 1; x++)
    {
        // Filtre de flou (moyenne des voisins)
        byte somme = (byte)(
            image[y-1, x-1] + image[y-1, x] + image[y-1, x+1] +
            image[y, x-1]   + image[y, x]   + image[y, x+1] +
            image[y+1, x-1] + image[y+1, x] + image[y+1, x+1]
        );
        image[y, x] = (byte)(somme / 9);
    }
}

// 2. Implémentation d'une matrice creuse (tableau en dents de scie)
// Utile quand la plupart des cellules sont vides
Dictionary<int, int[]> matriceCreuse = new Dictionary<int, int[]>();
matriceCreuse[3] = new int[] { 1, 0, 7 };  // Seulement la ligne 3 contient des données

// 3. Tampon circulaire avec tableau (pour traitement de flux)
public class TamponCirculaire<T>
{
    private T[] _données;
    private int _tête = 0;
    private int _queue = 0;
    private int _taille = 0;

    public TamponCirculaire(int capacité)
    {
        _données = new T[capacité];
    }

    public void Ajouter(T item)
    {
        if (_taille == _données.Length)
            throw new InvalidOperationException("Le tampon est plein");

        _données[_queue] = item;
        _queue = (_queue + 1) % _données.Length;
        _taille++;
    }

    public T Retirer()
    {
        if (_taille == 0)
            throw new InvalidOperationException("Le tampon est vide");

        T item = _données[_tête];
        _tête = (_tête + 1) % _données.Length;
        _taille--;
        return item;
    }

    public int Taille => _taille;
    public int Capacité => _données.Length;
}
```


---

Cette section a couvert les bases et les techniques avancées de manipulation des tableaux en C#. Les tableaux constituent le fondement de nombreuses structures de données plus complexes, et leur maîtrise est essentielle pour tout développeur C#. Dans les sections suivantes, nous explorerons les collections génériques qui offrent plus de flexibilité que les tableaux traditionnels.
