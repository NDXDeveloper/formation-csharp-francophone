 
# 7.3. Contr√¥les de base et leurs propri√©t√©s

Les contr√¥les sont les √©l√©ments fondamentaux de toute interface utilisateur Windows Forms. Cette section pr√©sente les contr√¥les les plus couramment utilis√©s, leurs propri√©t√©s principales, et comment cr√©er vos propres contr√¥les personnalis√©s.

## 7.3.1. Button, Label, TextBox, CheckBox, etc.

Windows Forms fournit une large gamme de contr√¥les pr√™ts √† l'emploi pour construire vos interfaces utilisateur. Voici les contr√¥les de base les plus couramment utilis√©s.

### Button

Le contr√¥le Button est l'un des √©l√©ments les plus fondamentaux d'une interface utilisateur. Il permet √† l'utilisateur de d√©clencher une action.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeButton()
{
    Button button = new Button
    {
        Text = "Cliquez-moi",
        Location = new Point(50, 50),
        Size = new Size(100, 30),
        BackColor = Color.LightBlue,
        ForeColor = Color.Black,
        Font = new Font("Arial", 9F, FontStyle.Bold),
        Name = "button1",
        TabIndex = 0,
        UseVisualStyleBackColor = true
    };

    // Attacher un gestionnaire d'√©v√©nements
    button.Click += Button_Click;

    // Ajouter le bouton au formulaire
    this.Controls.Add(button);
}

private void Button_Click(object sender, EventArgs e)
{
    MessageBox.Show("Le bouton a √©t√© cliqu√© !");
}
```


**Propri√©t√©s importantes du Button :**
- `Text` : Le texte affich√© sur le bouton
- `Image` : Une image √† afficher sur le bouton
- `ImageAlign` : L'alignement de l'image par rapport au texte
- `TextAlign` : L'alignement du texte dans le bouton
- `FlatStyle` : Le style visuel du bouton (Standard, Flat, Popup, System)
- `DialogResult` : La valeur retourn√©e si le bouton est utilis√© dans une bo√Æte de dialogue

**√âv√©nements cl√©s :**
- `Click` : D√©clench√© lorsque l'utilisateur clique sur le bouton
- `MouseEnter`/`MouseLeave` : D√©clench√©s lorsque le curseur entre ou quitte la zone du bouton

### Label

Le contr√¥le Label affiche du texte non modifiable par l'utilisateur. Il est utilis√© pour les titres, les descriptions et les instructions.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeLabel()
{
    Label label = new Label
    {
        Text = "Entrez votre nom :",
        Location = new Point(50, 20),
        Size = new Size(150, 20),
        AutoSize = true,
        Font = new Font("Segoe UI", 9F),
        ForeColor = Color.Navy,
        Name = "labelNom",
        TextAlign = ContentAlignment.MiddleLeft
    };

    this.Controls.Add(label);
}
```


**Propri√©t√©s importantes du Label :**
- `Text` : Le texte affich√©
- `AutoSize` : D√©termine si le contr√¥le redimensionne automatiquement sa taille pour s'adapter au contenu
- `TextAlign` : L'alignement du texte √† l'int√©rieur du Label
- `BorderStyle` : Le style de bordure
- `UseMnemonic` : D√©termine si les caract√®res pr√©c√©d√©s d'un & sont interpr√©t√©s comme des raccourcis clavier

### TextBox

Le contr√¥le TextBox permet √† l'utilisateur de saisir du texte.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeTextBox()
{
    TextBox textBox = new TextBox
    {
        Location = new Point(50, 50),
        Size = new Size(200, 23),
        Text = "",
        PlaceholderText = "Entrez votre nom ici", // Disponible uniquement dans .NET Core/.NET 5+
        MaxLength = 50,
        Name = "textBoxNom",
        TabIndex = 1,
        PasswordChar = '\0', // Caract√®re affich√© pour les mots de passe
        Multiline = false
    };

    // Attacher des gestionnaires d'√©v√©nements
    textBox.TextChanged += TextBox_TextChanged;

    this.Controls.Add(textBox);
}

private void TextBox_TextChanged(object sender, EventArgs e)
{
    TextBox textBox = (TextBox)sender;
    Console.WriteLine($"Texte modifi√© : {textBox.Text}");
}
```


**Propri√©t√©s importantes du TextBox :**
- `Text` : Le texte contenu dans le TextBox
- `PlaceholderText` (.NET 5+) : Texte indicatif affich√© lorsque le TextBox est vide
- `MaxLength` : Nombre maximum de caract√®res autoris√©s
- `Multiline` : D√©termine si le TextBox peut contenir plusieurs lignes
- `ReadOnly` : D√©termine si le texte peut √™tre modifi√© par l'utilisateur
- `PasswordChar` : Caract√®re affich√© √† la place du texte r√©el pour masquer une saisie sensible
- `WordWrap` : Active/d√©sactive le retour √† la ligne automatique dans un TextBox multiline
- `ScrollBars` : Configure les barres de d√©filement pour un TextBox multiline

**√âv√©nements cl√©s :**
- `TextChanged` : D√©clench√© lorsque le texte change
- `KeyPress` : D√©clench√© lorsqu'un caract√®re est saisi
- `KeyDown`/`KeyUp` : D√©clench√©s lorsqu'une touche est enfonc√©e/rel√¢ch√©e

### CheckBox

Le contr√¥le CheckBox permet √† l'utilisateur de s√©lectionner une option (oui/non).

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeCheckBox()
{
    CheckBox checkBox = new CheckBox
    {
        Text = "Accepter les conditions d'utilisation",
        Location = new Point(50, 80),
        Size = new Size(250, 20),
        Checked = false,
        ThreeState = false,  // Si true, permet l'√©tat ind√©termin√©
        Name = "checkBoxAccept",
        TabIndex = 2
    };

    // Attacher un gestionnaire d'√©v√©nements
    checkBox.CheckedChanged += CheckBox_CheckedChanged;

    this.Controls.Add(checkBox);
}

private void CheckBox_CheckedChanged(object sender, EventArgs e)
{
    CheckBox checkBox = (CheckBox)sender;
    Console.WriteLine($"√âtat : {checkBox.Checked}");
}
```


**Propri√©t√©s importantes du CheckBox :**
- `Checked` : √âtat actuel (coch√© ou non)
- `CheckState` : √âtat actuel avec possibilit√© d'une valeur ind√©termin√©e
- `ThreeState` : D√©termine si le CheckBox peut avoir trois √©tats (coch√©, non coch√©, ind√©termin√©)
- `AutoCheck` : D√©termine si l'√©tat change automatiquement lors d'un clic

**√âv√©nements cl√©s :**
- `CheckedChanged` : D√©clench√© lorsque l'√©tat change
- `CheckStateChanged` : D√©clench√© lorsque la propri√©t√© CheckState change

### RadioButton

Le contr√¥le RadioButton permet √† l'utilisateur de s√©lectionner une option parmi plusieurs choix mutuellement exclusifs.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeRadioButtons()
{
    // Premier RadioButton
    RadioButton radioButton1 = new RadioButton
    {
        Text = "Option 1",
        Location = new Point(50, 110),
        Size = new Size(100, 20),
        Checked = true,
        Name = "radioOption1",
        TabIndex = 3
    };

    // Deuxi√®me RadioButton
    RadioButton radioButton2 = new RadioButton
    {
        Text = "Option 2",
        Location = new Point(50, 130),
        Size = new Size(100, 20),
        Checked = false,
        Name = "radioOption2",
        TabIndex = 4
    };

    // Attacher des gestionnaires d'√©v√©nements
    radioButton1.CheckedChanged += RadioButton_CheckedChanged;
    radioButton2.CheckedChanged += RadioButton_CheckedChanged;

    this.Controls.Add(radioButton1);
    this.Controls.Add(radioButton2);
}

private void RadioButton_CheckedChanged(object sender, EventArgs e)
{
    RadioButton radioButton = (RadioButton)sender;
    if (radioButton.Checked) // N'ex√©cuter que si le bouton est s√©lectionn√©
    {
        Console.WriteLine($"Option s√©lectionn√©e : {radioButton.Text}");
    }
}
```


**Propri√©t√©s importantes du RadioButton :**
- `Checked` : Indique si le bouton radio est s√©lectionn√©
- `Appearance` : Modifie l'apparence (Normal ou Button)
- `AutoCheck` : D√©termine si l'√©tat change automatiquement lors d'un clic

**√âv√©nements cl√©s :**
- `CheckedChanged` : D√©clench√© lorsque l'√©tat de s√©lection change

### ComboBox

Le contr√¥le ComboBox combine une zone de texte avec une liste d√©roulante, permettant √† l'utilisateur de s√©lectionner un √©l√©ment ou de saisir une valeur.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeComboBox()
{
    ComboBox comboBox = new ComboBox
    {
        Location = new Point(50, 160),
        Size = new Size(200, 23),
        DropDownStyle = ComboBoxStyle.DropDownList, // DropDown, Simple, DropDownList
        Name = "comboBoxPays",
        TabIndex = 5
    };

    // Ajouter des √©l√©ments
    comboBox.Items.Add("France");
    comboBox.Items.Add("Belgique");
    comboBox.Items.Add("Suisse");
    comboBox.Items.Add("Canada");

    // S√©lectionner un √©l√©ment par d√©faut
    comboBox.SelectedIndex = 0;

    // Attacher un gestionnaire d'√©v√©nements
    comboBox.SelectedIndexChanged += ComboBox_SelectedIndexChanged;

    this.Controls.Add(comboBox);
}

private void ComboBox_SelectedIndexChanged(object sender, EventArgs e)
{
    ComboBox comboBox = (ComboBox)sender;
    Console.WriteLine($"S√©lection : {comboBox.SelectedItem}");
}
```


**Propri√©t√©s importantes du ComboBox :**
- `Items` : Collection des √©l√©ments de la liste
- `SelectedIndex` : Index de l'√©l√©ment s√©lectionn√©
- `SelectedItem` : √âl√©ment actuellement s√©lectionn√©
- `DropDownStyle` : Style d'affichage (DropDown, Simple, DropDownList)
- `MaxDropDownItems` : Nombre maximum d'√©l√©ments visibles lorsque la liste est d√©roul√©e
- `AutoCompleteMode` : Mode de compl√©tion automatique
- `Sorted` : D√©termine si les √©l√©ments sont tri√©s par ordre alphab√©tique

**√âv√©nements cl√©s :**
- `SelectedIndexChanged` : D√©clench√© lorsque la s√©lection change
- `TextChanged` : D√©clench√© lorsque le texte change (pour DropDown et Simple)
- `DropDown`/`DropDownClosed` : D√©clench√©s lorsque la liste d√©roulante s'ouvre/se ferme

### ListBox

Le contr√¥le ListBox affiche une liste d'√©l√©ments parmi lesquels l'utilisateur peut effectuer une ou plusieurs s√©lections.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeListBox()
{
    ListBox listBox = new ListBox
    {
        Location = new Point(50, 200),
        Size = new Size(200, 100),
        SelectionMode = SelectionMode.MultiSimple, // One, MultiSimple, MultiExtended
        Name = "listBoxLanguages",
        TabIndex = 6,
        Sorted = true
    };

    // Ajouter des √©l√©ments
    listBox.Items.Add("C#");
    listBox.Items.Add("JavaScript");
    listBox.Items.Add("Python");
    listBox.Items.Add("Java");
    listBox.Items.Add("TypeScript");

    // Attacher un gestionnaire d'√©v√©nements
    listBox.SelectedIndexChanged += ListBox_SelectedIndexChanged;

    this.Controls.Add(listBox);
}

private void ListBox_SelectedIndexChanged(object sender, EventArgs e)
{
    ListBox listBox = (ListBox)sender;

    // Afficher tous les √©l√©ments s√©lectionn√©s
    string selections = string.Join(", ", listBox.SelectedItems.Cast<string>());
    Console.WriteLine($"S√©lections : {selections}");
}
```


**Propri√©t√©s importantes du ListBox :**
- `Items` : Collection des √©l√©ments de la liste
- `SelectedIndex` : Index de l'√©l√©ment s√©lectionn√© (simple s√©lection)
- `SelectedIndices` : Collection des indices des √©l√©ments s√©lectionn√©s (multi-s√©lection)
- `SelectedItem` : √âl√©ment actuellement s√©lectionn√© (simple s√©lection)
- `SelectedItems` : Collection des √©l√©ments s√©lectionn√©s (multi-s√©lection)
- `SelectionMode` : Mode de s√©lection (One, MultiSimple, MultiExtended)
- `MultiColumn` : D√©termine si la liste s'affiche sur plusieurs colonnes
- `Sorted` : D√©termine si les √©l√©ments sont tri√©s par ordre alphab√©tique

**√âv√©nements cl√©s :**
- `SelectedIndexChanged` : D√©clench√© lorsque la s√©lection change
- `DoubleClick` : D√©clench√© lorsqu'un √©l√©ment est double-cliqu√©

### PictureBox

Le contr√¥le PictureBox affiche des images.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializePictureBox()
{
    PictureBox pictureBox = new PictureBox
    {
        Location = new Point(300, 50),
        Size = new Size(150, 150),
        SizeMode = PictureBoxSizeMode.Zoom, // Normal, StretchImage, AutoSize, CenterImage, Zoom
        Image = Image.FromFile("chemin/vers/image.jpg"), // Ou Resource.Image pour les ressources int√©gr√©es
        BorderStyle = BorderStyle.FixedSingle,
        Name = "pictureBoxLogo",
        TabIndex = 7
    };

    // Attacher un gestionnaire d'√©v√©nements
    pictureBox.Click += PictureBox_Click;

    this.Controls.Add(pictureBox);
}

private void PictureBox_Click(object sender, EventArgs e)
{
    // Ouvrir un s√©lecteur de fichier pour changer l'image
    using (OpenFileDialog openFileDialog = new OpenFileDialog())
    {
        openFileDialog.Filter = "Images|*.jpg;*.jpeg;*.png;*.gif;*.bmp|Tous les fichiers|*.*";

        if (openFileDialog.ShowDialog() == DialogResult.OK)
        {
            try
            {
                PictureBox pictureBox = (PictureBox)sender;
                pictureBox.Image = Image.FromFile(openFileDialog.FileName);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Erreur lors du chargement de l'image : {ex.Message}");
            }
        }
    }
}
```


**Propri√©t√©s importantes du PictureBox :**
- `Image` : L'image affich√©e
- `SizeMode` : Comment l'image est redimensionn√©e/positionn√©e
- `ImageLocation` : URL ou chemin de fichier de l'image
- `ErrorImage` : Image affich√©e en cas d'erreur de chargement
- `InitialImage` : Image affich√©e pendant le chargement de l'image principale

**√âv√©nements cl√©s :**
- `Click` : D√©clench√© lorsque l'utilisateur clique sur l'image
- `LoadCompleted` : D√©clench√© lorsque le chargement de l'image est termin√©

### NumericUpDown

Le contr√¥le NumericUpDown permet √† l'utilisateur de s√©lectionner une valeur num√©rique en utilisant des boutons haut/bas ou par saisie directe.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeNumericUpDown()
{
    NumericUpDown numericUpDown = new NumericUpDown
    {
        Location = new Point(300, 220),
        Size = new Size(80, 23),
        Minimum = 0,
        Maximum = 100,
        Value = 10,
        Increment = 5,
        DecimalPlaces = 0,
        ThousandsSeparator = true,
        Name = "numericQuantit√©",
        TabIndex = 8
    };

    // Attacher un gestionnaire d'√©v√©nements
    numericUpDown.ValueChanged += NumericUpDown_ValueChanged;

    this.Controls.Add(numericUpDown);
}

private void NumericUpDown_ValueChanged(object sender, EventArgs e)
{
    NumericUpDown numericUpDown = (NumericUpDown)sender;
    Console.WriteLine($"Valeur : {numericUpDown.Value}");
}
```


**Propri√©t√©s importantes du NumericUpDown :**
- `Value` : Valeur actuelle
- `Minimum`/`Maximum` : Valeurs minimale et maximale autoris√©es
- `Increment` : Pas d'incr√©mentation/d√©cr√©mentation
- `DecimalPlaces` : Nombre de d√©cimales affich√©es
- `ThousandsSeparator` : Active/d√©sactive l'affichage du s√©parateur de milliers
- `UpDownAlign` : Alignement des boutons haut/bas

**√âv√©nements cl√©s :**
- `ValueChanged` : D√©clench√© lorsque la valeur change

### DateTimePicker

Le contr√¥le DateTimePicker permet √† l'utilisateur de s√©lectionner une date et √©ventuellement une heure.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeDateTimePicker()
{
    DateTimePicker dateTimePicker = new DateTimePicker
    {
        Location = new Point(300, 260),
        Size = new Size(150, 23),
        Format = DateTimePickerFormat.Short, // Short, Long, Time, Custom
        CustomFormat = "dd/MM/yyyy HH:mm", // Utilis√© si Format = Custom
        MinDate = new DateTime(2000, 1, 1),
        MaxDate = new DateTime(2030, 12, 31),
        Value = DateTime.Today,
        ShowUpDown = false,
        Name = "dateTimePickerDate",
        TabIndex = 9
    };

    // Attacher un gestionnaire d'√©v√©nements
    dateTimePicker.ValueChanged += DateTimePicker_ValueChanged;

    this.Controls.Add(dateTimePicker);
}

private void DateTimePicker_ValueChanged(object sender, EventArgs e)
{
    DateTimePicker dateTimePicker = (DateTimePicker)sender;
    Console.WriteLine($"Date s√©lectionn√©e : {dateTimePicker.Value}");
}
```


**Propri√©t√©s importantes du DateTimePicker :**
- `Value` : Date et heure s√©lectionn√©es
- `MinDate`/`MaxDate` : Dates minimale et maximale autoris√©es
- `Format` : Format d'affichage (Short, Long, Time, Custom)
- `CustomFormat` : Format personnalis√©
- `ShowUpDown` : Affiche des boutons haut/bas au lieu d'un calendrier d√©roulant
- `ShowCheckBox` : Affiche une case √† cocher pour permettre une valeur nulle

**√âv√©nements cl√©s :**
- `ValueChanged` : D√©clench√© lorsque la date/heure s√©lectionn√©e change

### ProgressBar

Le contr√¥le ProgressBar affiche visuellement la progression d'une op√©ration.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeProgressBar()
{
    ProgressBar progressBar = new ProgressBar
    {
        Location = new Point(50, 320),
        Size = new Size(400, 23),
        Minimum = 0,
        Maximum = 100,
        Value = 0,
        Style = ProgressBarStyle.Blocks, // Blocks ou Marquee (.NET 5+)
        Step = 10,
        Name = "progressBarChargement",
        TabIndex = 10
    };

    // Exemple d'utilisation avec un Timer
    Timer timer = new Timer
    {
        Interval = 500,
        Enabled = true
    };

    timer.Tick += (sender, e) => {
        if (progressBar.Value < progressBar.Maximum)
        {
            // Incr√©menter de la valeur du Step
            progressBar.PerformStep();
        }
        else
        {
            // Arr√™ter le timer lorsque la progression est termin√©e
            timer.Stop();
            MessageBox.Show("Op√©ration termin√©e !");
        }
    };

    this.Controls.Add(progressBar);
    this.components.Add(timer); // Ajouter au conteneur de composants
}
```


**Propri√©t√©s importantes du ProgressBar :**
- `Value` : Valeur actuelle
- `Minimum`/`Maximum` : Valeurs minimale et maximale
- `Style` : Style d'affichage (Blocks, Continuous, Marquee)
- `Step` : Incr√©ment utilis√© par la m√©thode PerformStep()
- `MarqueeAnimationSpeed` : Vitesse d'animation en mode Marquee

### TrackBar (Slider)

Le contr√¥le TrackBar permet √† l'utilisateur de s√©lectionner une valeur dans une plage en d√©pla√ßant un curseur.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeTrackBar()
{
    TrackBar trackBar = new TrackBar
    {
        Location = new Point(50, 360),
        Size = new Size(300, 45),
        Minimum = 0,
        Maximum = 100,
        Value = 50,
        SmallChange = 1,
        LargeChange = 10,
        TickFrequency = 10,
        TickStyle = TickStyle.Both,
        Orientation = Orientation.Horizontal,
        Name = "trackBarVolume",
        TabIndex = 11
    };

    // Attacher un gestionnaire d'√©v√©nements
    trackBar.ValueChanged += TrackBar_ValueChanged;

    this.Controls.Add(trackBar);
}

private void TrackBar_ValueChanged(object sender, EventArgs e)
{
    TrackBar trackBar = (TrackBar)sender;
    Console.WriteLine($"Valeur : {trackBar.Value}");
}
```


**Propri√©t√©s importantes du TrackBar :**
- `Value` : Valeur actuelle
- `Minimum`/`Maximum` : Valeurs minimale et maximale
- `SmallChange` : Incr√©ment pour les touches fl√©ch√©es
- `LargeChange` : Incr√©ment pour la touche Page Up/Down
- `TickFrequency` : Fr√©quence des marques sur la piste
- `TickStyle` : Style des marques (None, TopLeft, BottomRight, Both)
- `Orientation` : Orientation (Horizontal, Vertical)

**√âv√©nements cl√©s :**
- `ValueChanged` : D√©clench√© lorsque la valeur change
- `Scroll` : D√©clench√© pendant le d√©placement du curseur

## 7.3.2. Propri√©t√©s communes

La plupart des contr√¥les Windows Forms partagent un ensemble de propri√©t√©s communes qui affectent leur apparence et leur comportement.

### Propri√©t√©s li√©es √† l'apparence

```textmate
// .NET Framework 4.7.2 et .NET 8
private void ConfigurerApparence(Control control)
{
    // Apparence g√©n√©rale
    control.BackColor = Color.White;
    control.ForeColor = Color.Black;
    control.Font = new Font("Segoe UI", 9F);
    control.Cursor = Cursors.Hand;

    // Bordure (pour les contr√¥les qui la supportent)
    if (control is TextBox || control is Label)
    {
        // Utilisation de reflection pour d√©finir la propri√©t√© BorderStyle
        var borderStyleProperty = control.GetType().GetProperty("BorderStyle");
        if (borderStyleProperty != null)
        {
            borderStyleProperty.SetValue(control, BorderStyle.FixedSingle);
        }
    }

    // Opacit√© et transparence
    control.Opacity = 0.9; // .NET 5+ uniquement
    control.BackColor = Color.FromArgb(150, 255, 255, 255); // Couleur semi-transparente

    // Style de la police
    control.Font = new Font("Arial", 10F, FontStyle.Bold | FontStyle.Italic);

    // Alignement (pour les contr√¥les qui supportent le texte)
    if (control is Button button)
    {
        button.TextAlign = ContentAlignment.MiddleCenter;
    }
    else if (control is Label label)
    {
        label.TextAlign = ContentAlignment.MiddleLeft;
    }
}
```


**Propri√©t√©s d'apparence communes :**
- `BackColor` : Couleur d'arri√®re-plan
- `ForeColor` : Couleur du texte
- `Font` : Police utilis√©e pour le texte
- `Cursor` : Pointeur de souris affich√© au survol
- `Opacity` (.NET 5+) : Niveau d'opacit√© du contr√¥le
- `BorderStyle` : Style de bordure (applicable √† certains contr√¥les)
- `BackgroundImage` : Image d'arri√®re-plan
- `BackgroundImageLayout` : Comment l'image d'arri√®re-plan est affich√©e
- `RightToLeft` : Direction du texte (pour les langues √©crites de droite √† gauche)
- `Padding` : Espace int√©rieur entre le contenu et les bords du contr√¥le
- `Margin` : Espace ext√©rieur entre le contr√¥le et les autres contr√¥les

### Propri√©t√©s li√©es √† la disposition

```textmate
// .NET Framework 4.7.2 et .NET 8
private void ConfigurerDisposition(Control control)
{
    // Position et taille
    control.Location = new Point(100, 100);
    control.Size = new Size(150, 30);
    control.Anchor = AnchorStyles.Top | AnchorStyles.Left;
    control.Dock = DockStyle.None;

    // Positionnement
    control.AutoSize = true;
    control.AutoSizeMode = AutoSizeMode.GrowAndShrink;
    control.MinimumSize = new Size(50, 20);
    control.MaximumSize = new Size(300, 100);

    // Z-order
    control.BringToFront(); // Am√®ne le contr√¥le au premier plan
    // ou
    control.SendToBack(); // Envoie le contr√¥le √† l'arri√®re-plan
}
```


**Propri√©t√©s de disposition communes :**
- `Location` : Position du contr√¥le dans son conteneur parent
- `Size` : Taille du contr√¥le (largeur et hauteur)
- `Anchor` : Comment le contr√¥le est ancr√© aux bords de son conteneur parent
- `Dock` : Comment le contr√¥le est amarr√© dans son conteneur parent
- `AutoSize` : Si le contr√¥le s'adapte automatiquement √† son contenu
- `AutoSizeMode` : Comment le contr√¥le s'adapte √† son contenu
- `MinimumSize`/`MaximumSize` : Tailles minimale et maximale du contr√¥le
- `Margin` : Espacement autour du contr√¥le
- `Padding` : Espacement int√©rieur du contr√¥le

### Propri√©t√©s li√©es au comportement

```textmate
// .NET Framework 4.7.2 et .NET 8
private void ConfigurerComportement(Control control)
{
    // Interaction utilisateur
    control.Enabled = true;
    control.Visible = true;
    control.TabIndex = 0;
    control.TabStop = true;
    control.AllowDrop = true;

    // Focus
    control.Focus(); // Donner le focus √† ce contr√¥le

    // Accessibilit√©
    control.AccessibleName = "Mon contr√¥le";
    control.AccessibleDescription = "Description du contr√¥le pour l'accessibilit√©";
    control.AccessibleRole = AccessibleRole.PushButton;

    // Infobulles
    ToolTip toolTip = new ToolTip();
    toolTip.SetToolTip(control, "Ceci est une infobulle");

    // Raccourcis clavier
    if (control is Button button)
    {
        button.Text = "&Valider"; // Le 'V' devient un raccourci avec Alt+V
    }
}
```


**Propri√©t√©s de comportement communes :**
- `Enabled` : D√©termine si le contr√¥le peut r√©pondre aux interactions
- `Visible` : D√©termine si le contr√¥le est visible
- `TabIndex` : Ordre du contr√¥le dans la s√©quence de tabulation
- `TabStop` : D√©termine si le contr√¥le peut recevoir le focus via la touche Tab
- `AllowDrop` : D√©termine si le contr√¥le peut √™tre une cible de glisser-d√©poser
- `CausesValidation` : D√©termine si le contr√¥le d√©clenche la validation lors de la perte du focus
- `ContextMenuStrip` : Menu contextuel associ√© au contr√¥le
- `Focused` : Indique si le contr√¥le a le focus

### Propri√©t√©s sp√©cifiques aux formulaires

Les formulaires (Form) ont des propri√©t√©s suppl√©mentaires pour contr√¥ler leur apparence et leur comportement.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void ConfigurerFormulaire(Form form)
{
    // Apparence g√©n√©rale
    form.Text = "Mon Application";
    form.Icon = new Icon("chemin/vers/icone.ico");
    form.BackColor = Color.White;
    form.ForeColor = Color.Black;
    form.Font = new Font("Segoe UI", 9F);
    form.FormBorderStyle = FormBorderStyle.Sizable;
    form.TransparencyKey = Color.Magenta; // Couleur trait√©e comme transparente

    // Taille et position
    form.Size = new Size(800, 600);
    form.MinimumSize = new Size(400, 300);
    form.MaximumSize = new Size(1200, 900);
    form.StartPosition = FormStartPosition.CenterScreen;
    form.WindowState = FormWindowState.Normal;

    // Comportement
    form.ShowInTaskbar = true;
    form.TopMost = false;
    form.ShowIcon = true;
    form.MinimizeBox = true;
    form.MaximizeBox = true;
    form.ControlBox = true;
    form.AcceptButton = buttonOK; // Bouton activ√© par la touche Entr√©e
    form.CancelButton = buttonAnnuler; // Bouton activ√© par la touche √âchap

    // Pour les bo√Ætes de dialogue modales
    form.FormBorderStyle = FormBorderStyle.FixedDialog;
    form.MaximizeBox = false;
    form.MinimizeBox = false;
    form.StartPosition = FormStartPosition.CenterParent;

    // √âv√©nements sp√©cifiques aux formulaires
    form.Load += Form_Load;
    form.FormClosing += Form_FormClosing;
    form.FormClosed += Form_FormClosed;
    form.Shown += Form_Shown;
}

private void Form_Load(object sender, EventArgs e)
{
    // Ex√©cut√© avant que le formulaire ne soit affich√© pour la premi√®re fois
    Console.WriteLine("Formulaire en cours de chargement");
}

private void Form_Shown(object sender, EventArgs e)
{
    // Ex√©cut√© apr√®s que le formulaire soit devenu visible
    Console.WriteLine("Formulaire affich√©");
}

private void Form_FormClosing(object sender, FormClosingEventArgs e)
{
    // Ex√©cut√© avant la fermeture du formulaire
    // Permet d'annuler la fermeture
    DialogResult result = MessageBox.Show(
        "Voulez-vous vraiment quitter ?",
        "Confirmation",
        MessageBoxButtons.YesNo,
        MessageBoxIcon.Question);

    if (result == DialogResult.No)
    {
        e.Cancel = true; // Annule la fermeture
    }
}

private void Form_FormClosed(object sender, FormClosedEventArgs e)
{
    // Ex√©cut√© apr√®s la fermeture du formulaire
    Console.WriteLine($"Formulaire ferm√©, raison : {e.CloseReason}");
}
```


**Propri√©t√©s sp√©cifiques aux formulaires :**
- `Text` : Texte affich√© dans la barre de titre
- `Icon` : Ic√¥ne affich√©e dans la barre de titre et la barre des t√¢ches
- `FormBorderStyle` : Style de bordure (None, FixedSingle, Fixed3D, FixedDialog, Sizable, FixedToolWindow, SizableToolWindow)
- `StartPosition` : Position initiale (Manual, CenterScreen, WindowsDefaultLocation, WindowsDefaultBounds, CenterParent)
- `WindowState` : √âtat initial (Normal, Minimized, Maximized)
- `ShowInTaskbar` : Indique si le formulaire appara√Æt dans la barre des t√¢ches
- `TopMost` : Indique si le formulaire reste au-dessus des autres fen√™tres
- `Opacity` : Niveau de transparence (0.0 √† 1.0)
- `ShowIcon` : Indique si l'ic√¥ne est affich√©e dans la barre de titre
- `MinimizeBox`/`MaximizeBox` : Indique si les boutons R√©duire/Agrandir sont affich√©s
- `ControlBox` : Indique si la bo√Æte de contr√¥le (avec les boutons de fermeture, etc.) est affich√©e
- `AcceptButton` : Bouton activ√© par la touche Entr√©e
- `CancelButton` : Bouton activ√© par la touche √âchap
- `DialogResult` : Valeur retourn√©e lorsque le formulaire est utilis√© comme bo√Æte de dialogue

## 7.3.3. Cr√©ation de contr√¥les personnalis√©s

La cr√©ation de contr√¥les personnalis√©s vous permet d'√©tendre les fonctionnalit√©s des contr√¥les existants ou de cr√©er des contr√¥les enti√®rement nouveaux.

### Extension d'un contr√¥le existant

L'approche la plus simple pour cr√©er un contr√¥le personnalis√© est d'√©tendre un contr√¥le existant.

```textmate
// .NET Framework 4.7.2 et .NET 8
public class TextBoxAvecValidation : TextBox
{
    // Couleurs pour les √©tats valide/invalide
    private Color _couleurValide = Color.White;
    private Color _couleurInvalide = Color.MistyRose;

    // Propri√©t√© pour le texte de validation
    private string _texteValidation = string.Empty;
    public string TexteValidation
    {
        get => _texteValidation;
        set
        {
            _texteValidation = value;
            Valider(); // Valider √† chaque changement du texte de validation
        }
    }

    // √âv√©nement personnalis√©
    public event EventHandler<bool> ValidationChanged;

    // Propri√©t√© en lecture seule pour l'√©tat de validation
    private bool _estValide = true;
    public bool EstValide => _estValide;

    // Couleurs personnalisables
    public Color CouleurValide
    {
        get => _couleurValide;
        set
        {
            _couleurValide = value;
            if (_estValide) BackColor = value;
        }
    }

    public Color CouleurInvalide
    {
        get => _couleurInvalide;
        set
        {
            _couleurInvalide = value;
            if (!_estValide) BackColor = value;
        }
    }

    // Expression r√©guli√®re de validation
    private string _pattern = string.Empty;
    public string PatternValidation
    {
        get => _pattern;
        set
        {
            _pattern = value;
            Valider(); // Valider √† chaque changement du pattern
        }
    }

    public TextBoxAvecValidation()
    {
        // Style par d√©faut
        BorderStyle = BorderStyle.FixedSingle;

        // Attacher l'√©v√©nement TextChanged
        this.TextChanged += (s, e) => Valider();
    }

    // M√©thode de validation
    private void Valider()
    {
        bool ancienEtat = _estValide;

        if (string.IsNullOrEmpty(Text))
        {
            // Consid√©rer vide comme invalide si un texte de validation est d√©fini
            _estValide = string.IsNullOrEmpty(_texteValidation);
        }
        else if (!string.IsNullOrEmpty(_pattern))
        {
            // Valider avec une expression r√©guli√®re
            _estValide = System.Text.RegularExpressions.Regex.IsMatch(Text, _pattern);
        }
        else
        {
            // Par d√©faut, consid√©rer comme valide
            _estValide = true;
        }

        // Mettre √† jour l'apparence
        BackColor = _estValide ? _couleurValide : _couleurInvalide;

        // D√©clencher l'√©v√©nement si l'√©tat a chang√©
        if (ancienEtat != _estValide)
        {
            ValidationChanged?.Invoke(this, _estValide);
        }
    }

    // Surcharger la m√©thode de cr√©ation du contr√¥le pour initialiser l'√©tat
    protected override void OnCreateControl()
    {
        base.OnCreateControl();
        Valider();
    }
}
```


Utilisation du contr√¥le personnalis√© :

```textmate
public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();

        // Cr√©er et configurer le TextBox personnalis√©
        TextBoxAvecValidation textBoxEmail = new TextBoxAvecValidation
        {
            Location = new Point(120, 50),
            Size = new Size(200, 23),
            PatternValidation = @"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$",
            TexteValidation = "Veuillez entrer une adresse email valide",
            CouleurValide = Color.LightGreen,
            CouleurInvalide = Color.LightPink
        };

        // Ajouter un Label pour indiquer le champ
        Label labelEmail = new Label
        {
            Text = "Email :",
            Location = new Point(50, 53),
            AutoSize = true
        };

        // Ajouter un Label pour afficher le message de validation
        Label labelValidation = new Label
        {
            Location = new Point(120, 76),
            Size = new Size(200, 20),
            ForeColor = Color.Red,
            Text = textBoxEmail.TexteValidation,
            Visible = !textBoxEmail.EstValide
        };

        // G√©rer l'√©v√©nement de validation
        textBoxEmail.ValidationChanged += (sender, estValide) =>
        {
            labelValidation.Visible = !estValide;
        };

        // Ajouter les contr√¥les au formulaire
        this.Controls.Add(labelEmail);
        this.Controls.Add(textBoxEmail);
        this.Controls.Add(labelValidation);
    }
}
```


### Cr√©ation d'un contr√¥le √† partir de z√©ro

Pour cr√©er un contr√¥le enti√®rement personnalis√©, vous pouvez h√©riter directement de la classe `Control`.

```textmate
// .NET Framework 4.7.2 et .NET 8
public class BoutonGradient : Control
{
    // Propri√©t√©s pour les couleurs du d√©grad√©
    private Color _couleurDebut = Color.RoyalBlue;
    public Color CouleurDebut
    {
        get => _couleurDebut;
        set
        {
            _couleurDebut = value;
            Invalidate(); // Forcer le redessin
        }
    }

    private Color _couleurFin = Color.SkyBlue;
    public Color CouleurFin
    {
        get => _couleurFin;
        set
        {
            _couleurFin = value;
            Invalidate();
        }
    }

    // Arrondi des coins
    private int _rayonArrondi = 10;
    public int RayonArrondi
    {
        get => _rayonArrondi;
        set
        {
            _rayonArrondi = value;
            Invalidate();
        }
    }

    // Direction du d√©grad√©
    public enum DirectionDegrade
    {
        Horizontal,
        Vertical,
        DiagonalHautGauche,
        DiagonalHautDroite
    }

    private DirectionDegrade _direction = DirectionDegrade.Horizontal;
    public DirectionDegrade Direction
    {
        get => _direction;
        set
        {
            _direction = value;
            Invalidate();
        }
    }

    // √âtats du bouton
    private bool _survol = false;
    private bool _enfonce = false;

    public BoutonGradient()
    {
        // D√©finir la taille par d√©faut
        Size = new Size(120, 40);

        // Activer le double buffer pour √©viter le scintillement
        SetStyle(ControlStyles.UserPaint, true);
        SetStyle(ControlStyles.AllPaintingInWmPaint, true);
        SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
        SetStyle(ControlStyles.ResizeRedraw, true);
        SetStyle(ControlStyles.SupportsTransparentBackColor, true);

        // D√©finir la couleur de fond comme transparente
        BackColor = Color.Transparent;

        // D√©finir la police par d√©faut
        Font = new Font("Segoe UI", 9F, FontStyle.Bold);
    }

    // G√©rer le dessin du contr√¥le
    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);

        Graphics g = e.Graphics;
        g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;

        // Cr√©er un rectangle arrondi
        System.Drawing.Drawing2D.GraphicsPath path = new System.Drawing.Drawing2D.GraphicsPath();
        Rectangle rect = new Rectangle(0, 0, Width - 1, Height - 1);

        // Dessiner le rectangle arrondi
        if (_rayonArrondi > 0)
        {
            int diameter = _rayonArrondi * 2;
            Rectangle arc = new Rectangle(rect.Location, new Size(diameter, diameter));

            // Coin sup√©rieur gauche
            path.AddArc(arc, 180, 90);

            // Coin sup√©rieur droit
            arc.X = rect.Right - diameter;
            path.AddArc(arc, 270, 90);

            // Coin inf√©rieur droit
            arc.Y = rect.Bottom - diameter;
            path.AddArc(arc, 0, 90);

            // Coin inf√©rieur gauche
            arc.X = rect.Left;
            path.AddArc(arc, 90, 90);

            path.CloseFigure();
        }
        else
        {
            path.AddRectangle(rect);
        }

        // Cr√©er le d√©grad√©
        System.Drawing.Drawing2D.LinearGradientBrush brush;

        // Ajuster les couleurs selon l'√©tat
        Color couleurDebut = _couleurDebut;
        Color couleurFin = _couleurFin;

        if (_enfonce)
        {
            // Inverser les couleurs si le bouton est enfonc√©
            couleurDebut = _couleurFin;
            couleurFin = _couleurDebut;
        }
        else if (_survol)
        {
            // √âclaircir les couleurs au survol
            couleurDebut = EclaircirCouleur(_couleurDebut, 30);
            couleurFin = EclaircirCouleur(_couleurFin, 30);
        }

        // Cr√©er le pinceau selon la direction
        switch (_direction)
        {
            case DirectionDegrade.Horizontal:
                brush = new System.Drawing.Drawing2D.LinearGradientBrush(
                    rect, couleurDebut, couleurFin, System.Drawing.Drawing2D.LinearGradientMode.Horizontal);
                break;

            case DirectionDegrade.Vertical:
                brush = new System.Drawing.Drawing2D.LinearGradientBrush(
                    rect, couleurDebut, couleurFin, System.Drawing.Drawing2D.LinearGradientMode.Vertical);
                break;

            case DirectionDegrade.DiagonalHautGauche:
                brush = new System.Drawing.Drawing2D.LinearGradientBrush(
                    rect, couleurDebut, couleurFin, System.Drawing.Drawing2D.LinearGradientMode.ForwardDiagonal);
                break;

            case DirectionDegrade.DiagonalHautDroite:
                brush = new System.Drawing.Drawing2D.LinearGradientBrush(
                    rect, couleurDebut, couleurFin, System.Drawing.Drawing2D.LinearGradientMode.BackwardDiagonal);
                break;

            default:
                brush = new System.Drawing.Drawing2D.LinearGradientBrush(
                    rect, couleurDebut, couleurFin, System.Drawing.Drawing2D.LinearGradientMode.Horizontal);
                break;
        }

        // Remplir le fond
        g.FillPath(brush, path);

        // Dessiner la bordure
        using (Pen pen = new Pen(Color.FromArgb(100, Color.Gray), 1))
        {
            g.DrawPath(pen, path);
        }

        // Dessiner le texte
        StringFormat sf = new StringFormat
        {
            Alignment = StringAlignment.Center,
            LineAlignment = StringAlignment.Center
        };

        // Calculer l'ombre du texte
        if (!_enfonce)
        {
            using (SolidBrush shadowBrush = new SolidBrush(Color.FromArgb(70, Color.Black)))
            {
                Rectangle shadowRect = new Rectangle(2, 2, Width, Height);
                g.DrawString(Text, Font, shadowBrush, shadowRect, sf);
            }
        }

        // Dessiner le texte principal
        using (SolidBrush textBrush = new SolidBrush(ForeColor))
        {
            Rectangle textRect = rect;

            // D√©caler l√©g√®rement le texte si le bouton est enfonc√©
            if (_enfonce)
            {
                textRect.Offset(1, 1);
            }

            g.DrawString(Text, Font, textBrush, textRect, sf);
        }

        // Lib√©rer les ressources
        brush.Dispose();
        path.Dispose();
    }

    // √âclaircir une couleur d'un pourcentage donn√©
    private Color EclaircirCouleur(Color couleur, int pourcentage)
    {
        float facteur = pourcentage / 100f;
        int r = (int)((255 - couleur.R) * facteur) + couleur.R;
        int g = (int)((255 - couleur.G) * facteur) + couleur.G;
        int b = (int)((255 - couleur.B) * facteur) + couleur.B;

        return Color.FromArgb(couleur.A, r, g, b);
    }

    // G√©rer les √©v√©nements de la souris
    protected override void OnMouseEnter(EventArgs e)
    {
        _survol = true;
        Invalidate();
        base.OnMouseEnter(e);
    }

    protected override void OnMouseLeave(EventArgs e)
    {
        _survol = false;
        Invalidate();
        base.OnMouseLeave(e);
    }

    protected override void OnMouseDown(MouseEventArgs e)
    {
        if (e.Button == MouseButtons.Left)
        {
            _enfonce = true;
            Invalidate();
        }
        base.OnMouseDown(e);
    }

    protected override void OnMouseUp(MouseEventArgs e)
    {
        _enfonce = false;
        Invalidate();
        base.OnMouseUp(e);
    }
}
```


Utilisation du contr√¥le personnalis√© :

```textmate
public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();

        // Cr√©er et configurer le bouton personnalis√©
        BoutonGradient bouton = new BoutonGradient
        {
            Location = new Point(50, 50),
            Size = new Size(150, 50),
            Text = "Bouton D√©grad√©",
            CouleurDebut = Color.RoyalBlue,
            CouleurFin = Color.LightSkyBlue,
            Direction = BoutonGradient.DirectionDegrade.DiagonalHautGauche,
            RayonArrondi = 15,
            ForeColor = Color.White,
            Font = new Font("Segoe UI", 10F, FontStyle.Bold)
        };

        // Attacher un gestionnaire d'√©v√©nements
        bouton.Click += (sender, e) => MessageBox.Show("Bouton cliqu√© !");

        // Ajouter au formulaire
        this.Controls.Add(bouton);
    }
}
```


### Cr√©ation d'un UserControl

Les UserControls sont des contr√¥les composites qui regroupent plusieurs contr√¥les standard dans une seule unit√© r√©utilisable.

```textmate
// .NET Framework 4.7.2 et .NET 8
// Ajouter un nouveau fichier "ChampRecherche.cs" de type "User Control"
public partial class ChampRecherche : UserControl
{
    // √âv√©nement personnalis√© pour la recherche
    public event EventHandler<string> Rechercher;

    // Propri√©t√©s
    public string TexteRecherche
    {
        get => textBoxRecherche.Text;
        set => textBoxRecherche.Text = value;
    }

    public string Placeholder
    {
        get => textBoxRecherche.PlaceholderText;
        set => textBoxRecherche.PlaceholderText = value;
    }

    public bool AfficherAnnuler
    {
        get => buttonAnnuler.Visible;
        set => buttonAnnuler.Visible = value;
    }

    public ChampRecherche()
    {
        InitializeComponent();

        // Configuration des √©v√©nements
        buttonRechercher.Click += ButtonRechercher_Click;
        buttonAnnuler.Click += ButtonAnnuler_Click;
        textBoxRecherche.KeyPress += TextBoxRecherche_KeyPress;
    }

    // Les m√©thodes d'initialisation du concepteur seront g√©n√©r√©es automatiquement,
    // mais voici comment elles pourraient √™tre impl√©ment√©es manuellement :
    private void InitializeComponent()
    {
        // Cr√©er les contr√¥les
        this.textBoxRecherche = new TextBox();
        this.buttonRechercher = new Button();
        this.buttonAnnuler = new Button();

        // Configurer le TextBox
        this.textBoxRecherche.Anchor = AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top;
        this.textBoxRecherche.Location = new Point(0, 0);
        this.textBoxRecherche.Name = "textBoxRecherche";
        this.textBoxRecherche.Size = new Size(200, 23);
        this.textBoxRecherche.TabIndex = 0;

        // En .NET 5+ uniquement
        if (Environment.Version.Major >= 5)
        {
            this.textBoxRecherche.PlaceholderText = "Rechercher...";
        }

        // Configurer le bouton de recherche
        this.buttonRechercher.Anchor = AnchorStyles.Top | AnchorStyles.Right;
        this.buttonRechercher.Location = new Point(206, 0);
        this.buttonRechercher.Name = "buttonRechercher";
        this.buttonRechercher.Size = new Size(30, 23);
        this.buttonRechercher.TabIndex = 1;
        this.buttonRechercher.Text = "üîç";
        this.buttonRechercher.UseVisualStyleBackColor = true;

        // Configurer le bouton d'annulation
        this.buttonAnnuler.Anchor = AnchorStyles.Top | AnchorStyles.Right;
        this.buttonAnnuler.Location = new Point(242, 0);
        this.buttonAnnuler.Name = "buttonAnnuler";
        this.buttonAnnuler.Size = new Size(30, 23);
        this.buttonAnnuler.TabIndex = 2;
        this.buttonAnnuler.Text = "‚úñ";
        this.buttonAnnuler.UseVisualStyleBackColor = true;
        this.buttonAnnuler.Visible = false;

        // Configurer le UserControl
        this.Controls.Add(this.buttonAnnuler);
        this.Controls.Add(this.buttonRechercher);
        this.Controls.Add(this.textBoxRecherche);
        this.Name = "ChampRecherche";
        this.Size = new Size(272, 23);
    }

    private TextBox textBoxRecherche;
    private Button buttonRechercher;
    private Button buttonAnnuler;

    private void ButtonRechercher_Click(object sender, EventArgs e)
    {
        LancerRecherche();
    }

    private void ButtonAnnuler_Click(object sender, EventArgs e)
    {
        textBoxRecherche.Clear();
        buttonAnnuler.Visible = false;
        textBoxRecherche.Focus();
    }

    private void TextBoxRecherche_KeyPress(object sender, KeyPressEventArgs e)
    {
        if (e.KeyChar == (char)Keys.Enter)
        {
            e.Handled = true;
            LancerRecherche();
        }
    }

    private void LancerRecherche()
    {
        string texte = textBoxRecherche.Text.Trim();

        if (!string.IsNullOrEmpty(texte))
        {
            // Afficher le bouton d'annulation
            buttonAnnuler.Visible = true;

            // D√©clencher l'√©v√©nement de recherche
            Rechercher?.Invoke(this, texte);
        }
        else
        {
            buttonAnnuler.Visible = false;
        }
    }

    // M√©thode publique pour effacer le champ
    public void Effacer()
    {
        textBoxRecherche.Clear();
        buttonAnnuler.Visible = false;
    }
}
```


Utilisation du UserControl :

```textmate
public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();

        // Cr√©er et configurer le contr√¥le de recherche
        ChampRecherche champRecherche = new ChampRecherche
        {
            Location = new Point(20, 20),
            Size = new Size(300, 23),
            Placeholder = "Rechercher un produit...",
            Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right
        };

        // Attacher un gestionnaire d'√©v√©nements
        champRecherche.Rechercher += (sender, texte) =>
        {
            MessageBox.Show($"Recherche de : {texte}");
            // Effectuer la recherche et afficher les r√©sultats
        };

        // Ajouter au formulaire
        this.Controls.Add(champRecherche);
    }
}
```


### Gestion de l'accessibilit√© des contr√¥les personnalis√©s

Pour rendre vos contr√¥les personnalis√©s accessibles aux technologies d'assistance, il est important d'impl√©menter correctement les fonctionnalit√©s d'accessibilit√©.

```textmate
// .NET Framework 4.7.2 et .NET 8
public class BoutonAccessible : Button
{
    public BoutonAccessible()
    {
        // D√©finir les propri√©t√©s d'accessibilit√© par d√©faut
        AccessibleRole = AccessibleRole.PushButton;
        AccessibleName = "Bouton accessible";
        AccessibleDescription = "Un bouton avec des fonctionnalit√©s d'accessibilit√© am√©lior√©es";
    }

    // Surcharger pour fournir des informations d'accessibilit√©
    protected override AccessibleObject CreateAccessibilityInstance()
    {
        return new BoutonAccessibleObject(this);
    }

    // Classe interne pour la gestion de l'accessibilit√©
    protected class BoutonAccessibleObject : ButtonBaseAccessibleObject
    {
        private BoutonAccessible _owner;

        public BoutonAccessibleObject(BoutonAccessible owner)
            : base(owner)
        {
            _owner = owner;
        }

        // Surcharger pour fournir un nom d'accessibilit√© personnalis√©
        public override string Name
        {
            get
            {
                // Si l'utilisateur a d√©fini un nom d'accessibilit√©, l'utiliser
                if (!string.IsNullOrEmpty(Owner.AccessibleName))
                {
                    return Owner.AccessibleName;
                }

                // Sinon, utiliser le texte du bouton
                return _owner.Text;
            }
        }

        // Surcharger pour fournir une description d'accessibilit√© personnalis√©e
        public override string Description
        {
            get
            {
                // Si l'utilisateur a d√©fini une description d'accessibilit√©, l'utiliser
                if (!string.IsNullOrEmpty(Owner.AccessibleDescription))
                {
                    return Owner.AccessibleDescription;
                }

                // Sinon, utiliser le texte du bouton avec des informations suppl√©mentaires
                return $"Bouton : {_owner.Text}";
            }
        }

        // Surcharger pour fournir l'√©tat d'accessibilit√©
        public override AccessibleStates State
        {
            get
            {
                AccessibleStates state = base.State;

                if (!_owner.Enabled)
                {
                    state |= AccessibleStates.Unavailable;
                }

                if (_owner.Focused)
                {
                    state |= AccessibleStates.Focused;
                }

                return state;
            }
        }

        // Surcharger pour fournir les actions d'accessibilit√©
        public override void DoDefaultAction()
        {
            // Simuler un clic sur le bouton
            _owner.PerformClick();
        }
    }
}
```

## 7.3.4. Contr√¥les composites

Les contr√¥les composites sont des contr√¥les qui contiennent plusieurs contr√¥les enfants. Ils peuvent √™tre cr√©√©s soit en utilisant des UserControls, soit en regroupant des contr√¥les existants dans des conteneurs.

### Utilisation des Panels et GroupBoxes

Les Panels et GroupBoxes sont des contr√¥les conteneurs qui vous permettent d'organiser d'autres contr√¥les.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeCompositeControls()
{
    // Cr√©er un GroupBox
    GroupBox groupBoxContact = new GroupBox
    {
        Text = "Informations de contact",
        Location = new Point(20, 20),
        Size = new Size(400, 200),
        Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right
    };

    // Ajouter des Labels et TextBoxes au GroupBox
    Label labelNom = new Label
    {
        Text = "Nom :",
        Location = new Point(20, 30),
        AutoSize = true
    };

    TextBox textBoxNom = new TextBox
    {
        Location = new Point(120, 27),
        Size = new Size(250, 23),
        Anchor = AnchorStyles.Left | AnchorStyles.Right
    };

    Label labelPrenom = new Label
    {
        Text = "Pr√©nom :",
        Location = new Point(20, 60),
        AutoSize = true
    };

    TextBox textBoxPrenom = new TextBox
    {
        Location = new Point(120, 57),
        Size = new Size(250, 23),
        Anchor = AnchorStyles.Left | AnchorStyles.Right
    };

    Label labelEmail = new Label
    {
        Text = "Email :",
        Location = new Point(20, 90),
        AutoSize = true
    };

    TextBox textBoxEmail = new TextBox
    {
        Location = new Point(120, 87),
        Size = new Size(250, 23),
        Anchor = AnchorStyles.Left | AnchorStyles.Right
    };

    Label labelTelephone = new Label
    {
        Text = "T√©l√©phone :",
        Location = new Point(20, 120),
        AutoSize = true
    };

    TextBox textBoxTelephone = new TextBox
    {
        Location = new Point(120, 117),
        Size = new Size(250, 23),
        Anchor = AnchorStyles.Left | AnchorStyles.Right
    };

    Button buttonEnregistrer = new Button
    {
        Text = "Enregistrer",
        Location = new Point(295, 160),
        Size = new Size(75, 23),
        Anchor = AnchorStyles.Right
    };

    // Ajouter les contr√¥les au GroupBox
    groupBoxContact.Controls.Add(labelNom);
    groupBoxContact.Controls.Add(textBoxNom);
    groupBoxContact.Controls.Add(labelPrenom);
    groupBoxContact.Controls.Add(textBoxPrenom);
    groupBoxContact.Controls.Add(labelEmail);
    groupBoxContact.Controls.Add(textBoxEmail);
    groupBoxContact.Controls.Add(labelTelephone);
    groupBoxContact.Controls.Add(textBoxTelephone);
    groupBoxContact.Controls.Add(buttonEnregistrer);

    // Cr√©er un Panel pour regrouper d'autres contr√¥les
    Panel panelOptions = new Panel
    {
        Location = new Point(20, 240),
        Size = new Size(400, 150),
        BorderStyle = BorderStyle.FixedSingle,
        Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right
    };

    // Ajouter des CheckBoxes au Panel
    CheckBox checkBoxNewsletter = new CheckBox
    {
        Text = "S'inscrire √† la newsletter",
        Location = new Point(20, 20),
        AutoSize = true
    };

    CheckBox checkBoxPromo = new CheckBox
    {
        Text = "Recevoir des offres promotionnelles",
        Location = new Point(20, 50),
        AutoSize = true
    };

    // Ajouter des RadioButtons au Panel
    RadioButton radioButtonEmail = new RadioButton
    {
        Text = "Pr√©f√©rence de contact par email",
        Location = new Point(20, 80),
        AutoSize = true,
        Checked = true
    };

    RadioButton radioButtonTelephone = new RadioButton
    {
        Text = "Pr√©f√©rence de contact par t√©l√©phone",
        Location = new Point(20, 110),
        AutoSize = true
    };

    // Ajouter les contr√¥les au Panel
    panelOptions.Controls.Add(checkBoxNewsletter);
    panelOptions.Controls.Add(checkBoxPromo);
    panelOptions.Controls.Add(radioButtonEmail);
    panelOptions.Controls.Add(radioButtonTelephone);

    // Ajouter les conteneurs au formulaire
    this.Controls.Add(groupBoxContact);
    this.Controls.Add(panelOptions);
}
```


### Cr√©ation d'un contr√¥le composite avanc√©

Cr√©ons un contr√¥le composite plus avanc√© sous forme de UserControl pour la s√©lection d'une adresse.

```textmate
// .NET Framework 4.7.2 et .NET 8
// Ajouter un nouveau fichier "AdresseControl.cs" de type "User Control"
public partial class AdresseControl : UserControl
{
    // Propri√©t√©s pour acc√©der aux valeurs
    public string Adresse
    {
        get => textBoxAdresse.Text;
        set => textBoxAdresse.Text = value;
    }

    public string CodePostal
    {
        get => textBoxCodePostal.Text;
        set => textBoxCodePostal.Text = value;
    }

    public string Ville
    {
        get => textBoxVille.Text;
        set => textBoxVille.Text = value;
    }

    public string Pays
    {
        get => comboBoxPays.SelectedItem?.ToString() ?? "";
        set
        {
            int index = comboBoxPays.Items.IndexOf(value);
            if (index >= 0)
            {
                comboBoxPays.SelectedIndex = index;
            }
            else if (comboBoxPays.Items.Count > 0)
            {
                comboBoxPays.SelectedIndex = 0;
            }
        }
    }

    // √âv√©nements personnalis√©s
    public event EventHandler AdresseChanged;

    private bool _validationEnabled = true;
    public bool ValidationEnabled
    {
        get => _validationEnabled;
        set
        {
            _validationEnabled = value;
            ValiderChamps();
        }
    }

    public AdresseControl()
    {
        InitializeComponent();

        // Initialiser les pays
        InitialiserPays();

        // Attacher les gestionnaires d'√©v√©nements pour la validation
        textBoxAdresse.TextChanged += TextBox_TextChanged;
        textBoxCodePostal.TextChanged += TextBox_TextChanged;
        textBoxVille.TextChanged += TextBox_TextChanged;
        comboBoxPays.SelectedIndexChanged += ComboBox_SelectedIndexChanged;

        // Effectuer une validation initiale
        ValiderChamps();
    }

    // Les m√©thodes d'initialisation du concepteur seront g√©n√©r√©es automatiquement,
    // mais voici comment elles pourraient √™tre impl√©ment√©es manuellement :
    private void InitializeComponent()
    {
        // Cr√©er les contr√¥les
        this.tableLayoutPanel = new TableLayoutPanel();
        this.labelAdresse = new Label();
        this.textBoxAdresse = new TextBox();
        this.labelCodePostal = new Label();
        this.textBoxCodePostal = new TextBox();
        this.labelVille = new Label();
        this.textBoxVille = new TextBox();
        this.labelPays = new Label();
        this.comboBoxPays = new ComboBox();
        this.buttonValider = new Button();
        this.errorProvider = new ErrorProvider();

        // TableLayoutPanel
        this.tableLayoutPanel.ColumnCount = 2;
        this.tableLayoutPanel.RowCount = 5;
        this.tableLayoutPanel.Dock = DockStyle.Fill;
        this.tableLayoutPanel.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 30F));
        this.tableLayoutPanel.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 70F));
        for (int i = 0; i < 5; i++)
        {
            this.tableLayoutPanel.RowStyles.Add(new RowStyle(SizeType.Absolute, 30F));
        }

        // Adresse
        this.labelAdresse.Text = "Adresse :";
        this.labelAdresse.Anchor = AnchorStyles.Left | AnchorStyles.Right;
        this.textBoxAdresse.Dock = DockStyle.Fill;

        // Code postal
        this.labelCodePostal.Text = "Code postal :";
        this.labelCodePostal.Anchor = AnchorStyles.Left | AnchorStyles.Right;
        this.textBoxCodePostal.Dock = DockStyle.Fill;

        // Ville
        this.labelVille.Text = "Ville :";
        this.labelVille.Anchor = AnchorStyles.Left | AnchorStyles.Right;
        this.textBoxVille.Dock = DockStyle.Fill;

        // Pays
        this.labelPays.Text = "Pays :";
        this.labelPays.Anchor = AnchorStyles.Left | AnchorStyles.Right;
        this.comboBoxPays.Dock = DockStyle.Fill;
        this.comboBoxPays.DropDownStyle = ComboBoxStyle.DropDownList;

        // Bouton Valider
        this.buttonValider.Text = "Valider";
        this.buttonValider.Click += ButtonValider_Click;

        // Ajouter les contr√¥les au TableLayoutPanel
        this.tableLayoutPanel.Controls.Add(this.labelAdresse, 0, 0);
        this.tableLayoutPanel.Controls.Add(this.textBoxAdresse, 1, 0);
        this.tableLayoutPanel.Controls.Add(this.labelCodePostal, 0, 1);
        this.tableLayoutPanel.Controls.Add(this.textBoxCodePostal, 1, 1);
        this.tableLayoutPanel.Controls.Add(this.labelVille, 0, 2);
        this.tableLayoutPanel.Controls.Add(this.textBoxVille, 1, 2);
        this.tableLayoutPanel.Controls.Add(this.labelPays, 0, 3);
        this.tableLayoutPanel.Controls.Add(this.comboBoxPays, 1, 3);
        this.tableLayoutPanel.Controls.Add(this.buttonValider, 1, 4);

        // Configurer le UserControl
        this.Controls.Add(this.tableLayoutPanel);
        this.Name = "AdresseControl";
        this.Size = new Size(400, 150);
    }

    private TableLayoutPanel tableLayoutPanel;
    private Label labelAdresse;
    private TextBox textBoxAdresse;
    private Label labelCodePostal;
    private TextBox textBoxCodePostal;
    private Label labelVille;
    private TextBox textBoxVille;
    private Label labelPays;
    private ComboBox comboBoxPays;
    private Button buttonValider;
    private ErrorProvider errorProvider;

    private void InitialiserPays()
    {
        // Liste des pays
        string[] pays = new string[]
        {
            "France",
            "Belgique",
            "Suisse",
            "Canada",
            "Luxembourg",
            "Allemagne",
            "Italie",
            "Espagne",
            "Royaume-Uni",
            "√âtats-Unis"
        };

        // Ajouter les pays √† la ComboBox
        comboBoxPays.Items.AddRange(pays);

        // S√©lectionner la France par d√©faut
        if (comboBoxPays.Items.Count > 0)
        {
            comboBoxPays.SelectedIndex = 0;
        }
    }

    private void TextBox_TextChanged(object sender, EventArgs e)
    {
        ValiderChamps();
        NotifierChangementAdresse();
    }

    private void ComboBox_SelectedIndexChanged(object sender, EventArgs e)
    {
        ValiderChamps();
        NotifierChangementAdresse();
    }

    private void ButtonValider_Click(object sender, EventArgs e)
    {
        if (ValiderChamps())
        {
            MessageBox.Show("Adresse valide !", "Validation", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }
        else
        {
            MessageBox.Show("Veuillez corriger les erreurs avant de continuer.", "Validation", MessageBoxButtons.OK, MessageBoxIcon.Warning);
        }
    }

    private bool ValiderChamps()
    {
        if (!_validationEnabled)
        {
            errorProvider.Clear();
            return true;
        }

        bool estValide = true;

        // Valider l'adresse
        if (string.IsNullOrWhiteSpace(textBoxAdresse.Text))
        {
            errorProvider.SetError(textBoxAdresse, "L'adresse est requise");
            estValide = false;
        }
        else
        {
            errorProvider.SetError(textBoxAdresse, "");
        }

        // Valider le code postal
        string codePostal = textBoxCodePostal.Text.Trim();
        string paysSelectionne = comboBoxPays.SelectedItem?.ToString() ?? "";
        bool codePostalValide = true;

        if (string.IsNullOrWhiteSpace(codePostal))
        {
            errorProvider.SetError(textBoxCodePostal, "Le code postal est requis");
            estValide = false;
            codePostalValide = false;
        }
        else
        {
            // Valider selon le pays s√©lectionn√©
            switch (paysSelectionne)
            {
                case "France":
                    // Code postal fran√ßais : 5 chiffres
                    if (!System.Text.RegularExpressions.Regex.IsMatch(codePostal, @"^\d{5}$"))
                    {
                        errorProvider.SetError(textBoxCodePostal, "Le code postal fran√ßais doit contenir 5 chiffres");
                        estValide = false;
                        codePostalValide = false;
                    }
                    break;

                case "Belgique":
                    // Code postal belge : 4 chiffres
                    if (!System.Text.RegularExpressions.Regex.IsMatch(codePostal, @"^\d{4}$"))
                    {
                        errorProvider.SetError(textBoxCodePostal, "Le code postal belge doit contenir 4 chiffres");
                        estValide = false;
                        codePostalValide = false;
                    }
                    break;

                case "Suisse":
                    // Code postal suisse : 4 chiffres
                    if (!System.Text.RegularExpressions.Regex.IsMatch(codePostal, @"^\d{4}$"))
                    {
                        errorProvider.SetError(textBoxCodePostal, "Le code postal suisse doit contenir 4 chiffres");
                        estValide = false;
                        codePostalValide = false;
                    }
                    break;

                case "Canada":
                    // Code postal canadien : format A1A 1A1
                    if (!System.Text.RegularExpressions.Regex.IsMatch(codePostal, @"^[A-Za-z]\d[A-Za-z]\s?\d[A-Za-z]\d$"))
                    {
                        errorProvider.SetError(textBoxCodePostal, "Le code postal canadien doit √™tre au format A1A 1A1");
                        estValide = false;
                        codePostalValide = false;
                    }
                    break;

                default:
                    // Pour les autres pays, v√©rifier simplement que le code postal n'est pas vide
                    if (string.IsNullOrWhiteSpace(codePostal))
                    {
                        errorProvider.SetError(textBoxCodePostal, "Le code postal est requis");
                        estValide = false;
                        codePostalValide = false;
                    }
                    break;
            }
        }

        if (codePostalValide)
        {
            errorProvider.SetError(textBoxCodePostal, "");
        }

        // Valider la ville
        if (string.IsNullOrWhiteSpace(textBoxVille.Text))
        {
            errorProvider.SetError(textBoxVille, "La ville est requise");
            estValide = false;
        }
        else
        {
            errorProvider.SetError(textBoxVille, "");
        }

        // Valider le pays
        if (comboBoxPays.SelectedIndex < 0)
        {
            errorProvider.SetError(comboBoxPays, "Le pays est requis");
            estValide = false;
        }
        else
        {
            errorProvider.SetError(comboBoxPays, "");
        }

        return estValide;
    }

    private void NotifierChangementAdresse()
    {
        AdresseChanged?.Invoke(this, EventArgs.Empty);
    }

    // M√©thode publique pour r√©cup√©rer l'adresse compl√®te
    public string GetAdresseComplete()
    {
        return $"{Adresse}\n{CodePostal} {Ville}\n{Pays}";
    }

    // M√©thode publique pour d√©finir l'adresse compl√®te
    public void SetAdresseComplete(string adresse, string codePostal, string ville, string pays)
    {
        Adresse = adresse;
        CodePostal = codePostal;
        Ville = ville;
        Pays = pays;
    }
}
```


Utilisation du contr√¥le composite :

```textmate
public partial class Form1 : Form
{
    public Form1()
    {
        InitializeComponent();

        // Cr√©er et configurer le contr√¥le d'adresse
        AdresseControl adresseControl = new AdresseControl
        {
            Location = new Point(20, 20),
            Size = new Size(400, 150),
            Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right
        };

        // D√©finir une adresse par d√©faut
        adresseControl.SetAdresseComplete(
            "123 rue de la R√©publique",
            "75001",
            "Paris",
            "France"
        );

        // Attacher un gestionnaire d'√©v√©nements
        adresseControl.AdresseChanged += (sender, e) =>
        {
            // Mettre √† jour d'autres parties de l'application
            this.Text = $"Adresse : {adresseControl.Ville}, {adresseControl.Pays}";
        };

        // Ajouter au formulaire
        this.Controls.Add(adresseControl);

        // Ajouter un bouton pour afficher l'adresse compl√®te
        Button buttonAfficher = new Button
        {
            Text = "Afficher l'adresse",
            Location = new Point(20, 180),
            Size = new Size(150, 30)
        };

        buttonAfficher.Click += (sender, e) =>
        {
            MessageBox.Show(
                adresseControl.GetAdresseComplete(),
                "Adresse compl√®te",
                MessageBoxButtons.OK,
                MessageBoxIcon.Information
            );
        };

        this.Controls.Add(buttonAfficher);
    }
}
```


### Contr√¥les composites avanc√©s avec des conteneurs sp√©cialis√©s

Les contr√¥les comme FlowLayoutPanel et TableLayoutPanel sont particuli√®rement utiles pour cr√©er des interfaces utilisateur dynamiques.

```textmate
// .NET Framework 4.7.2 et .NET 8
private void InitializeAdvancedLayoutControls()
{
    // Cr√©er un FlowLayoutPanel pour une disposition dynamique
    FlowLayoutPanel flowLayoutPanel = new FlowLayoutPanel
    {
        Location = new Point(20, 20),
        Size = new Size(300, 150),
        FlowDirection = FlowDirection.LeftToRight,
        WrapContents = true,
        BorderStyle = BorderStyle.FixedSingle,
        AutoScroll = true,
        Padding = new Padding(5),
        Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right
    };

    // Ajouter plusieurs boutons au FlowLayoutPanel
    for (int i = 1; i <= 10; i++)
    {
        Button button = new Button
        {
            Text = $"Bouton {i}",
            Size = new Size(80, 30),
            Margin = new Padding(5)
        };

        button.Click += (sender, e) =>
        {
            Button clickedButton = (Button)sender;
            MessageBox.Show($"Vous avez cliqu√© sur {clickedButton.Text}");
        };

        flowLayoutPanel.Controls.Add(button);
    }

    // Cr√©er un TableLayoutPanel pour une disposition en grille
    TableLayoutPanel tableLayoutPanel = new TableLayoutPanel
    {
        Location = new Point(20, 180),
        Size = new Size(300, 200),
        ColumnCount = 3,
        RowCount = 3,
        BorderStyle = BorderStyle.FixedSingle,
        CellBorderStyle = TableLayoutPanelCellBorderStyle.Single,
        Padding = new Padding(3),
        Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right
    };

    // D√©finir les styles de colonnes et de lignes
    tableLayoutPanel.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 33.33F));
    tableLayoutPanel.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 33.33F));
    tableLayoutPanel.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 33.34F));

    tableLayoutPanel.RowStyles.Add(new RowStyle(SizeType.Percent, 33.33F));
    tableLayoutPanel.RowStyles.Add(new RowStyle(SizeType.Percent, 33.33F));
    tableLayoutPanel.RowStyles.Add(new RowStyle(SizeType.Percent, 33.34F));

    // Ajouter des contr√¥les au TableLayoutPanel
    for (int row = 0; row < 3; row++)
    {
        for (int col = 0; col < 3; col++)
        {
            if (row == 0 && col == 0)
            {
                // Ajouter un Label dans la premi√®re cellule
                Label label = new Label
                {
                    Text = "Produit",
                    TextAlign = ContentAlignment.MiddleCenter,
                    Dock = DockStyle.Fill,
                    Font = new Font("Segoe UI", 9F, FontStyle.Bold)
                };
                tableLayoutPanel.Controls.Add(label, col, row);
            }
            else if (row == 0 && col == 1)
            {
                // Ajouter un Label dans la deuxi√®me cellule
                Label label = new Label
                {
                    Text = "Quantit√©",
                    TextAlign = ContentAlignment.MiddleCenter,
                    Dock = DockStyle.Fill,
                    Font = new Font("Segoe UI", 9F, FontStyle.Bold)
                };
                tableLayoutPanel.Controls.Add(label, col, row);
            }
            else if (row == 0 && col == 2)
            {
                // Ajouter un Label dans la troisi√®me cellule
                Label label = new Label
                {
                    Text = "Prix",
                    TextAlign = ContentAlignment.MiddleCenter,
                    Dock = DockStyle.Fill,
                    Font = new Font("Segoe UI", 9F, FontStyle.Bold)
                };
                tableLayoutPanel.Controls.Add(label, col, row);
            }
            else if (col == 0)
            {
                // Ajouter des noms de produits dans la premi√®re colonne
                ComboBox comboBox = new ComboBox
                {
                    Dock = DockStyle.Fill,
                    DropDownStyle = ComboBoxStyle.DropDownList
                };

                comboBox.Items.AddRange(new string[] { "Produit A", "Produit B", "Produit C" });
                if (comboBox.Items.Count > 0)
                {
                    comboBox.SelectedIndex = 0;
                }

                tableLayoutPanel.Controls.Add(comboBox, col, row);
            }
            else if (col == 1)
            {
                // Ajouter des NumericUpDown pour les quantit√©s dans la deuxi√®me colonne
                NumericUpDown numericUpDown = new NumericUpDown
                {
                    Dock = DockStyle.Fill,
                    Minimum = 1,
                    Maximum = 100,
                    Value = 1
                };

                tableLayoutPanel.Controls.Add(numericUpDown, col, row);
            }
            else if (col == 2)
            {
                // Ajouter des TextBox pour les prix dans la troisi√®me colonne
                TextBox textBox = new TextBox
                {
                    Dock = DockStyle.Fill,
                    Text = "0,00 ‚Ç¨",
                    TextAlign = HorizontalAlignment.Right
                };

                tableLayoutPanel.Controls.Add(textBox, col, row);
            }
        }
    }

    // Ajouter un SplitContainer pour diviser l'√©cran en deux parties
    SplitContainer splitContainer = new SplitContainer
    {
        Location = new Point(20, 390),
        Size = new Size(300, 200),
        Orientation = Orientation.Horizontal,
        SplitterDistance = 100,
        Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Bottom
    };

    // Configurer le panneau sup√©rieur
    TextBox textBoxSource = new TextBox
    {
        Multiline = true,
        Dock = DockStyle.Fill,
        ScrollBars = ScrollBars.Vertical,
        Text = "Entrez du texte ici..."
    };

    splitContainer.Panel1.Controls.Add(textBoxSource);

    // Configurer le panneau inf√©rieur
    TextBox textBoxPreview = new TextBox
    {
        Multiline = true,
        Dock = DockStyle.Fill,
        ScrollBars = ScrollBars.Vertical,
        ReadOnly = true
    };

    splitContainer.Panel2.Controls.Add(textBoxPreview);

    // Synchroniser les deux TextBox
    textBoxSource.TextChanged += (sender, e) =>
    {
        textBoxPreview.Text = textBoxSource.Text.ToUpper();
    };

    // D√©clencher l'√©v√©nement pour initialiser le texte
    textBoxSource.Text = "Entrez du texte ici...";

    // Ajouter les contr√¥les au formulaire
    this.Controls.Add(flowLayoutPanel);
    this.Controls.Add(tableLayoutPanel);
    this.Controls.Add(splitContainer);
}
```


Ces exemples illustrent les contr√¥les de base de Windows Forms, leurs propri√©t√©s principales, et comment cr√©er des contr√¥les personnalis√©s pour r√©pondre √† des besoins sp√©cifiques. En comprenant ces concepts, vous serez en mesure de d√©velopper des interfaces utilisateur riches et interactives dans vos applications Windows Forms.
