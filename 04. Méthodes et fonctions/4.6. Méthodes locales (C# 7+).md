# 4.6. Méthodes locales (C# 7+)

Les méthodes locales, introduites dans C# 7.0, permettent de définir des fonctions à l'intérieur d'autres méthodes, propriétés ou constructeurs. Cette fonctionnalité est disponible aussi bien dans .NET Framework 4.7.2 que dans .NET 8, et elle offre plusieurs avantages pour organiser et encapsuler votre code. Cette section explore en détail comment définir et utiliser les méthodes locales, ainsi que leurs avantages et cas d'utilisation privilégiés.

## 4.6.1. Définition dans d'autres méthodes

### Syntaxe de base

Une méthode locale est définie à l'intérieur du corps d'une autre méthode (ou propriété, constructeur, etc.). Sa portée est limitée à cette méthode contenante.

```textmate
public void MéthodeContenante()
{
    // Code avant la méthode locale

    // Définition d'une méthode locale
    void MéthodeLocale(int paramètre)
    {
        // Corps de la méthode locale
        Console.WriteLine($"Paramètre reçu : {paramètre}");
    }

    // Code après la définition

    // Appel de la méthode locale
    MéthodeLocale(42);

    // Autre code
}
```


### Caractéristiques principales

#### Position dans le code

Les méthodes locales peuvent être définies à n'importe quel endroit dans la méthode contenante, mais par convention, elles sont souvent placées soit au début, soit à la fin de celle-ci :

```textmate
public int CalculerStatistiques(int[] nombres)
{
    // 1. Placement au début (avant utilisation)
    int Carré(int x) => x * x;

    if (nombres == null || nombres.Length == 0)
        return 0;

    int somme = nombres.Sum();
    int sommeDesCarrés = nombres.Sum(n => Carré(n));

    // ou

    // 2. Placement à la fin (après utilisation)
    int Carré(int x) => x * x;

    return sommeDesCarrés - Carré(somme) / nombres.Length;
}
```


#### Types de retour et paramètres

Les méthodes locales peuvent avoir des types de retour, des paramètres, et des modificateurs tout comme les méthodes normales :

```textmate
public bool EstMotValide(string mot)
{
    // Méthode locale sans type de retour (void)
    void LogValidation(string message)
    {
        Console.WriteLine($"Validation: {message}");
    }

    // Méthode locale avec type de retour et paramètres
    bool ContientLettresUniquement(string texte)
    {
        return texte.All(char.IsLetter);
    }

    // Méthode locale avec paramètres optionnels
    string Normaliser(string texte, bool supprimerEspaces = false)
    {
        var résultat = texte.ToLower();
        if (supprimerEspaces)
            résultat = résultat.Replace(" ", "");
        return résultat;
    }

    if (string.IsNullOrEmpty(mot))
    {
        LogValidation("Mot vide");
        return false;
    }

    var motNormalisé = Normaliser(mot, true);

    if (!ContientLettresUniquement(motNormalisé))
    {
        LogValidation("Contient des caractères non alphabétiques");
        return false;
    }

    LogValidation("Mot valide");
    return true;
}
```


#### Accès aux variables de la méthode contenante

Les méthodes locales peuvent accéder à toutes les variables de la méthode contenante, y compris les paramètres et les variables locales :

```textmate
public void TraiterCommande(int idCommande, bool envoyerNotification)
{
    string statut = "En cours";
    var dateTraitement = DateTime.Now;

    // La méthode locale peut accéder à idCommande, envoyerNotification,
    // statut et dateTraitement
    void EnregistrerJournal(string action)
    {
        Console.WriteLine($"[{dateTraitement}] Commande {idCommande}: {action} - Statut: {statut}");

        if (envoyerNotification)
        {
            EnvoyerNotification(idCommande, action);
        }
    }

    // Code principal
    EnregistrerJournal("Début traitement");

    // Traitement de la commande
    statut = "Terminé";

    EnregistrerJournal("Fin traitement");
}
```


#### Restrictions sur les modificateurs

Les méthodes locales ont certaines restrictions sur les modificateurs qu'elles peuvent utiliser :

```textmate
public void ExempleModificateurs()
{
    // VALIDE: modificateur static dans une méthode locale (C# 8.0+)
    static int Additionner(int a, int b) => a + b;

    // INVALIDE: les méthodes locales ne peuvent pas être public, private, protected, etc.
    // public void MéthodeInvalide() { }

    // INVALIDE: les méthodes locales ne peuvent pas être virtual, abstract, override, etc.
    // virtual void MéthodeInvalide() { }

    // VALIDE: async est autorisé
    async Task<int> RécupérerDonnéesAsync()
    {
        await Task.Delay(100);
        return 42;
    }

    // Utilisation
    int résultat = Additionner(5, 3);
    var tâche = RécupérerDonnéesAsync();
}
```


#### Visibilité et portée

Les méthodes locales sont uniquement visibles dans la méthode contenante :

```textmate
public class Exemple
{
    public void Méthode1()
    {
        void MéthodeLocale()
        {
            Console.WriteLine("Dans la méthode locale");
        }

        MéthodeLocale(); // Fonctionne
    }

    public void Méthode2()
    {
        // MéthodeLocale(); // ERREUR: MéthodeLocale n'est pas visible ici
    }
}
```


### Méthodes locales statiques

À partir de C# 8.0, les méthodes locales peuvent être déclarées avec le mot-clé `static`, ce qui les empêche d'accéder aux variables de la méthode contenante (sauf si elles sont passées en paramètres). Cela permet d'éviter les captures accidentelles de variables et améliore la performance dans certains cas :

```textmate
// Disponible dans .NET Core 3.0+ et .NET 8
public void ExempleMéthodeLocaleStatique(int[] données)
{
    var facteur = 10;

    // Méthode locale statique - ne peut pas accéder à 'facteur'
    static double Calculer(int valeur)
    {
        // facteur ne peut pas être utilisé ici
        return Math.Sqrt(valeur);
    }

    // Méthode locale non statique - peut accéder à 'facteur'
    double CalculerAvecFacteur(int valeur)
    {
        return Math.Sqrt(valeur) * facteur;
    }

    foreach (var valeur in données)
    {
        Console.WriteLine(Calculer(valeur));
        Console.WriteLine(CalculerAvecFacteur(valeur));
    }
}
```


### Différences entre .NET Framework 4.7.2 et .NET 8

Les méthodes locales sont prises en charge à la fois dans .NET Framework 4.7.2 et .NET 8, avec quelques différences :

| Fonctionnalité | .NET Framework 4.7.2 | .NET 8 |
|----------------|----------------------|--------|
| Méthodes locales de base | ✅ | ✅ |
| Méthodes locales statiques | ❌ (requiert C# 8.0+) | ✅ |
| Attributs sur méthodes locales | ✅ | ✅ |
| Méthodes locales avec des types de référence par valeur (`ref struct`) | ❌ (requiert C# 8.0+) | ✅ |

Pour .NET Framework 4.7.2, vous pouvez utiliser les méthodes locales de base, mais les fonctionnalités introduites dans C# 8.0 et versions ultérieures nécessitent généralement .NET Core ou .NET 5+.

## 4.6.2. Avantages et cas d'utilisation

Les méthodes locales offrent plusieurs avantages qui en font un outil précieux dans votre boîte à outils de développement C#.

### 1. Encapsulation améliorée

Les méthodes locales permettent d'encapsuler une logique auxiliaire qui n'a pas besoin d'être accessible en dehors de la méthode contenante :

```textmate
public List<Produit> FiltrerEtTrierProduits(List<Produit> produits, string catégorie)
{
    // Cette logique de filtrage n'a pas besoin d'être exposée en dehors de cette méthode
    bool CorrespondAuFiltre(Produit p)
    {
        if (string.IsNullOrEmpty(catégorie))
            return true;

        return p.Catégorie.Equals(catégorie, StringComparison.OrdinalIgnoreCase);
    }

    // Cette logique de tri est spécifique à cette méthode
    int ComparerProduits(Produit p1, Produit p2)
    {
        var comparaisonPrix = p1.Prix.CompareTo(p2.Prix);
        if (comparaisonPrix != 0)
            return comparaisonPrix;

        return string.Compare(p1.Nom, p2.Nom, StringComparison.OrdinalIgnoreCase);
    }

    // Utilisation des méthodes locales
    var résultat = produits
        .Where(CorrespondAuFiltre)
        .ToList();

    résultat.Sort(ComparerProduits);

    return résultat;
}
```


### 2. Éviter la pollution du namespace de classe

Avant les méthodes locales, il fallait souvent déclarer des méthodes privées uniquement utilisées par une seule méthode, ce qui polluait l'espace de noms de la classe :

```textmate
// Avant C# 7.0
public class Exemple
{
    public double CalculerStatistiques(double[] valeurs)
    {
        // Logique principale
        var moyenne = CalculerMoyenne(valeurs);
        var écartType = CalculerÉcartType(valeurs, moyenne);
        return écartType / moyenne;
    }

    // Ces méthodes privées polluent l'espace de noms de la classe
    // alors qu'elles ne sont utilisées que par CalculerStatistiques
    private double CalculerMoyenne(double[] valeurs)
    {
        return valeurs.Sum() / valeurs.Length;
    }

    private double CalculerÉcartType(double[] valeurs, double moyenne)
    {
        return Math.Sqrt(valeurs.Sum(v => Math.Pow(v - moyenne, 2)) / valeurs.Length);
    }
}

// Avec C# 7.0+
public class ExempleAvecMéthodesLocales
{
    public double CalculerStatistiques(double[] valeurs)
    {
        // Méthodes locales - n'encombrent pas l'espace de noms de la classe
        double CalculerMoyenne(double[] vals)
        {
            return vals.Sum() / vals.Length;
        }

        double CalculerÉcartType(double[] vals, double moy)
        {
            return Math.Sqrt(vals.Sum(v => Math.Pow(v - moy, 2)) / vals.Length);
        }

        // Logique principale
        var moyenne = CalculerMoyenne(valeurs);
        var écartType = CalculerÉcartType(valeurs, moyenne);
        return écartType / moyenne;
    }
}
```


### 3. Performance améliorée pour les fermetures

Les méthodes locales sont plus performantes que les expressions lambda dans certains scénarios, notamment lorsqu'elles sont appelées plusieurs fois ou dans des boucles :

```textmate
public void TraiterDonnées(List<int> données)
{
    var résultats = new List<int>();

    // Option 1: Expression lambda - crée une fermeture (closure)
    // qui peut entraîner des allocations de mémoire sur le tas
    Func<int, int> transformer = x => x * x + 1;

    // Option 2: Méthode locale - souvent compilée plus efficacement,
    // sans allocations supplémentaires
    int Transformer(int x) => x * x + 1;

    foreach (var donnée in données)
    {
        // La méthode locale est généralement plus performante ici
        résultats.Add(Transformer(donnée));
    }
}
```


Dans cet exemple, le compilateur peut optimiser la méthode locale `Transformer` plus efficacement qu'une expression lambda équivalente, en évitant la création d'objets délégués à chaque itération.

### 4. Meilleure lisibilité pour la logique récursive

Les méthodes locales sont particulièrement utiles pour implémenter des algorithmes récursifs :

```textmate
public int CalculerFactorielle(int n)
{
    // Validation d'entrée
    if (n < 0)
        throw new ArgumentException("La factorielle n'est définie que pour les entiers non négatifs.");

    // Méthode locale récursive
    int FactorielleRécursive(int i)
    {
        if (i <= 1)
            return 1;

        return i * FactorielleRécursive(i - 1);
    }

    return FactorielleRécursive(n);
}

public List<int> ParcourirArbre(Nœud racine)
{
    var résultat = new List<int>();

    // Méthode locale récursive pour parcourir l'arbre
    void Parcourir(Nœud nœud)
    {
        if (nœud == null)
            return;

        résultat.Add(nœud.Valeur);

        foreach (var enfant in nœud.Enfants)
        {
            Parcourir(enfant);
        }
    }

    Parcourir(racine);
    return résultat;
}
```


### 5. Clarté du code et intention

Les méthodes locales peuvent améliorer considérablement la lisibilité en donnant des noms significatifs à des blocs de code complexes :

```textmate
public ValidationResult ValiderUtilisateur(Utilisateur utilisateur)
{
    var résultat = new ValidationResult();

    void VérifierChampObligatoire(string valeur, string nomChamp)
    {
        if (string.IsNullOrWhiteSpace(valeur))
        {
            résultat.Erreurs.Add($"Le champ {nomChamp} est obligatoire.");
        }
    }

    void VérifierLongueurMinimale(string valeur, string nomChamp, int longueurMin)
    {
        if (!string.IsNullOrEmpty(valeur) && valeur.Length < longueurMin)
        {
            résultat.Erreurs.Add($"Le champ {nomChamp} doit contenir au moins {longueurMin} caractères.");
        }
    }

    void VérifierFormatEmail(string email)
    {
        if (!string.IsNullOrEmpty(email) && !email.Contains("@"))
        {
            résultat.Erreurs.Add("L'adresse e-mail n'est pas valide.");
        }
    }

    // Exécution des validations
    VérifierChampObligatoire(utilisateur.Nom, "Nom");
    VérifierChampObligatoire(utilisateur.Email, "Email");
    VérifierLongueurMinimale(utilisateur.MotDePasse, "Mot de passe", 8);
    VérifierFormatEmail(utilisateur.Email);

    résultat.EstValide = résultat.Erreurs.Count == 0;
    return résultat;
}
```


### 6. Organisation du code par étapes

Les méthodes locales sont idéales pour diviser une méthode complexe en étapes logiques et nommées :

```textmate
public async Task<RapportCommande> GénérerRapportCommandeAsync(int idCommande)
{
    var rapport = new RapportCommande();

    // 1. Récupération des données
    async Task RécupérerDonnéesAsync()
    {
        rapport.Commande = await _commandeRepository.ObtenirParIdAsync(idCommande);
        rapport.Client = await _clientRepository.ObtenirParIdAsync(rapport.Commande.IdClient);
        rapport.Produits = await _produitRepository.ObtenirProduitsCommandeAsync(idCommande);
    }

    // 2. Calcul des statistiques
    void CalculerStatistiques()
    {
        rapport.NombreProduits = rapport.Produits.Count;
        rapport.Total = rapport.Produits.Sum(p => p.Prix * p.Quantité);
        rapport.RemiseAppliquée = CalculerRemise(rapport.Client, rapport.Total);
        rapport.TotalAvecRemise = rapport.Total - rapport.RemiseAppliquée;
    }

    // 3. Génération du contenu formaté
    void GénérerContenuFormaté()
    {
        rapport.EnTête = $"Rapport de commande #{rapport.Commande.Référence}";
        rapport.RésuméClient = $"Client: {rapport.Client.Nom} ({rapport.Client.Email})";
        rapport.DétailsCommande = GénérerTableauProduits(rapport.Produits);
        rapport.PiedDePage = $"Total: {rapport.TotalAvecRemise:C} (remise: {rapport.RemiseAppliquée:C})";
    }

    // Exécution séquentielle des étapes
    await RécupérerDonnéesAsync();
    CalculerStatistiques();
    GénérerContenuFormaté();

    return rapport;
}
```


### 7. Utilisation avec asynchrone/await

Les méthodes locales peuvent être asynchrones, ce qui est particulièrement utile pour encapsuler des opérations asynchrones au sein d'une méthode plus grande :

```textmate
public async Task<RésultatSynchronisation> SynchroniserDonnéesAsync()
{
    var résultat = new RésultatSynchronisation();

    // Méthode locale asynchrone pour la synchronisation des utilisateurs
    async Task SynchroniserUtilisateursAsync()
    {
        try
        {
            var utilisateurs = await _serviceApi.ObtenirUtilisateursAsync();
            résultat.NombreUtilisateursSynchronisés = await _repository.MettreÀJourUtilisateursAsync(utilisateurs);
            résultat.StatutUtilisateurs = StatutSynchronisation.Succès;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Erreur lors de la synchronisation des utilisateurs");
            résultat.StatutUtilisateurs = StatutSynchronisation.Échec;
            résultat.ErreurUtilisateurs = ex.Message;
        }
    }

    // Méthode locale asynchrone pour la synchronisation des produits
    async Task SynchroniserProduitsAsync()
    {
        try
        {
            var produits = await _serviceApi.ObtenirProduitsAsync();
            résultat.NombreProduitsSynchronisés = await _repository.MettreÀJourProduitsAsync(produits);
            résultat.StatutProduits = StatutSynchronisation.Succès;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Erreur lors de la synchronisation des produits");
            résultat.StatutProduits = StatutSynchronisation.Échec;
            résultat.ErreurProduits = ex.Message;
        }
    }

    // Exécution parallèle des tâches de synchronisation
    await Task.WhenAll(
        SynchroniserUtilisateursAsync(),
        SynchroniserProduitsAsync()
    );

    résultat.DateSynchronisation = DateTime.Now;

    return résultat;
}
```


### 8. Générateurs itérables

Les méthodes locales peuvent utiliser `yield return` pour créer des générateurs itérables qui n'ont pas besoin d'être exposés en dehors de la méthode contenante :

```textmate
public IEnumerable<int> GénérerSéquenceFibonacci(int nombreÉléments)
{
    if (nombreÉléments < 0)
        throw new ArgumentException("Le nombre d'éléments doit être positif.");

    // Générateur local implémentant la logique de Fibonacci
    IEnumerable<int> GénérerSéquence()
    {
        if (nombreÉléments == 0)
            yield break;

        yield return 0;

        if (nombreÉléments == 1)
            yield break;

        yield return 1;

        int précédent = 0;
        int courant = 1;

        for (int i = 2; i < nombreÉléments; i++)
        {
            int suivant = précédent + courant;
            yield return suivant;
            précédent = courant;
            courant = suivant;
        }
    }

    // Effectue quelques validations supplémentaires si nécessaire,
    // puis utilise le générateur local
    return GénérerSéquence();
}
```


### Bonnes pratiques et considérations

#### 1. Longueur et complexité

Bien que les méthodes locales puissent réduire la complexité, elles ne doivent pas devenir trop longues ou complexes elles-mêmes :

```textmate
// Bien : Méthode locale simple et ciblée
public void TraiterDonnées(List<DonnéeClient> données)
{
    // Méthode locale qui fait une chose bien précise
    bool EstÉligibleAuTraitement(DonnéeClient donnée)
    {
        return donnée.DateCréation > DateTime.Now.AddDays(-30) &&
               donnée.Statut != StatutClient.Inactif &&
               !string.IsNullOrEmpty(donnée.Email);
    }

    var donnéesÉligibles = données.Where(EstÉligibleAuTraitement).ToList();
    // reste du traitement...
}

// À éviter : Méthode locale trop longue et complexe
public void TraiterDonnéesMal(List<DonnéeClient> données)
{
    void TraiterToutesLesDonnées()
    {
        // Des dizaines de lignes de code ici...
        foreach (var donnée in données)
        {
            // Logique complexe qui devrait être divisée en plusieurs méthodes...
        }
        // Encore plus de code...
    }

    TraiterToutesLesDonnées();
}
```


#### 2. Déplacement vers des méthodes privées lorsque nécessaire

Si une méthode locale est réutilisée dans plusieurs méthodes, envisagez de la transformer en méthode privée :

```textmate
// Avant : Duplication des méthodes locales
public class ServiceClient
{
    public List<Client> FiltrerClientsActifs(List<Client> clients)
    {
        bool EstClientActif(Client c)
        {
            return c.Statut == StatutClient.Actif && c.DernierAchat > DateTime.Now.AddMonths(-6);
        }

        return clients.Where(EstClientActif).ToList();
    }

    public decimal CalculerRevenuClientsActifs(List<Client> clients)
    {
        bool EstClientActif(Client c)
        {
            return c.Statut == StatutClient.Actif && c.DernierAchat > DateTime.Now.AddMonths(-6);
        }

        return clients.Where(EstClientActif).Sum(c => c.ValeursAchats);
    }
}

// Après : Extraction vers une méthode privée
public class ServiceClientAmélioré
{
    private bool EstClientActif(Client client)
    {
        return client.Statut == StatutClient.Actif && client.DernierAchat > DateTime.Now.AddMonths(-6);
    }

    public List<Client> FiltrerClientsActifs(List<Client> clients)
    {
        return clients.Where(EstClientActif).ToList();
    }

    public decimal CalculerRevenuClientsActifs(List<Client> clients)
    {
        return clients.Where(EstClientActif).Sum(c => c.ValeursAchats);
    }
}
```


#### 3. Utilisation judicieuse des méthodes locales statiques

Dans .NET 8, utilisez des méthodes locales statiques lorsque vous n'avez pas besoin d'accéder aux variables de la méthode contenante, pour une meilleure performance et pour éviter les captures accidentelles :

```textmate
// .NET 8 uniquement
public void TraiterListe(List<int> nombres, int seuil)
{
    // Bonne utilisation d'une méthode locale statique
    // Pas d'accès aux variables de la méthode contenante
    static bool EstNombrePremier(int n)
    {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0 || n % 3 == 0) return false;

        for (int i = 5; i * i <= n; i += 6)
        {
            if (n % i == 0 || n % (i + 2) == 0)
                return false;
        }

        return true;
    }

    // Méthode locale non statique - nécessite l'accès à 'seuil'
    bool EstValide(int n)
    {
        return n > seuil && EstNombrePremier(n);
    }

    var résultat = nombres.Where(EstValide).ToList();

    // reste du code...
}
```


## Conclusion

Les méthodes locales, disponibles dans .NET Framework 4.7.2 et .NET 8, constituent un outil puissant pour améliorer l'organisation, la lisibilité et la performance de votre code C#. Elles excellent dans les scénarios où vous avez besoin d'une logique auxiliaire qui ne devrait pas être exposée en dehors de la méthode contenante.

Leurs principaux avantages incluent :

1. Une meilleure encapsulation de la logique
2. Une réduction de la pollution de l'espace de noms de la classe
3. Des performances améliorées par rapport aux expressions lambda dans certains cas
4. Une grande lisibilité pour les algorithmes récursifs
5. Une organisation claire du code par étapes logiques
6. La compatibilité avec les fonctionnalités asynchrones

.NET 8 offre des fonctionnalités supplémentaires comme les méthodes locales statiques, qui permettent d'optimiser davantage les performances et d'éviter certains pièges liés aux captures de variables.

En suivant les bonnes pratiques et en utilisant les méthodes locales aux endroits appropriés, vous pouvez écrire un code plus maintenable, plus lisible et plus performant, que vous travailliez avec .NET Framework 4.7.2 ou .NET 8.
