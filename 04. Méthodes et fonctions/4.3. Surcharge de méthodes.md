# 4.3. Surcharge de méthodes

La surcharge de méthodes (*method overloading*) est une fonctionnalité puissante en C# qui permet de définir plusieurs méthodes avec le même nom mais des signatures différentes. Cette technique améliore la lisibilité et l'ergonomie du code en offrant différentes façons d'invoquer une fonctionnalité similaire. Dans cette section, nous explorerons les principes de la surcharge de méthodes, les règles de résolution, et les bonnes pratiques à adopter.

## 4.3.1. Règles de résolution de surcharge

La surcharge de méthodes permet au compilateur C# de déterminer quelle version d'une méthode doit être appelée en fonction des arguments fournis. Cette résolution suit des règles précises.

### Principes fondamentaux

Pour qu'une méthode soit considérée comme une surcharge d'une autre, elle doit :

1. Avoir le même nom
2. Avoir une signature différente, c'est-à-dire :
   - Un nombre différent de paramètres, et/ou
   - Des types de paramètres différents, et/ou
   - Des modificateurs de paramètres différents (ref, out, params)

Le type de retour seul ne suffit pas à différencier deux surcharges.

### Exemples de base

```textmate
public class Calculateur
{
    // Surcharge avec différents nombres de paramètres
    public int Additionner(int a, int b)
    {
        return a + b;
    }

    public int Additionner(int a, int b, int c)
    {
        return a + b + c;
    }

    // Surcharge avec différents types de paramètres
    public double Additionner(double a, double b)
    {
        return a + b;
    }

    public string Additionner(string a, string b)
    {
        return a + b; // Concaténation de chaînes
    }

    // INCORRECT : Ne compile pas - même signature que la première méthode
    // public double Additionner(int a, int b)
    // {
    //     return a + b;
    // }
}
```


### Processus de résolution de surcharge

Lorsque le compilateur C# rencontre un appel à une méthode surchargée, il suit un processus complexe pour déterminer quelle surcharge utiliser :

1. **Correspondance exacte** : D'abord, il recherche une méthode dont les paramètres correspondent exactement aux types des arguments.
2. **Conversions implicites** : Si aucune correspondance exacte n'est trouvée, il considère les méthodes dont les paramètres peuvent recevoir les arguments après conversions implicites.
3. **Meilleure correspondance** : Si plusieurs surcharges sont éligibles, le compilateur choisit la "meilleure correspondance" selon des règles de priorité complexes.
4. **Ambiguïté** : Si plusieurs surcharges sont éligibles et qu'aucune n'est clairement meilleure, le compilateur génère une erreur d'ambiguïté.

### Exemples de résolution

```textmate
public class ExempleResolution
{
    // Exemple 1: Surcharges avec conversions implicites
    public void Afficher(int valeur)
    {
        Console.WriteLine($"Int: {valeur}");
    }

    public void Afficher(double valeur)
    {
        Console.WriteLine($"Double: {valeur}");
    }

    public void Afficher(object valeur)
    {
        Console.WriteLine($"Object: {valeur}");
    }

    // Exemple 2: Surcharges avec paramètres optionnels
    public void Configurer(int id, string nom = null)
    {
        Console.WriteLine($"Config1: {id}, {nom ?? "défaut"}");
    }

    public void Configurer(string nom)
    {
        Console.WriteLine($"Config2: {nom}");
    }

    // Exemple 3: Surcharges avec params
    public void Traiter(params int[] nombres)
    {
        Console.WriteLine($"Traitement de {nombres.Length} nombres");
    }

    public void Traiter(int premier, params int[] autres)
    {
        Console.WriteLine($"Traitement spécial pour {premier} et {autres.Length} autres");
    }
}

// Usage et résolution
var exemple = new ExempleResolution();

// Appel à Afficher
exemple.Afficher(5);        // Appelle Afficher(int)
exemple.Afficher(5.0);      // Appelle Afficher(double)
exemple.Afficher("texte");  // Appelle Afficher(object)

// Appel à Configurer
exemple.Configurer(1);           // Appelle Configurer(int, string) avec valeur par défaut
exemple.Configurer("Nom");       // Appelle Configurer(string)
exemple.Configurer(1, "Nom");    // Appelle Configurer(int, string)

// Appel à Traiter
exemple.Traiter();               // Appelle Traiter(params int[]) avec tableau vide
exemple.Traiter(1);              // Appelle Traiter(int, params int[]) avec tableau vide
exemple.Traiter(1, 2, 3);        // Appelle Traiter(int, params int[]) avec [2,3]
```


### Cas complexes et ambiguïtés

#### Conversions implicites et priorité

```textmate
public class ResolutionComplexe
{
    public void Methode(int x) { Console.WriteLine("int"); }
    public void Methode(long x) { Console.WriteLine("long"); }
    public void Methode(double x) { Console.WriteLine("double"); }

    public void Tester()
    {
        short s = 5;
        Methode(s);      // Appelle Methode(int) - conversion implicite de short à int est préférée
        Methode(10.5f);  // Appelle Methode(double) - conversion implicite de float à double est préférée
    }
}
```


#### Ambiguïtés et résolution

```textmate
public class ExempleAmbiguité
{
    // Ces méthodes ne sont pas ambiguës car les paramètres sont différents
    public void Traiter(int a, double b) { }
    public void Traiter(double a, int b) { }

    public void Tester()
    {
        Traiter(1, 2);       // Ambigu! Les deux méthodes peuvent accepter ces arguments
                            // mais nécessitent des conversions différentes
                            // Erreur de compilation

        // Solutions: forcer le type ou utiliser des casts explicites
        Traiter(1, 2.0);     // Appelle Traiter(int, double)
        Traiter(1.0, 2);     // Appelle Traiter(double, int)
        Traiter(1, (double)2); // Appelle Traiter(int, double) avec cast explicite
    }
}
```


### Différences entre .NET Framework 4.7.2 et .NET 8

Les règles de base de la surcharge de méthodes sont identiques entre .NET Framework 4.7.2 et .NET 8. Cependant, quelques fonctionnalités plus récentes peuvent affecter la surcharge :

#### Paramètres par défaut et surcharge (.NET Framework 4.7.2 et .NET 8)

```textmate
public class ParamètresDéfaut
{
    // Ces méthodes peuvent créer des ambiguïtés
    public void Méthode(int a = 0) { }
    public void Méthode() { } // Ambiguïté potentielle avec l'appel Méthode()
}
```


#### Tuples nommés (.NET 8 et .NET Framework 4.7.2 avec System.ValueTuple)

```textmate
public class SurchargeAvecTuples
{
    // Ces méthodes sont considérées comme différentes
    public void Traiter((int X, int Y) point) { }
    public void Traiter((int Lon, int Lat) coordonnées) { }

    // Les noms des éléments des tuples ne font pas partie de la signature
    // Ceci ne compilera pas (même signature)
    // public void Traiter((int A, int B) autre) { }
}
```


#### In, ref, et out (.NET Framework 4.7.2 et .NET 8)

Les modificateurs `ref`, `out` et `in` font partie de la signature et permettent de différencier les surcharges :

```textmate
public class ModificateursParamètres
{
    public void Modifier(int a) { }
    public void Modifier(ref int a) { }    // Surcharge valide
    public void Modifier(out int a) { a = 0; } // Surcharge valide
    public void Modifier(in int a) { }     // Surcharge valide (C# 7.2+)

    public void Test()
    {
        int x = 5;
        Modifier(x);       // Appelle Modifier(int)
        Modifier(ref x);   // Appelle Modifier(ref int)
        Modifier(out int y); // Appelle Modifier(out int)
        Modifier(in x);    // Appelle Modifier(in int)
    }
}
```


## 4.3.2. Bonnes pratiques

La surcharge de méthodes, bien qu'utile, peut créer des confusions si elle est mal utilisée. Voici des bonnes pratiques à suivre.

### 1. Maintenir une cohérence sémantique

Les surcharges doivent représenter la même opération conceptuelle, appliquée à différents types ou avec différentes options.

```textmate
// BIEN : Toutes les surcharges réalisent la même opération conceptuelle
public class BonneConception
{
    public int Additionner(int a, int b) => a + b;
    public double Additionner(double a, double b) => a + b;
    public decimal Additionner(decimal a, decimal b) => a + b;
}

// MAUVAIS : Les surcharges font des opérations conceptuellement différentes
public class MauvaiseConception
{
    public int Calculer(int a, int b) => a + b;  // Addition
    public int Calculer(int a) => a * a;        // Carré
    public double Calculer(double a, double b, double c) => a * b / c;  // Opération complexe
}
```


### 2. Limiter le nombre de surcharges

Trop de surcharges peut rendre l'API difficile à comprendre et à utiliser.

```textmate
// BIEN : Nombre limité de surcharges avec des différences claires
public class BonnePratique
{
    public void Enregistrer(string message) { /* Enregistre avec paramètres par défaut */ }
    public void Enregistrer(string message, LogLevel niveau) { /* Enregistre avec niveau spécifié */ }
    public void Enregistrer(string message, LogLevel niveau, string catégorie) { /* Avec catégorie */ }
}

// MAUVAIS : Trop de surcharges avec des différences subtiles
public class MauvaisePratique
{
    public void Enregistrer(string message) { }
    public void Enregistrer(string message, LogLevel niveau) { }
    public void Enregistrer(string message, string catégorie) { }
    public void Enregistrer(LogLevel niveau, string message) { }
    public void Enregistrer(string message, bool inclureHorodatage) { }
    public void Enregistrer(string message, LogLevel niveau, string catégorie) { }
    public void Enregistrer(string message, string catégorie, LogLevel niveau) { } // Ordre différent!
    // ... etc.
}
```


### 3. Préférer les paramètres optionnels pour les cas simples

Les paramètres optionnels peuvent souvent remplacer plusieurs surcharges et rendre le code plus maintenable.

```textmate
// BIEN : Utilisation de paramètres optionnels
public class AvecParamètresOptionnels
{
    public void Configurer(string nom, int priorité = 0, bool estActif = true)
    {
        // Implémentation
    }
}

// ÉQUIVALENT AVEC SURCHARGES (plus verbeux)
public class AvecSurcharges
{
    public void Configurer(string nom)
    {
        Configurer(nom, 0, true);
    }

    public void Configurer(string nom, int priorité)
    {
        Configurer(nom, priorité, true);
    }

    public void Configurer(string nom, int priorité, bool estActif)
    {
        // Implémentation
    }
}
```


### 4. Éviter les surcharges qui diffèrent uniquement par des types numériques

Les conversions implicites entre types numériques peuvent créer des ambiguïtés ou des comportements inattendus.

```textmate
// PROBLÉMATIQUE : Surcharges avec différents types numériques
public class TypesNumériques
{
    public void Traiter(int valeur) { Console.WriteLine("int"); }
    public void Traiter(long valeur) { Console.WriteLine("long"); }
    public void Traiter(float valeur) { Console.WriteLine("float"); }

    public void Test()
    {
        int i = 5;
        Traiter(i);      // OK: Appelle Traiter(int)

        var x = 5;       // Type inféré: int
        Traiter(x);      // OK: Appelle Traiter(int)

        Traiter(5);      // OK: Appelle Traiter(int)
        Traiter(5L);     // OK: Appelle Traiter(long)
        Traiter(5.0f);   // OK: Appelle Traiter(float)

        // Mais attention aux cas ambigus avec des expressions plus complexes
    }
}
```


### 5. Documenter clairement les différences entre surcharges

Une bonne documentation aide les utilisateurs à comprendre quelle surcharge utiliser selon leurs besoins.

```textmate
/// <summary>
/// Charge les données depuis une source.
/// </summary>
/// <param name="chemin">Chemin du fichier à charger.</param>
/// <returns>Les données chargées.</returns>
public Data Charger(string chemin)
{
    // Implémentation
}

/// <summary>
/// Charge les données depuis une source avec des options spécifiques.
/// </summary>
/// <param name="chemin">Chemin du fichier à charger.</param>
/// <param name="options">Options de chargement personnalisées.</param>
/// <returns>Les données chargées selon les options spécifiées.</returns>
public Data Charger(string chemin, LoadOptions options)
{
    // Implémentation
}
```


### 6. Utiliser des noms descriptifs plutôt que des surcharges dans certains cas

Parfois, des méthodes distinctes avec des noms plus explicites sont préférables à des surcharges.

```textmate
// BIEN : Noms spécifiques pour des comportements différents
public class BonneClartéAPI
{
    public Customer TrouverClientParId(int id) { /* ... */ }
    public Customer TrouverClientParEmail(string email) { /* ... */ }
    public List<Customer> RechercherClientsParNom(string nomPartiel) { /* ... */ }
}

// MOINS CLAIR : Utilisation de surcharges pour des comportements différents
public class MoinsClaire
{
    public Customer TrouverClient(int id) { /* ... */ }
    public Customer TrouverClient(string email) { /* ... */ }
    public List<Customer> TrouverClient(string nomPartiel, bool recherchePartielle) { /* ... */ }
}
```


### 7. Attention aux méthodes qui acceptent null

Les surcharges qui diffèrent par des types référence peuvent causer des confusions avec la valeur null.

```textmate
public class GestionNull
{
    public void Traiter(string texte)
    {
        Console.WriteLine("Traiter(string)");
    }

    public void Traiter(object obj)
    {
        Console.WriteLine("Traiter(object)");
    }

    public void Test()
    {
        Traiter("texte");    // Appelle Traiter(string)
        Traiter(new object()); // Appelle Traiter(object)
        Traiter(null);       // Ambigu? En réalité, appelle Traiter(string) car c'est plus spécifique

        // Pour forcer l'appel à Traiter(object) avec null
        Traiter((object)null);
    }
}
```


### 8. Cohérence entre les versions .NET Framework 4.7.2 et .NET 8

Lorsque vous travaillez avec les deux versions du framework, assurez-vous que vos surcharges se comportent de manière cohérente.

```textmate
public class CompatibilitéVersions
{
    // Fonctionnalité de base compatible avec les deux versions
    public void Traiter(string donnée) { /* Implémentation de base */ }

    // Surcharge utilisant des fonctionnalités plus récentes
    public void Traiter(string donnée, CancellationToken token)
    {
        #if NETCOREAPP || NET5_0_OR_GREATER
        // Code spécifique à .NET Core/.NET 5+
        #else
        // Code pour .NET Framework
        #endif
    }
}
```


### 9. Considérations pour les APIs publiques

Pour les APIs destinées à être utilisées par d'autres développeurs, quelques principes supplémentaires s'appliquent :

- **Stabilité** : Une fois publiées, les surcharges ne devraient pas être modifiées de manière incompatible
- **Extensibilité** : Considérez comment les futures surcharges pourraient être ajoutées sans créer d'ambiguïtés
- **Testabilité** : Assurez-vous que chaque surcharge est testable indépendamment

```textmate
// API publique bien conçue
public class BonneAPIPublique
{
    // Version 1.0 - API initiale
    public Task<Result> TraiterAsync(RequestData request)
    {
        // Implémentation par défaut
        return TraiterAsync(request, CancellationToken.None);
    }

    // Version 1.0 - Surcharge principale avec toutes les options
    public Task<Result> TraiterAsync(RequestData request, CancellationToken cancellationToken)
    {
        // Implémentation complète
    }

    // Version 2.0 - Nouvelle surcharge avec options supplémentaires
    // Ajout sans casser les appels existants
    public Task<Result> TraiterAsync(RequestData request, ProcessingOptions options, CancellationToken cancellationToken = default)
    {
        // Nouvelle implémentation
    }
}
```


## Résumé

La surcharge de méthodes est une fonctionnalité puissante qui améliore la lisibilité et l'ergonomie des APIs C#, tant en .NET Framework 4.7.2 qu'en .NET 8. Les principes clés à retenir sont :

1. Les surcharges doivent partager le même nom mais avoir des signatures différentes.
2. Le compilateur sélectionne la surcharge la plus appropriée selon des règles de résolution complexes.
3. Les bonnes pratiques incluent la cohérence sémantique, la limitation du nombre de surcharges, et la documentation claire.
4. Dans certains cas, les paramètres optionnels ou des noms de méthodes distincts sont préférables aux surcharges.

En suivant ces principes, vous créerez des APIs intuitives, maintenables et correctement utilisées par d'autres développeurs, quelle que soit la version de .NET utilisée.
