# 4.5. Méthodes d'extension

Les méthodes d'extension sont une fonctionnalité puissante de C# qui permet d'ajouter des méthodes à des types existants sans modifier leur code source ni créer de types dérivés. Introduites dans C# 3.0, elles sont disponibles à la fois dans .NET Framework 4.7.2 et .NET 8. Cette section explore comment créer et utiliser des méthodes d'extension, comment elles sont utilisées dans LINQ, et présente les bonnes pratiques à suivre.

## 4.5.1. Création et utilisation

### Syntaxe de base

Pour créer une méthode d'extension, vous devez suivre ces règles :

1. Définir la méthode dans une classe statique non générique
2. Déclarer la méthode comme statique
3. Utiliser le mot-clé `this` devant le premier paramètre pour indiquer le type étendu
4. Le premier paramètre représente l'instance sur laquelle la méthode sera appelée

```textmate
// Classe statique contenant des méthodes d'extension
public static class StringExtensions
{
    // Méthode d'extension pour le type string
    public static bool EstPalindrome(this string texte)
    {
        if (string.IsNullOrEmpty(texte))
            return false;

        string texteNormalisé = texte.ToLower().Replace(" ", "");
        char[] caractères = texteNormalisé.ToCharArray();
        Array.Reverse(caractères);
        string inverse = new string(caractères);

        return texteNormalisé == inverse;
    }

    // Autre méthode d'extension pour string, avec paramètres supplémentaires
    public static string TronquerAvecSuffixe(this string texte, int longueurMax, string suffixe = "...")
    {
        if (string.IsNullOrEmpty(texte) || texte.Length <= longueurMax)
            return texte;

        return texte.Substring(0, longueurMax) + suffixe;
    }
}
```


### Utilisation des méthodes d'extension

Une fois définies, les méthodes d'extension peuvent être utilisées comme si elles étaient des méthodes d'instance du type étendu :

```textmate
// Assurez-vous d'importer l'espace de noms contenant les extensions
using MonProjet.Extensions;

// Utilisation des méthodes d'extension
string phrase = "Engage le jeu que je le gagne";
bool estPalindrome = phrase.EstPalindrome(); // true

string description = "Ceci est une longue description qui sera tronquée";
string résumé = description.TronquerAvecSuffixe(20); // "Ceci est une longue..."
string aperçu = description.TronquerAvecSuffixe(15, " [suite]"); // "Ceci est une [suite]"
```


### Extension des types intégrés

L'un des avantages majeurs des méthodes d'extension est la possibilité d'ajouter des fonctionnalités aux types intégrés de .NET :

```textmate
public static class IntExtensions
{
    // Extension pour vérifier si un entier est pair
    public static bool EstPair(this int nombre)
    {
        return nombre % 2 == 0;
    }

    // Extension pour vérifier si un entier est premier
    public static bool EstPremier(this int nombre)
    {
        if (nombre <= 1) return false;
        if (nombre <= 3) return true;
        if (nombre % 2 == 0 || nombre % 3 == 0) return false;

        for (int i = 5; i * i <= nombre; i += 6)
        {
            if (nombre % i == 0 || nombre % (i + 2) == 0)
                return false;
        }

        return true;
    }
}

// Utilisation
int nombre = 17;
Console.WriteLine($"{nombre} est pair : {nombre.EstPair()}");
Console.WriteLine($"{nombre} est premier : {nombre.EstPremier()}");
```


### Extension des types génériques

Les méthodes d'extension peuvent également cibler des types génériques :

```textmate
public static class EnumerableExtensions
{
    // Extension pour calculer la moyenne d'une séquence de nombres
    public static double MoyenneSécurisée<T>(this IEnumerable<T> source, Func<T, double> sélecteur)
    {
        if (source == null)
            throw new ArgumentNullException(nameof(source));

        if (sélecteur == null)
            throw new ArgumentNullException(nameof(sélecteur));

        int count = 0;
        double sum = 0;

        foreach (var item in source)
        {
            sum += sélecteur(item);
            count++;
        }

        return count > 0 ? sum / count : 0;
    }

    // Extension pour obtenir des éléments aléatoires d'une collection
    public static IEnumerable<T> ÉlémentsPrisAuHasard<T>(this IEnumerable<T> source, int nombre)
    {
        if (source == null)
            throw new ArgumentNullException(nameof(source));

        var éléments = source.ToList();
        if (éléments.Count == 0)
            return Enumerable.Empty<T>();

        var aléatoire = new Random();
        int àPrendre = Math.Min(nombre, éléments.Count);

        return éléments
            .OrderBy(x => aléatoire.Next())
            .Take(àPrendre);
    }
}

// Utilisation
var nombres = new List<int> { 1, 2, 3, 4, 5 };
double moyenne = nombres.MoyenneSécurisée(n => n); // 3.0

var fruits = new[] { "pomme", "banane", "orange", "fraise", "kiwi", "ananas" };
var sélection = fruits.ÉlémentsPrisAuHasard(3); // 3 fruits aléatoires
```


### Extension des interfaces

Les méthodes d'extension peuvent être appliquées aux interfaces, ce qui permet d'ajouter des fonctionnalités à toutes les implémentations :

```textmate
public static class DisposableExtensions
{
    // Extension pour exécuter une action et garantir la libération des ressources
    public static void UtiliserEtLibérer<T>(this T ressource, Action<T> action) where T : IDisposable
    {
        if (ressource == null)
            throw new ArgumentNullException(nameof(ressource));

        try
        {
            action(ressource);
        }
        finally
        {
            ressource.Dispose();
        }
    }
}

// Utilisation
var fichier = new StreamWriter("test.txt");
fichier.UtiliserEtLibérer(f => {
    f.WriteLine("Ligne 1");
    f.WriteLine("Ligne 2");
});
// Le fichier est automatiquement fermé après utilisation
```


### Extension des types avec contraintes génériques

Les méthodes d'extension peuvent utiliser des contraintes génériques pour cibler des types spécifiques :

```textmate
public static class ComparableExtensions
{
    // Extension pour limiter une valeur entre min et max
    public static T Limiter<T>(this T valeur, T min, T max) where T : IComparable<T>
    {
        if (valeur.CompareTo(min) < 0)
            return min;

        if (valeur.CompareTo(max) > 0)
            return max;

        return valeur;
    }
}

// Utilisation
int température = 37.Limiter(-20, 50); // 37 reste inchangé
int horsLimite = 100.Limiter(0, 50);   // ramené à 50
```


## 4.5.2. LINQ comme exemple de méthodes d'extension

LINQ (Language Integrated Query) est l'un des exemples les plus puissants et les plus connus d'utilisation des méthodes d'extension en C#. Ces méthodes étendent l'interface `IEnumerable<T>` pour fournir des capacités de requête puissantes.

### Les méthodes d'extension LINQ essentielles

```textmate
// Exemples de méthodes LINQ courantes
var nombres = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Where - filtrage
var nombresPairs = nombres.Where(n => n % 2 == 0);
// Résultat : [2, 4, 6, 8, 10]

// Select - projection/transformation
var carrés = nombres.Select(n => n * n);
// Résultat : [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

// OrderBy - tri
var triés = nombres.OrderByDescending(n => n);
// Résultat : [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

// Take - limiter le nombre d'éléments
var premiers = nombres.Take(3);
// Résultat : [1, 2, 3]

// Skip - ignorer des éléments
var saufPremiers = nombres.Skip(7);
// Résultat : [8, 9, 10]

// Agrégation
int somme = nombres.Sum();                    // 55
double moyenne = nombres.Average();           // 5.5
int maximum = nombres.Max();                  // 10
int minimum = nombres.Min();                  // 1
int comptage = nombres.Count();               // 10
bool tousSupÀZéro = nombres.All(n => n > 0);  // true
bool auMoinsUnPair = nombres.Any(n => n % 2 == 0); // true
```


### Chaînage de méthodes LINQ

L'un des avantages majeurs des méthodes d'extension LINQ est la possibilité de les chaîner pour créer des requêtes complexes :

```textmate
// Exemple de requête LINQ complexe
var produits = ObtenirProduits(); // Imaginons une liste de produits

var résultat = produits
    .Where(p => p.Catégorie == "Électronique")    // Filtrer par catégorie
    .Where(p => p.Prix > 100)                    // Filtrer par prix
    .OrderBy(p => p.Prix)                        // Trier par prix croissant
    .Select(p => new {                           // Projection vers un nouveau type
        Nom = p.Nom,
        PrixTTC = p.Prix * 1.2,
        Disponible = p.Stock > 0
    })
    .Take(5);                                    // Limiter aux 5 premiers résultats
```


### Implémentation de vos propres extensions LINQ

Vous pouvez créer vos propres méthodes d'extension similaires à LINQ :

```textmate
public static class EnumerableExtensionsAvancées
{
    // Extension pour répartir les éléments en groupes de taille égale
    public static IEnumerable<IEnumerable<T>> ParGroupes<T>(this IEnumerable<T> source, int tailleGroupe)
    {
        if (source == null)
            throw new ArgumentNullException(nameof(source));

        if (tailleGroupe <= 0)
            throw new ArgumentException("La taille du groupe doit être positive", nameof(tailleGroupe));

        var énumérateur = source.GetEnumerator();
        while (énumérateur.MoveNext())
        {
            var groupe = new List<T> { énumérateur.Current };

            for (int i = 1; i < tailleGroupe && énumérateur.MoveNext(); i++)
            {
                groupe.Add(énumérateur.Current);
            }

            yield return groupe;
        }
    }

    // Extension pour calculer la médiane d'une séquence de nombres
    public static double Médiane<T>(this IEnumerable<T> source, Func<T, double> sélecteur)
    {
        if (source == null)
            throw new ArgumentNullException(nameof(source));

        var valeurs = source.Select(sélecteur).OrderBy(v => v).ToList();

        if (valeurs.Count == 0)
            throw new InvalidOperationException("La séquence ne contient aucun élément");

        int milieu = valeurs.Count / 2;

        if (valeurs.Count % 2 == 0)
            return (valeurs[milieu - 1] + valeurs[milieu]) / 2;
        else
            return valeurs[milieu];
    }
}

// Utilisation
var nombres = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Répartir en groupes de 3
var groupes = nombres.ParGroupes(3);
// Résultat : [[1,2,3], [4,5,6], [7,8,9], [10]]

// Calculer la médiane
double médiane = nombres.Médiane(n => n); // 5.5

// Combiner avec des méthodes LINQ standard
var médianePaires = nombres
    .Where(n => n % 2 == 0)
    .Médiane(n => n); // 6.0
```


### Méthodes d'extension asynchrones (Disponibles dans .NET Standard 2.0, .NET Core et .NET 8)

Dans .NET moderne, vous pouvez créer des méthodes d'extension asynchrones :

```textmate
public static class HttpClientExtensions
{
    public static async Task<T> GetJsonAsync<T>(this HttpClient client, string url)
    {
        var response = await client.GetAsync(url);
        response.EnsureSuccessStatusCode();

        var json = await response.Content.ReadAsStringAsync();
        return System.Text.Json.JsonSerializer.Deserialize<T>(json);
    }
}

// Utilisation (.NET 8)
var client = new HttpClient();
var utilisateurs = await client.GetJsonAsync<List<Utilisateur>>("https://api.exemple.com/utilisateurs");

// En .NET Framework 4.7.2, vous devriez utiliser Newtonsoft.Json à la place de System.Text.Json
```


## 4.5.3. Bonnes pratiques et pièges courants

Les méthodes d'extension sont un outil puissant, mais comme toute fonctionnalité avancée, elles doivent être utilisées judicieusement. Voici les bonnes pratiques à suivre et les pièges à éviter lors de leur utilisation.

### Bonnes pratiques

#### 1. Organiser les extensions par type étendu

Regroupez vos méthodes d'extension en classes selon le type qu'elles étendent :

```textmate
// Extensions pour les chaînes de caractères
public static class StringExtensions { /* ... */ }

// Extensions pour les collections
public static class CollectionExtensions { /* ... */ }

// Extensions pour les dates
public static class DateTimeExtensions { /* ... */ }
```


#### 2. Nommer les classes de manière cohérente

Suivez une convention de nommage cohérente pour vos classes d'extensions :

```textmate
// Modèle recommandé : [TypeName]Extensions
public static class StringExtensions { /* ... */ }
public static class EnumerableExtensions { /* ... */ }
public static class ExceptionExtensions { /* ... */ }
```


#### 3. Utiliser des espaces de noms appropriés

Placez vos extensions dans des espaces de noms qui reflètent leur finalité, pas forcément celui du type étendu :

```textmate
// Extensions génériques utilitaires
namespace MonApplication.Extensions { /* ... */ }

// Extensions spécifiques au domaine
namespace MonApplication.Domaine.Extensions { /* ... */ }

// Extensions pour une fonctionnalité particulière
namespace MonApplication.Reporting.Extensions { /* ... */ }
```


#### 4. Documenter clairement vos extensions

Documentez vos méthodes d'extension comme vous le feriez pour toute autre API publique :

```textmate
/// <summary>
/// Tronque une chaîne à la longueur spécifiée et ajoute un suffixe si nécessaire.
/// </summary>
/// <param name="texte">La chaîne à tronquer. Si null, null est retourné.</param>
/// <param name="longueurMax">Longueur maximale avant troncature.</param>
/// <param name="suffixe">Suffixe à ajouter en cas de troncature. Par défaut "..."</param>
/// <returns>La chaîne tronquée ou la chaîne originale si assez courte.</returns>
public static string Tronquer(this string texte, int longueurMax, string suffixe = "...")
{
    // Implémentation
}
```


#### 5. Préférer l'immutabilité

Pour les types immuables comme string, vos méthodes d'extension devraient retourner de nouvelles instances plutôt que de modifier l'existant :

```textmate
// Bon: Retourne une nouvelle chaîne
public static string SansAccents(this string texte)
{
    if (string.IsNullOrEmpty(texte))
        return texte;

    // Retourne une nouvelle chaîne sans les accents
    return new string(texte
        .Normalize(NormalizationForm.FormD)
        .Where(c => CharUnicodeInfo.GetUnicodeCategory(c) != UnicodeCategory.NonSpacingMark)
        .ToArray());
}

// Mauvais: Ne pas modifier les collections passées en paramètre
public static void AjouterSiAbsent<T>(this List<T> liste, T élément)
{
    if (!liste.Contains(élément))
        liste.Add(élément);
}
```


#### 6. Gérer les valeurs null de façon cohérente

Décidez d'une stratégie cohérente pour gérer les valeurs null et documentez-la :

```textmate
// Option 1: Retourner null si l'entrée est null
public static string InverserTexte(this string texte)
{
    if (texte == null)
        return null;

    char[] caractères = texte.ToCharArray();
    Array.Reverse(caractères);
    return new string(caractères);
}

// Option 2: Lancer une exception si l'entrée est null
public static string EnMajuscules(this string texte)
{
    if (texte == null)
        throw new ArgumentNullException(nameof(texte));

    return texte.ToUpper();
}

// Option 3: Définir un comportement par défaut pour null
public static int CompterMots(this string texte)
{
    if (string.IsNullOrWhiteSpace(texte))
        return 0;

    return texte.Split(new[] { ' ', '\t', '\n' }, StringSplitOptions.RemoveEmptyEntries).Length;
}
```


#### 7. Éviter la surcharge cognitive

N'abusez pas des méthodes d'extension. Trop d'extensions peuvent rendre l'API difficile à comprendre :

```textmate
// Bien: Extensions bien nommées et cohérentes
public static class DateTimeExtensions
{
    public static bool EstJourOuvré(this DateTime date) { /* ... */ }
    public static DateTime PremierJourDuMois(this DateTime date) { /* ... */ }
    public static DateTime DernierJourDuMois(this DateTime date) { /* ... */ }
    public static int ÂgeEnAnnées(this DateTime dateNaissance) { /* ... */ }
}

// Mauvais: Trop d'extensions non cohérentes
public static class DateTimeExtensionsTropNombreuses
{
    public static string FormatYYYYMMDD(this DateTime date) { /* ... */ }
    public static double ToUnixTimestamp(this DateTime date) { /* ... */ }
    public static DateTime AddWorkdays(this DateTime date, int days) { /* ... */ }
    public static string GetMonthName(this DateTime date) { /* ... */ }
    public static string ToIso8601(this DateTime date) { /* ... */ }
    public static DateTime FromIso8601(this string iso8601) { /* ... */ } // Mélange des responsabilités
    // ... et beaucoup d'autres
}
```


#### 8. Extension de types concrets vs interfaces

Préférez étendre des interfaces plutôt que des implémentations concrètes lorsque cela a du sens :

```textmate
// Préférable : étendre l'interface
public static class EnumerableExtensions
{
    public static bool EstVide<T>(this IEnumerable<T> source)
    {
        return !source.Any();
    }
}

// Moins flexible : étendre le type concret
public static class ListExtensions
{
    public static bool EstVide<T>(this List<T> liste)
    {
        return liste.Count == 0;
    }
}
```


#### 9. Utiliser les extensions pour des opérations transversales

Les méthodes d'extension sont idéales pour les préoccupations transversales comme la journalisation, la validation ou la conversion :

```textmate
public static class LoggingExtensions
{
    public static T LogDebug<T>(this T obj, string message, ILogger logger)
    {
        logger.LogDebug(message, obj);
        return obj; // Retourne l'objet pour permettre le chaînage
    }
}

// Utilisation
var utilisateur = GetUserById(123)
    .LogDebug("Utilisateur récupéré", _logger);
```


### Pièges courants

#### 1. Ne pas confondre avec les méthodes d'instance existantes

Évitez de créer des méthodes d'extension dont le nom entre en conflit avec des méthodes d'instance existantes :

```textmate
// Problématique: Le type String a déjà une méthode ToUpper()
public static class StringExtensions
{
    // Évitez ceci - crée de la confusion
    public static string ToUpper(this string texte)
    {
        // ...
    }

    // Préférez un nom spécifique
    public static string EnMajusculesAvecOptions(this string texte, bool préserverAccents)
    {
        // ...
    }
}
```


#### 2. Les méthodes d'extension ne peuvent pas accéder aux membres privés

Les méthodes d'extension n'ont accès qu'aux membres publics du type étendu :

```textmate
public class MaClasse
{
    private int donnéePrivée;
    public int DonnéePublique { get; set; }
}

public static class MaClasseExtensions
{
    public static void Exemple(this MaClasse instance)
    {
        // Fonctionne
        int valeur = instance.DonnéePublique;

        // Ne compile pas - ne peut pas accéder au membre privé
        // int valeurPrivée = instance.donnéePrivée;
    }
}
```


#### 3. Les méthodes d'extension sont résolues statiquement

Les méthodes d'extension sont résolues à la compilation, pas à l'exécution, ce qui limite le polymorphisme :

```textmate
public class Animal { }
public class Chien : Animal { }

public static class AnimalExtensions
{
    public static string Décrire(this Animal animal)
    {
        return "Un animal";
    }
}

public static class ChienExtensions
{
    public static string Décrire(this Chien chien)
    {
        return "Un chien";
    }
}

// Utilisation
Chien rex = new Chien();
Animal animal = rex;

Console.WriteLine(rex.Décrire());    // "Un chien"
Console.WriteLine(animal.Décrire()); // "Un animal", pas "Un chien"
```


#### 4. Les méthodes d'extension n'apparaissent que si leur namespace est importé

Les méthodes d'extension ne sont disponibles que si vous importez leur espace de noms :

```textmate
// Dans un fichier MyExtensions.cs
namespace MonApplication.Extensions
{
    public static class StringExtensions
    {
        public static bool EstPalindrome(this string texte)
        {
            // Implémentation
        }
    }
}

// Dans un autre fichier
using System;
// Les extensions ne sont pas disponibles sans cette ligne
// using MonApplication.Extensions;

public class Program
{
    public static void Main()
    {
        string mot = "radar";

        // Ne compile pas sans l'import du namespace
        // bool estPalindrome = mot.EstPalindrome();

        // Fonctionne toujours avec la syntaxe de méthode statique
        bool estPalindrome = MonApplication.Extensions.StringExtensions.EstPalindrome(mot);
    }
}
```


#### 5. Éviter les effets de bord

Les méthodes d'extension ne devraient généralement pas modifier l'état de leurs paramètres :

```textmate
// À éviter: Modifier l'état de l'instance
public static class ListExtensions
{
    public static void AjouterPlusieursÉléments<T>(this List<T> liste, params T[] éléments)
    {
        // Modifie la liste d'origine (effet de bord)
        foreach (var élément in éléments)
        {
            liste.Add(élément);
        }
    }
}

// Préférable: Retourner une nouvelle collection
public static class EnumerableExtensions
{
    public static IEnumerable<T> Concat<T>(this IEnumerable<T> source, params T[] éléments)
    {
        // Retourne une nouvelle séquence sans modifier l'originale
        foreach (var item in source)
            yield return item;

        foreach (var élément in éléments)
            yield return élément;
    }
}
```


#### 6. Considérations de performance

Certaines implémentations naïves de méthodes d'extension peuvent entraîner des problèmes de performance :

```textmate
// Problématique : Énumère la collection deux fois
public static class EnumerableExtensionsInefficace
{
    public static double MoyenneOuDefaut<T>(this IEnumerable<T> source, Func<T, double> sélecteur)
    {
        // Inefficace : énumère la collection pour Count(), puis à nouveau pour Sum()
        if (source.Count() == 0)
            return 0;

        return source.Sum(sélecteur) / source.Count();
    }
}

// Efficace : Énumère la collection une seule fois
public static class EnumerableExtensionsEfficace
{
    public static double MoyenneOuDefaut<T>(this IEnumerable<T> source, Func<T, double> sélecteur)
    {
        int count = 0;
        double sum = 0;

        foreach (var item in source)
        {
            sum += sélecteur(item);
            count++;
        }

        return count > 0 ? sum / count : 0;
    }
}
```


#### 7. Difficulté de test

Les méthodes d'extension peuvent être plus difficiles à tester que les méthodes d'instance normales :

```textmate
// Difficile à mocker pour les tests
public static class HttpClientExtensions
{
    public static async Task<T> GetAndDeserialize<T>(this HttpClient client, string url)
    {
        var response = await client.GetAsync(url);
        response.EnsureSuccessStatusCode();
        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<T>(json);
    }
}

// Plus facile à tester avec injection de dépendances
public class HttpService
{
    private readonly HttpClient _client;

    public HttpService(HttpClient client)
    {
        _client = client;
    }

    public async Task<T> GetAndDeserialize<T>(string url)
    {
        var response = await _client.GetAsync(url);
        response.EnsureSuccessStatusCode();
        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<T>(json);
    }
}
```


#### 8. Confusion avec l'héritage et le polymorphisme

N'utilisez pas les méthodes d'extension comme substitut à une bonne conception orientée objet :

```textmate
// Mauvais : utiliser des extensions pour simuler le polymorphisme
public class Document { }
public class TextDocument : Document { }
public class SpreadsheetDocument : Document { }

public static class DocumentExtensions
{
    public static void Print(this Document doc)
    {
        if (doc is TextDocument)
            Console.WriteLine("Printing text document");
        else if (doc is SpreadsheetDocument)
            Console.WriteLine("Printing spreadsheet");
        else
            Console.WriteLine("Printing generic document");
    }
}

// Bon : utiliser le polymorphisme classique
public abstract class Document
{
    public abstract void Print();
}

public class TextDocument : Document
{
    public override void Print()
    {
        Console.WriteLine("Printing text document");
    }
}

public class SpreadsheetDocument : Document
{
    public override void Print()
    {
        Console.WriteLine("Printing spreadsheet");
    }
}
```


### Différences entre .NET Framework 4.7.2 et .NET 8

Les méthodes d'extension fonctionnent de manière très similaire dans .NET Framework 4.7.2 et .NET 8. Cependant, certaines différences méritent d'être soulignées :

#### 1. Extensions pour les types récents

.NET 8 introduit de nouveaux types qui n'existent pas dans .NET Framework 4.7.2, comme `Span<T>`, `Memory<T>`, et vous pouvez créer des extensions pour ces types :

```textmate
// Extension disponible uniquement dans .NET Core / .NET 8
public static class SpanExtensions
{
    public static bool CommenceParChiffre(this ReadOnlySpan<char> span)
    {
        return span.Length > 0 && char.IsDigit(span[0]);
    }
}

// Utilisation (.NET 8)
string texte = "123abc";
bool commenceParChiffre = texte.AsSpan().CommenceParChiffre();
```


#### 2. Performances améliorées

Dans .NET 8, certaines optimisations de performance rendent les méthodes d'extension plus efficaces, notamment pour les structures et les types de référence par valeur (`ref struct`).

#### 3. Extensions async améliorées

.NET 8 offre un meilleur support pour les motifs asynchrones, notamment avec `IAsyncEnumerable<T>` :

```textmate
// Disponible dans .NET Core 3.0+ et .NET 8, pas dans .NET Framework 4.7.2
public static class AsyncEnumerableExtensions
{
    public static async Task<List<T>> ToListAsync<T>(this IAsyncEnumerable<T> source)
    {
        var result = new List<T>();
        await foreach (var item in source)
        {
            result.Add(item);
        }
        return result;
    }
}

// Utilisation (.NET 8)
public async IAsyncEnumerable<int> GénérerNombresAsync()
{
    for (int i = 0; i < 10; i++)
    {
        await Task.Delay(100); // Simulation de travail asynchrone
        yield return i;
    }
}

// Appelant
var nombres = await GénérerNombresAsync().ToListAsync();
```


Les méthodes d'extension constituent l'une des fonctionnalités les plus élégantes et puissantes de C#. Elles permettent d'étendre les types existants sans les modifier, offrant ainsi une flexibilité remarquable dans la conception d'API fluides et expressives.

Comme nous l'avons vu, les méthodes d'extension excellent dans plusieurs scénarios :

1. **Extension de types existants** : Elles permettent d'ajouter des fonctionnalités aux types sur lesquels vous n'avez pas de contrôle, y compris les types primitifs et ceux du framework .NET.

2. **Création d'API fluides** : Les méthodes d'extension favorisent la création d'API chaînables qui améliorent la lisibilité et l'expressivité du code, comme le démontre parfaitement LINQ.

3. **Organisation du code** : Elles facilitent la séparation des préoccupations en permettant de regrouper des fonctionnalités connexes dans des classes statiques dédiées.

4. **Réutilisation du code** : Elles encouragent le partage de fonctionnalités communes entre différents projets via des bibliothèques d'extensions.

Cependant, pour tirer le meilleur parti des méthodes d'extension, il est essentiel de suivre les bonnes pratiques :

- Organiser les extensions de manière logique par type étendu
- Utiliser une nomenclature claire et cohérente
- Préférer l'immutabilité quand c'est approprié
- Gérer correctement les valeurs null
- Éviter d'en abuser au point de créer de la confusion

Les méthodes d'extension sont disponibles à la fois dans .NET Framework 4.7.2 et .NET 8, avec des améliorations notables dans ce dernier, notamment pour les types de haute performance et les opérations asynchrones.

En conclusion, les méthodes d'extension sont bien plus qu'une simple fonctionnalité syntaxique — elles représentent un paradigme de conception puissant qui, lorsqu'il est utilisé judicieusement, peut considérablement améliorer la qualité et la maintenabilité de votre code. Que vous travailliez avec des API existantes ou que vous conceviez vos propres bibliothèques, les méthodes d'extension méritent une place de choix dans votre boîte à outils de développement C#.
