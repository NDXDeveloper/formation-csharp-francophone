# 19.2. Patterns structurels en C#

Les **patterns structurels** sont des mod√®les de conception qui s'occupent de la mani√®re dont les objets et les classes sont compos√©s pour former des structures plus larges. Ils facilitent la cr√©ation de structures complexes en simplifiant les relations entre objets.

## Qu'est-ce qu'un Pattern Structurel ?

Les patterns structurels vous aident √† :
- **Assembler des objets et des classes** en structures plus grandes
- **Simplifier les interfaces complexes**
- **G√©rer les relations entre objets** de mani√®re flexible
- **Adapter des interfaces incompatibles**

## 19.2.1. Adapter - "Le traducteur"

### Qu'est-ce que l'Adapter ?

L'Adapter permet √† **deux interfaces incompatibles de travailler ensemble**. C'est comme un adaptateur √©lectrique qui vous permet d'utiliser un appareil fran√ßais aux √âtats-Unis.

### Quand l'utiliser ?

- Quand vous devez utiliser une classe existante avec une interface incompatible
- Pour int√©grer des biblioth√®ques tierces
- Pour faire √©voluer votre code sans casser l'existant

### Exemple simple : Adaptateur de m√©dias

```csharp
// Interface cible que notre code attend
public interface IMediaPlayer
{
    void Play(string filename);
}

// Classe existante avec une interface diff√©rente
public class AdvancedMediaPlayer
{
    public void PlayVlc(string filename)
    {
        Console.WriteLine($"Lecture VLC: {filename}");
    }

    public void PlayMp4(string filename)
    {
        Console.WriteLine($"Lecture MP4: {filename}");
    }
}

// Adapter qui fait le pont entre les deux interfaces
public class MediaAdapter : IMediaPlayer
{
    private AdvancedMediaPlayer advancedPlayer;

    public MediaAdapter(string fileType)
    {
        advancedPlayer = new AdvancedMediaPlayer();
    }

    public void Play(string filename)
    {
        string extension = Path.GetExtension(filename).ToLower();

        switch (extension)
        {
            case ".vlc":
                advancedPlayer.PlayVlc(filename);
                break;
            case ".mp4":
                advancedPlayer.PlayMp4(filename);
                break;
            default:
                Console.WriteLine($"Format {extension} non support√©");
                break;
        }
    }
}

// Player principal qui utilise l'adaptateur
public class AudioPlayer : IMediaPlayer
{
    private MediaAdapter mediaAdapter;

    public void Play(string filename)
    {
        string extension = Path.GetExtension(filename).ToLower();

        if (extension == ".mp3")
        {
            Console.WriteLine($"Lecture MP3: {filename}");
        }
        else
        {
            // Utiliser l'adaptateur pour les autres formats
            mediaAdapter = new MediaAdapter(extension);
            mediaAdapter.Play(filename);
        }
    }
}

// Utilisation
var player = new AudioPlayer();
player.Play("music.mp3");        // Lecture MP3: music.mp3
player.Play("movie.mp4");        // Lecture MP4: movie.mp4
player.Play("video.vlc");        // Lecture VLC: video.vlc
```

### Exemple avec int√©gration de biblioth√®que tierce

```csharp
// Interface de notre syst√®me
public interface ILogger
{
    void LogError(string message);
    void LogInfo(string message);
}

// Biblioth√®que tierce avec une interface diff√©rente
public class ThirdPartyLogger
{
    public void WriteError(string msg, DateTime timestamp)
    {
        Console.WriteLine($"[ERROR {timestamp}] {msg}");
    }

    public void WriteInformation(string msg, DateTime timestamp)
    {
        Console.WriteLine($"[INFO {timestamp}] {msg}");
    }
}

// Adapter pour int√©grer la biblioth√®que tierce
public class ThirdPartyLoggerAdapter : ILogger
{
    private ThirdPartyLogger thirdPartyLogger;

    public ThirdPartyLoggerAdapter()
    {
        thirdPartyLogger = new ThirdPartyLogger();
    }

    public void LogError(string message)
    {
        thirdPartyLogger.WriteError(message, DateTime.Now);
    }

    public void LogInfo(string message)
    {
        thirdPartyLogger.WriteInformation(message, DateTime.Now);
    }
}

// Utilisation
ILogger logger = new ThirdPartyLoggerAdapter();
logger.LogInfo("Application d√©marr√©e");
logger.LogError("Une erreur est survenue");
```

## 19.2.2. Bridge - "S√©parer l'abstraction de l'impl√©mentation"

### Qu'est-ce que le Bridge ?

Le Bridge **s√©pare une abstraction de son impl√©mentation**, permettant aux deux de varier ind√©pendamment.

### Quand l'utiliser ?

- Quand vous voulez √©viter une explosion combinatoire de classes
- Pour pouvoir changer l'impl√©mentation sans affecter le client
- Quand l'abstraction et l'impl√©mentation doivent √©voluer s√©par√©ment

### Exemple simple : Formes et couleurs

```csharp
// Interface implementation (ce qui est "sous" le pont)
public interface IColor
{
    string GetColor();
}

// Impl√©mentations concr√®tes
public class RedColor : IColor
{
    public string GetColor()
    {
        return "Rouge";
    }
}

public class BlueColor : IColor
{
    public string GetColor()
    {
        return "Bleu";
    }
}

// Abstraction (ce qui est "au-dessus" du pont)
public abstract class Shape
{
    protected IColor color;

    protected Shape(IColor color)
    {
        this.color = color;
    }

    public abstract void Draw();
}

// Abstractions raffin√©es
public class Circle : Shape
{
    public Circle(IColor color) : base(color)
    {
    }

    public override void Draw()
    {
        Console.WriteLine($"Dessiner un cercle {color.GetColor()}");
    }
}

public class Square : Shape
{
    public Square(IColor color) : base(color)
    {
    }

    public override void Draw()
    {
        Console.WriteLine($"Dessiner un carr√© {color.GetColor()}");
    }
}

// Utilisation
var redCircle = new Circle(new RedColor());
var blueSquare = new Square(new BlueColor());

redCircle.Draw();    // Dessiner un cercle Rouge
blueSquare.Draw();   // Dessiner un carr√© Bleu
```

### Exemple plus avanc√© : Appareils et t√©l√©commandes

```csharp
// Interface implementation (Device)
public interface IDevice
{
    void TurnOn();
    void TurnOff();
    void SetVolume(int volume);
    int GetVolume();
    bool IsEnabled();
}

// Impl√©mentations concr√®tes
public class TV : IDevice
{
    private bool isOn = false;
    private int volume = 50;

    public void TurnOn()
    {
        isOn = true;
        Console.WriteLine("TV allum√©e");
    }

    public void TurnOff()
    {
        isOn = false;
        Console.WriteLine("TV √©teinte");
    }

    public void SetVolume(int volume)
    {
        this.volume = Math.Max(0, Math.Min(100, volume));
        Console.WriteLine($"Volume TV: {this.volume}");
    }

    public int GetVolume() => volume;
    public bool IsEnabled() => isOn;
}

public class Radio : IDevice
{
    private bool isOn = false;
    private int volume = 30;

    public void TurnOn()
    {
        isOn = true;
        Console.WriteLine("Radio allum√©e");
    }

    public void TurnOff()
    {
        isOn = false;
        Console.WriteLine("Radio √©teinte");
    }

    public void SetVolume(int volume)
    {
        this.volume = Math.Max(0, Math.Min(100, volume));
        Console.WriteLine($"Volume Radio: {this.volume}");
    }

    public int GetVolume() => volume;
    public bool IsEnabled() => isOn;
}

// Abstraction (Remote)
public class RemoteControl
{
    protected IDevice device;

    public RemoteControl(IDevice device)
    {
        this.device = device;
    }

    public void TogglePower()
    {
        if (device.IsEnabled())
        {
            device.TurnOff();
        }
        else
        {
            device.TurnOn();
        }
    }

    public void VolumeUp()
    {
        device.SetVolume(device.GetVolume() + 10);
    }

    public void VolumeDown()
    {
        device.SetVolume(device.GetVolume() - 10);
    }
}

// Abstraction raffin√©e
public class AdvancedRemoteControl : RemoteControl
{
    public AdvancedRemoteControl(IDevice device) : base(device)
    {
    }

    public void Mute()
    {
        device.SetVolume(0);
        Console.WriteLine("Appareil mis en silencieux");
    }
}

// Utilisation
var tv = new TV();
var remote = new AdvancedRemoteControl(tv);

remote.TogglePower();  // TV allum√©e
remote.VolumeUp();     // Volume TV: 60
remote.Mute();         // Appareil mis en silencieux
```

## 19.2.3. Composite - "Traiter les objets et les composites de mani√®re uniforme"

### Qu'est-ce que le Composite ?

Le Composite permet de **composer des objets en structures d'arbre** et de travailler avec ces structures comme avec des objets individuels.

### Quand l'utiliser ?

- Pour repr√©senter des hi√©rarchies d'objets
- Quand vous voulez traiter les objets individuels et les compositions de mani√®re uniforme
- Pour cr√©er des structures r√©cursives

### Exemple simple : Syst√®me de fichiers

```csharp
// Composant abstrait
public abstract class FileSystemComponent
{
    protected string name;

    public FileSystemComponent(string name)
    {
        this.name = name;
    }

    public abstract void Display(int depth = 0);
    public abstract long GetSize();

    protected string GetIndent(int depth)
    {
        return new string(' ', depth * 2);
    }
}

// Feuille (Leaf)
public class File : FileSystemComponent
{
    private long size;

    public File(string name, long size) : base(name)
    {
        this.size = size;
    }

    public override void Display(int depth = 0)
    {
        Console.WriteLine($"{GetIndent(depth)}- {name} ({size} bytes)");
    }

    public override long GetSize()
    {
        return size;
    }
}

// Composite
public class Folder : FileSystemComponent
{
    private List<FileSystemComponent> components = new List<FileSystemComponent>();

    public Folder(string name) : base(name)
    {
    }

    public void Add(FileSystemComponent component)
    {
        components.Add(component);
    }

    public void Remove(FileSystemComponent component)
    {
        components.Remove(component);
    }

    public override void Display(int depth = 0)
    {
        Console.WriteLine($"{GetIndent(depth)}+ {name}/");
        foreach (var component in components)
        {
            component.Display(depth + 1);
        }
    }

    public override long GetSize()
    {
        return components.Sum(c => c.GetSize());
    }
}

// Utilisation
var root = new Folder("Root");
var documents = new Folder("Documents");
var photos = new Folder("Photos");

var file1 = new File("resume.docx", 24576);
var file2 = new File("presentation.pptx", 2048000);
var photo1 = new File("beach.jpg", 1048576);
var photo2 = new File("sunset.jpg", 2097152);

documents.Add(file1);
documents.Add(file2);
photos.Add(photo1);
photos.Add(photo2);

root.Add(documents);
root.Add(photos);

root.Display();
Console.WriteLine($"\nTaille totale: {root.GetSize()} bytes");

/* Output:
+ Root/
  + Documents/
    - resume.docx (24576 bytes)
    - presentation.pptx (2048000 bytes)
  + Photos/
    - beach.jpg (1048576 bytes)
    - sunset.jpg (2097152 bytes)

Taille totale: 5218304 bytes
*/
```

### Exemple avanc√© : Interface graphique

```csharp
// Composant abstrait
public abstract class UIComponent
{
    protected string name;
    protected int x, y, width, height;

    public UIComponent(string name, int x, int y, int width, int height)
    {
        this.name = name;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public abstract void Draw();
    public abstract void HandleClick(int clickX, int clickY);
}

// Feuilles
public class Button : UIComponent
{
    public Button(string name, int x, int y, int width, int height)
        : base(name, x, y, width, height)
    {
    }

    public override void Draw()
    {
        Console.WriteLine($"Bouton '{name}' √† ({x}, {y}) - {width}x{height}");
    }

    public override void HandleClick(int clickX, int clickY)
    {
        if (clickX >= x && clickX <= x + width &&
            clickY >= y && clickY <= y + height)
        {
            Console.WriteLine($"Bouton '{name}' cliqu√©!");
        }
    }
}

public class TextBox : UIComponent
{
    public TextBox(string name, int x, int y, int width, int height)
        : base(name, x, y, width, height)
    {
    }

    public override void Draw()
    {
        Console.WriteLine($"TextBox '{name}' √† ({x}, {y}) - {width}x{height}");
    }

    public override void HandleClick(int clickX, int clickY)
    {
        if (clickX >= x && clickX <= x + width &&
            clickY >= y && clickY <= y + height)
        {
            Console.WriteLine($"TextBox '{name}' s√©lectionn√©e!");
        }
    }
}

// Composite
public class Panel : UIComponent
{
    private List<UIComponent> components = new List<UIComponent>();

    public Panel(string name, int x, int y, int width, int height)
        : base(name, x, y, width, height)
    {
    }

    public void Add(UIComponent component)
    {
        components.Add(component);
    }

    public override void Draw()
    {
        Console.WriteLine($"Panel '{name}' √† ({x}, {y}) - {width}x{height}");
        foreach (var component in components)
        {
            component.Draw();
        }
    }

    public override void HandleClick(int clickX, int clickY)
    {
        // Transformer les coordonn√©es relatives au panel
        int relativeX = clickX - x;
        int relativeY = clickY - y;

        foreach (var component in components)
        {
            component.HandleClick(relativeX, relativeY);
        }
    }
}

// Utilisation
var mainWindow = new Panel("Fen√™tre principale", 0, 0, 800, 600);
var loginPanel = new Panel("Panel de connexion", 50, 50, 300, 200);

var usernameBox = new TextBox("Username", 10, 30, 200, 30);
var passwordBox = new TextBox("Password", 10, 80, 200, 30);
var loginButton = new Button("Se connecter", 10, 130, 100, 40);

loginPanel.Add(usernameBox);
loginPanel.Add(passwordBox);
loginPanel.Add(loginButton);

mainWindow.Add(loginPanel);

mainWindow.Draw();
mainWindow.HandleClick(120, 180); // Clic sur le bouton
```

## 19.2.4. Decorator - "Ajouter des responsabilit√©s dynamiquement"

### Qu'est-ce que le Decorator ?

Le Decorator permet d'**ajouter dynamiquement des fonctionnalit√©s** √† un objet sans modifier sa structure.

### Quand l'utiliser ?

- Pour √©tendre les fonctionnalit√©s d'un objet sans sous-classer
- Quand vous avez besoin de combinaisons flexibles de comportements
- Pour appliquer des responsabilit√©s qu'on peut retirer

### Exemple simple : Caf√© avec options

```csharp
// Interface composant
public interface ICoffee
{
    string GetDescription();
    double GetCost();
}

// Composant de base
public class SimpleCoffee : ICoffee
{
    public string GetDescription()
    {
        return "Caf√© simple";
    }

    public double GetCost()
    {
        return 1.0;
    }
}

// D√©corateur abstrait
public abstract class CoffeeDecorator : ICoffee
{
    protected ICoffee coffee;

    public CoffeeDecorator(ICoffee coffee)
    {
        this.coffee = coffee;
    }

    public abstract string GetDescription();
    public abstract double GetCost();
}

// D√©corateurs concrets
public class Milk : CoffeeDecorator
{
    public Milk(ICoffee coffee) : base(coffee)
    {
    }

    public override string GetDescription()
    {
        return coffee.GetDescription() + ", Lait";
    }

    public override double GetCost()
    {
        return coffee.GetCost() + 0.5;
    }
}

public class Sugar : CoffeeDecorator
{
    public Sugar(ICoffee coffee) : base(coffee)
    {
    }

    public override string GetDescription()
    {
        return coffee.GetDescription() + ", Sucre";
    }

    public override double GetCost()
    {
        return coffee.GetCost() + 0.2;
    }
}

public class WhippedCream : CoffeeDecorator
{
    public WhippedCream(ICoffee coffee) : base(coffee)
    {
    }

    public override string GetDescription()
    {
        return coffee.GetDescription() + ", Cr√®me fouett√©e";
    }

    public override double GetCost()
    {
        return coffee.GetCost() + 0.7;
    }
}

// Utilisation
ICoffee myCoffee = new SimpleCoffee();
Console.WriteLine($"{myCoffee.GetDescription()} = ${myCoffee.GetCost()}");

// Ajouter du lait
myCoffee = new Milk(myCoffee);
Console.WriteLine($"{myCoffee.GetDescription()} = ${myCoffee.GetCost()}");

// Ajouter du sucre
myCoffee = new Sugar(myCoffee);
Console.WriteLine($"{myCoffee.GetDescription()} = ${myCoffee.GetCost()}");

// Ajouter de la cr√®me fouett√©e
myCoffee = new WhippedCream(myCoffee);
Console.WriteLine($"{myCoffee.GetDescription()} = ${myCoffee.GetCost()}");

/* Output:
Caf√© simple = $1
Caf√© simple, Lait = $1.5
Caf√© simple, Lait, Sucre = $1.7
Caf√© simple, Lait, Sucre, Cr√®me fouett√©e = $2.4
*/
```

### Exemple avanc√© : Syst√®me de compression de fichiers

```csharp
// Interface composant
public interface IDataSource
{
    void WriteData(byte[] data);
    byte[] ReadData();
}

// Composant de base
public class FileDataSource : IDataSource
{
    private string filename;

    public FileDataSource(string filename)
    {
        this.filename = filename;
    }

    public void WriteData(byte[] data)
    {
        File.WriteAllBytes(filename, data);
        Console.WriteLine($"Donn√©es √©crites dans {filename}");
    }

    public byte[] ReadData()
    {
        byte[] data = File.ReadAllBytes(filename);
        Console.WriteLine($"Donn√©es lues depuis {filename}");
        return data;
    }
}

// D√©corateur abstrait
public abstract class DataSourceDecorator : IDataSource
{
    protected IDataSource dataSource;

    public DataSourceDecorator(IDataSource dataSource)
    {
        this.dataSource = dataSource;
    }

    public abstract void WriteData(byte[] data);
    public abstract byte[] ReadData();
}

// D√©corateur de compression
public class CompressionDecorator : DataSourceDecorator
{
    public CompressionDecorator(IDataSource dataSource) : base(dataSource)
    {
    }

    public override void WriteData(byte[] data)
    {
        byte[] compressedData = Compress(data);
        Console.WriteLine($"Compression des donn√©es ({data.Length} -> {compressedData.Length} bytes)");
        dataSource.WriteData(compressedData);
    }

    public override byte[] ReadData()
    {
        byte[] compressedData = dataSource.ReadData();
        byte[] decompressedData = Decompress(compressedData);
        Console.WriteLine($"D√©compression des donn√©es ({compressedData.Length} -> {decompressedData.Length} bytes)");
        return decompressedData;
    }

    private byte[] Compress(byte[] data)
    {
        // Simulation de compression
        using (var output = new MemoryStream())
        {
            using (var compressor = new System.IO.Compression.GZipStream(output, System.IO.Compression.CompressionLevel.Optimal))
            {
                compressor.Write(data, 0, data.Length);
            }
            return output.ToArray();
        }
    }

    private byte[] Decompress(byte[] data)
    {
        // Simulation de d√©compression
        using (var input = new MemoryStream(data))
        using (var decompressor = new System.IO.Compression.GZipStream(input, System.IO.Compression.CompressionMode.Decompress))
        using (var output = new MemoryStream())
        {
            decompressor.CopyTo(output);
            return output.ToArray();
        }
    }
}

// D√©corateur de chiffrement
public class EncryptionDecorator : DataSourceDecorator
{
    public EncryptionDecorator(IDataSource dataSource) : base(dataSource)
    {
    }

    public override void WriteData(byte[] data)
    {
        byte[] encryptedData = Encrypt(data);
        Console.WriteLine($"Chiffrement des donn√©es");
        dataSource.WriteData(encryptedData);
    }

    public override byte[] ReadData()
    {
        byte[] encryptedData = dataSource.ReadData();
        byte[] decryptedData = Decrypt(encryptedData);
        Console.WriteLine($"D√©chiffrement des donn√©es");
        return decryptedData;
    }

    private byte[] Encrypt(byte[] data)
    {
        // Simulation simple de chiffrement (XOR)
        byte[] result = new byte[data.Length];
        byte key = 123; // Cl√© simple pour l'exemple

        for (int i = 0; i < data.Length; i++)
        {
            result[i] = (byte)(data[i] ^ key);
        }

        return result;
    }

    private byte[] Decrypt(byte[] data)
    {
        // Le d√©chiffrement XOR est identique au chiffrement
        return Encrypt(data);
    }
}

// Utilisation
string filename = "data.txt";
byte[] testData = Encoding.UTF8.GetBytes("Ceci est un message secret!");

// Source de donn√©es simple
IDataSource dataSource = new FileDataSource(filename);

// Ajouter compression et chiffrement
dataSource = new CompressionDecorator(dataSource);
dataSource = new EncryptionDecorator(dataSource);

// √âcrire les donn√©es (elles seront chiffr√©es puis compress√©es)
dataSource.WriteData(testData);

// Lire les donn√©es (elles seront d√©compress√©es puis d√©chiffr√©es)
byte[] readData = dataSource.ReadData();
string result = Encoding.UTF8.GetString(readData);
Console.WriteLine($"Donn√©es r√©cup√©r√©es: {result}");
```

## 19.2.5. Fa√ßade - "Interface simplifi√©e"

### Qu'est-ce que la Fa√ßade ?

La Fa√ßade fournit une **interface simplifi√©e** pour un sous-syst√®me complexe.

### Quand l'utiliser ?

- Pour masquer la complexit√© d'un syst√®me
- Pour fournir un point d'entr√©e unique
- Pour r√©duire les d√©pendances entre syst√®mes

### Exemple simple : Syst√®me home cin√©ma

```csharp
// Composants complexes du syst√®me
public class TV
{
    public void TurnOn() => Console.WriteLine("TV allum√©e");
    public void TurnOff() => Console.WriteLine("TV √©teinte");
    public void SetInput(string input) => Console.WriteLine($"TV entr√©e: {input}");
}

public class SoundSystem
{
    public void TurnOn() => Console.WriteLine("Syst√®me audio allum√©");
    public void TurnOff() => Console.WriteLine("Syst√®me audio √©teint");
    public void SetVolume(int volume) => Console.WriteLine($"Volume: {volume}");
    public void SetSurroundSound() => Console.WriteLine("Son surround activ√©");
}

public class DVDPlayer
{
    public void TurnOn() => Console.WriteLine("Lecteur DVD allum√©");
    public void TurnOff() => Console.WriteLine("Lecteur DVD √©teint");
    public void Play(string movie) => Console.WriteLine($"Lecture: {movie}");
    public void Stop() => Console.WriteLine("Arr√™t de la lecture");
}

public class Projector
{
    public void TurnOn() => Console.WriteLine("Projecteur allum√©");
    public void TurnOff() => Console.WriteLine("Projecteur √©teint");
    public void WideScreenMode() => Console.WriteLine("Mode √©cran large");
}

public class Lights
{
    public void Dim(int level) => Console.WriteLine($"Lumi√®res tamis√©es: {level}%");
    public void TurnOn() => Console.WriteLine("Lumi√®res allum√©es");
}

// Fa√ßade qui simplifie l'utilisation
public class HomeTheaterFacade
{
    private TV tv;
    private SoundSystem soundSystem;
    private DVDPlayer dvdPlayer;
    private Projector projector;
    private Lights lights;

    public HomeTheaterFacade()
    {
        tv = new TV();
        soundSystem = new SoundSystem();
        dvdPlayer = new DVDPlayer();
        projector = new Projector();
        lights = new Lights();
    }

    public void WatchMovie(string movie)
    {
        Console.WriteLine("Pr√©paration pour regarder un film...");

        lights.Dim(10);
        projector.TurnOn();
        projector.WideScreenMode();
        tv.TurnOn();
        tv.SetInput("DVD");
        soundSystem.TurnOn();
        soundSystem.SetSurroundSound();
        soundSystem.SetVolume(50);
        dvdPlayer.TurnOn();
        dvdPlayer.Play(movie);

        Console.WriteLine("Film pr√™t √† √™tre regard√©!");
    }

    public void EndMovie()
    {
        Console.WriteLine("Fin du film...");

        dvdPlayer.Stop();
        dvdPlayer.TurnOff();
        soundSystem.TurnOff();
        tv.TurnOff();
        projector.TurnOff();
        lights.TurnOn();

        Console.WriteLine("Syst√®me √©teint!");
    }
}

// Utilisation
var homeTheater = new HomeTheaterFacade();
homeTheater.WatchMovie("Inception");
// ... apr√®s avoir regard√© le film
homeTheater.EndMovie();
```

### Exemple avanc√© : API d'envoi de notifications

```csharp
// Services complexes
public class EmailService
{
    public void SendEmail(string to, string subject, string body)
    {
        Console.WriteLine($"Email envoy√© √† {to}: {subject}");
    }
}

public class SMSService
{
    public void SendSMS(string phoneNumber, string message)
    {
        Console.WriteLine($"SMS envoy√© √† {phoneNumber}: {message}");
    }
}

public class PushNotificationService
{
    public void SendPushNotification(string deviceId, string title, string message)
    {
        Console.WriteLine($"Push envoy√© √† {deviceId}: {title} - {message}");
    }
}

public class SlackService
{
    public void SendSlackMessage(string channel, string message)
    {
        Console.WriteLine($"Message Slack envoy√© √† #{channel}: {message}");
    }
}

// Base de donn√©es pour r√©cup√©rer les informations
public class UserDatabase
{
    private Dictionary<string, UserInfo> users = new Dictionary<string, UserInfo>
    {
        {"user1", new UserInfo { Email = "user1@email.com", Phone = "1234567890", DeviceId = "device123" } },
        {"user2", new UserInfo { Email = "user2@email.com", Phone = "0987654321", DeviceId = "device456" } }
    };

    public UserInfo GetUserInfo(string userId)
    {
        users.TryGetValue(userId, out var userInfo);
        return userInfo ?? new UserInfo();
    }
}

public class UserInfo
{
    public string Email { get; set; }
    public string Phone { get; set; }
    public string DeviceId { get; set; }
}

// Fa√ßade pour simplifier l'envoi de notifications
public class NotificationFacade
{
    private EmailService emailService;
    private SMSService smsService;
    private PushNotificationService pushService;
    private SlackService slackService;
    private UserDatabase userDatabase;

    public NotificationFacade()
    {
        emailService = new EmailService();
        smsService = new SMSService();
        pushService = new PushNotificationService();
        slackService = new SlackService();
        userDatabase = new UserDatabase();
    }

    public void SendAllNotifications(string userId, string subject, string message)
    {
        var userInfo = userDatabase.GetUserInfo(userId);

        // Envoyer par tous les canaux disponibles
        if (!string.IsNullOrEmpty(userInfo.Email))
        {
            emailService.SendEmail(userInfo.Email, subject, message);
        }

        if (!string.IsNullOrEmpty(userInfo.Phone))
        {
            // Simplifier le message pour SMS
            string shortMessage = message.Length > 160 ? message.Substring(0, 157) + "..." : message;
            smsService.SendSMS(userInfo.Phone, shortMessage);
        }

        if (!string.IsNullOrEmpty(userInfo.DeviceId))
        {
            pushService.SendPushNotification(userInfo.DeviceId, subject, message);
        }
    }

    public void SendUrgentAlert(string subject, string message)
    {
        Console.WriteLine($"ALERTE URGENTE: {subject}");

        // Envoyer √† tous les canaux d'urgence
        slackService.SendSlackMessage("alerts", $"üö® {subject}: {message}");

        // Envoyer √† tous les utilisateurs
        var allUsers = new[] { "user1", "user2" }; // Simplified for example
        foreach (var userId in allUsers)
        {
            SendAllNotifications(userId, $"URGENT: {subject}", message);
        }
    }

    public void SendWelcomeMessage(string userId)
    {
        var userInfo = userDatabase.GetUserInfo(userId);
        string subject = "Bienvenue dans notre application!";
        string message = "Merci de nous avoir rejoint. Voici comment commencer...";

        // S√©quence de bienvenue personnalis√©e
        emailService.SendEmail(userInfo.Email, subject, message);

        // Envoyer aussi une push notification apr√®s 5 secondes
        if (!string.IsNullOrEmpty(userInfo.DeviceId))
        {
            pushService.SendPushNotification(userInfo.DeviceId, "N'oubliez pas...",
                "Consultez votre email pour des conseils utiles");
        }
    }
}

// Utilisation simplifi√©e
var notifications = new NotificationFacade();

// Envoyer une notification simple
notifications.SendAllNotifications("user1", "Nouveau message", "Vous avez un nouveau message");

// Envoyer une alerte urgente
notifications.SendUrgentAlert("Maintenance syst√®me", "Le syst√®me sera indisponible de 2h √† 4h");

// Envoyer un message de bienvenue
notifications.SendWelcomeMessage("user2");
```

## 19.2.6. Proxy - "Repr√©sentant ou substitut"

### Qu'est-ce que le Proxy ?

Le Proxy fournit un **substitut ou un repr√©sentant** d'un autre objet pour contr√¥ler l'acc√®s √† celui-ci.

### Types de Proxy courants :

1. **Virtual Proxy** : Charge un objet √† la demande
2. **Protection Proxy** : Contr√¥le l'acc√®s √† un objet
3. **Remote Proxy** : Repr√©sente un objet distant
4. **Cache Proxy** : Met en cache des r√©sultats

### Exemple simple : Virtual Proxy pour images

```csharp
// Interface commune
public interface IImage
{
    void Display();
    void Resize(int width, int height);
}

// Objet r√©el (co√ªteux √† cr√©er)
public class RealImage : IImage
{
    private string filename;
    private byte[] imageData;
    private int width;
    private int height;

    public RealImage(string filename)
    {
        this.filename = filename;
        LoadImageFromDisk();
    }

    private void LoadImageFromDisk()
    {
        Console.WriteLine($"Chargement de l'image {filename} depuis le disque...");
        // Simulation du chargement co√ªteux
        System.Threading.Thread.Sleep(1000);

        // Simuler le chargement de donn√©es
        imageData = new byte[1024 * 1024]; // 1MB
        width = 1920;
        height = 1080;

        Console.WriteLine($"Image {filename} charg√©e ({width}x{height})");
    }

    public void Display()
    {
        Console.WriteLine($"Affichage de l'image {filename} ({width}x{height})");
    }

    public void Resize(int width, int height)
    {
        this.width = width;
        this.height = height;
        Console.WriteLine($"Image {filename} redimensionn√©e √† {width}x{height}");
    }
}

// Proxy qui charge l'image √† la demande
public class ImageProxy : IImage
{
    private string filename;
    private RealImage realImage;

    public ImageProxy(string filename)
    {
        this.filename = filename;
    }

    public void Display()
    {
        // Charger l'image r√©elle seulement si n√©cessaire
        if (realImage == null)
        {
            realImage = new RealImage(filename);
        }
        realImage.Display();
    }

    public void Resize(int width, int height)
    {
        // Certaines op√©rations peuvent √™tre faites sans charger l'image
        Console.WriteLine($"Pr√©paration du redimensionnement √† {width}x{height}");

        // Charger seulement si vraiment n√©cessaire
        if (realImage == null)
        {
            realImage = new RealImage(filename);
        }
        realImage.Resize(width, height);
    }
}

// Utilisation
Console.WriteLine("Cr√©ation du proxy...");
IImage image = new ImageProxy("grande_image.jpg");
Console.WriteLine("Proxy cr√©√©, image non encore charg√©e");

// L'image est charg√©e seulement maintenant
image.Display();

// Redimensionnement
image.Resize(800, 600);
```

### Exemple avanc√© : Protection Proxy

```csharp
// Interface pour l'acc√®s aux donn√©es sensibles
public interface ISecureDatabase
{
    string ReadData(string query);
    void WriteData(string data);
    void DeleteData(string condition);
}

// Objet r√©el avec acc√®s √† la base de donn√©es
public class SecureDatabase : ISecureDatabase
{
    public string ReadData(string query)
    {
        Console.WriteLine($"Ex√©cution requ√™te: {query}");
        return "Donn√©es sensibles...";
    }

    public void WriteData(string data)
    {
        Console.WriteLine($"√âcriture donn√©es: {data}");
    }

    public void DeleteData(string condition)
    {
        Console.WriteLine($"Suppression donn√©es: {condition}");
    }
}

// Syst√®me d'authentification
public enum UserRole
{
    Admin,
    User,
    Guest
}

public class User
{
    public string Name { get; set; }
    public UserRole Role { get; set; }
    public string Password { get; set; }
}

// Protection Proxy avec authentification et autorisation
public class DatabaseProtectionProxy : ISecureDatabase
{
    private SecureDatabase realDatabase;
    private User currentUser;
    private Dictionary<string, User> users;

    public DatabaseProtectionProxy()
    {
        realDatabase = new SecureDatabase();
        // Initialiser quelques utilisateurs pour l'exemple
        users = new Dictionary<string, User>
        {
            {"admin", new User { Name = "admin", Role = UserRole.Admin, Password = "admin123" }},
            {"user1", new User { Name = "user1", Role = UserRole.User, Password = "user123" }},
            {"guest", new User { Name = "guest", Role = UserRole.Guest, Password = "guest123" }}
        };
    }

    public bool Login(string username, string password)
    {
        if (users.TryGetValue(username, out var user) && user.Password == password)
        {
            currentUser = user;
            Console.WriteLine($"Connexion r√©ussie en tant que {user.Name} ({user.Role})");
            return true;
        }

        Console.WriteLine("√âchec de la connexion");
        return false;
    }

    public void Logout()
    {
        Console.WriteLine($"D√©connexion de {currentUser?.Name}");
        currentUser = null;
    }

    public string ReadData(string query)
    {
        if (currentUser == null)
        {
            throw new UnauthorizedAccessException("Vous devez √™tre connect√©");
        }

        if (currentUser.Role == UserRole.Guest)
        {
            throw new UnauthorizedAccessException("Les invit√©s ne peuvent pas lire les donn√©es");
        }

        Console.WriteLine($"[{currentUser.Name}] Acc√®s en lecture autoris√©");
        return realDatabase.ReadData(query);
    }

    public void WriteData(string data)
    {
        if (currentUser == null)
        {
            throw new UnauthorizedAccessException("Vous devez √™tre connect√©");
        }

        if (currentUser.Role != UserRole.Admin)
        {
            throw new UnauthorizedAccessException("Seuls les administrateurs peuvent √©crire");
        }

        Console.WriteLine($"[{currentUser.Name}] Acc√®s en √©criture autoris√©");
        realDatabase.WriteData(data);
    }

    public void DeleteData(string condition)
    {
        if (currentUser == null)
        {
            throw new UnauthorizedAccessException("Vous devez √™tre connect√©");
        }

        if (currentUser.Role != UserRole.Admin)
        {
            throw new UnauthorizedAccessException("Seuls les administrateurs peuvent supprimer");
        }

        // Double v√©rification pour les suppressions
        Console.WriteLine($"ATTENTION: Tentative de suppression par {currentUser.Name}");
        Console.WriteLine("Confirmer la suppression? (y/N)");
        // Dans un vrai syst√®me, on attendrait la confirmation
        Console.WriteLine("Suppression confirm√©e");
        realDatabase.DeleteData(condition);
    }
}

// Utilisation
var database = new DatabaseProtectionProxy();

// Tentative sans connexion
try
{
    database.ReadData("SELECT * FROM users");
}
catch (UnauthorizedAccessException ex)
{
    Console.WriteLine($"Erreur: {ex.Message}");
}

// Connexion en tant qu'utilisateur normal
database.Login("user1", "user123");
var data = database.ReadData("SELECT * FROM public_data");

try
{
    database.WriteData("INSERT INTO users...");
}
catch (UnauthorizedAccessException ex)
{
    Console.WriteLine($"Erreur: {ex.Message}");
}

// Connexion en tant qu'admin
database.Login("admin", "admin123");
database.WriteData("INSERT INTO logs...");
database.DeleteData("WHERE date < '2023-01-01'");
```

## 19.2.7. Flyweight - "Partager pour √©conomiser"

### Qu'est-ce que le Flyweight ?

Le Flyweight permet d'**√©conomiser de la m√©moire** en partageant efficacement des donn√©es communes entre plusieurs objets.

### Concepts cl√©s :

- **√âtat intrins√®que** : donn√©es partag√©es entre objets
- **√âtat extrins√®que** : donn√©es uniques √† chaque objet
- **Factory** : g√®re la cr√©ation et le partage des flyweights

### Exemple simple : Caract√®res dans un traitement de texte

```csharp
// Flyweight stockant l'√©tat intrins√®que (partag√©)
public class CharacterStyle
{
    public string Font { get; private set; }
    public int Size { get; private set; }
    public string Color { get; private set; }

    public CharacterStyle(string font, int size, string color)
    {
        Font = font;
        Size = size;
        Color = color;
    }

    public void Display(char character, int x, int y)
    {
        Console.WriteLine($"Caract√®re '{character}' √† ({x},{y}) - {Font}, {Size}pt, {Color}");
    }
}

// Factory pour g√©rer les flyweights
public class CharacterStyleFactory
{
    private Dictionary<string, CharacterStyle> styles = new Dictionary<string, CharacterStyle>();

    public CharacterStyle GetStyle(string font, int size, string color)
    {
        string key = $"{font}-{size}-{color}";

        if (!styles.ContainsKey(key))
        {
            styles[key] = new CharacterStyle(font, size, color);
            Console.WriteLine($"Nouveau style cr√©√©: {key}");
        }
        else
        {
            Console.WriteLine($"Style r√©utilis√©: {key}");
        }

        return styles[key];
    }

    public int GetStyleCount()
    {
        return styles.Count;
    }
}

// Contexte stockant l'√©tat extrins√®que (unique)
public class Character
{
    private char character;
    private int x;
    private int y;
    private CharacterStyle style; // R√©f√©rence partag√©e

    public Character(char character, int x, int y, CharacterStyle style)
    {
        this.character = character;
        this.x = x;
        this.y = y;
        this.style = style;
    }

    public void Display()
    {
        style.Display(character, x, y);
    }
}

// Document utilisant les caract√®res
public class Document
{
    private List<Character> characters = new List<Character>();
    private CharacterStyleFactory styleFactory = new CharacterStyleFactory();

    public void AddCharacter(char character, int x, int y, string font, int size, string color)
    {
        CharacterStyle style = styleFactory.GetStyle(font, size, color);
        characters.Add(new Character(character, x, y, style));
    }

    public void Display()
    {
        foreach (var character in characters)
        {
            character.Display();
        }

        Console.WriteLine($"\nNombre total de caract√®res: {characters.Count}");
        Console.WriteLine($"Nombre de styles cr√©√©s: {styleFactory.GetStyleCount()}");
    }
}

// Utilisation
var document = new Document();

// Ajouter du texte avec diff√©rents styles
string text = "Hello World!";
for (int i = 0; i < text.Length; i++)
{
    document.AddCharacter(text[i], i * 10, 10, "Arial", 12, "Black");
}

// Ajouter plus de texte avec certains styles partag√©s
for (int i = 0; i < "Hello".Length; i++)
{
    document.AddCharacter("Hello"[i], i * 10, 30, "Arial", 12, "Red");
}

document.Display();
```

### Exemple avanc√© : Particules dans un jeu

```csharp
// Flyweight pour les types de particules
public class ParticleType
{
    public string Name { get; private set; }
    public string Texture { get; private set; }
    public double Mass { get; private set; }
    public string Color { get; private set; }

    public ParticleType(string name, string texture, double mass, string color)
    {
        Name = name;
        Texture = texture;
        Mass = mass;
        Color = color;
    }

    public void Render(double x, double y, double size, double rotation)
    {
        Console.WriteLine($"Particule {Name} √† ({x:F1},{y:F1}) " +
                         $"- texture: {Texture}, masse: {Mass}, " +
                         $"couleur: {Color}, taille: {size:F1}, rotation: {rotation:F1}¬∞");
    }

    public void UpdatePhysics(Particle particle, double deltaTime)
    {
        // Calculer les effets physiques bas√©s sur la masse
        particle.VelocityY += 9.81 * Mass * deltaTime; // Gravit√©

        // Appliquer la vitesse
        particle.X += particle.VelocityX * deltaTime;
        particle.Y += particle.VelocityY * deltaTime;

        // Appliquer la rotation
        particle.Rotation += particle.AngularVelocity * deltaTime;
    }
}

// Contexte pour chaque particule individuelle
public class Particle
{
    public double X { get; set; }
    public double Y { get; set; }
    public double VelocityX { get; set; }
    public double VelocityY { get; set; }
    public double Size { get; set; }
    public double Rotation { get; set; }
    public double AngularVelocity { get; set; }
    public double LifeTime { get; set; }

    private ParticleType type;

    public Particle(ParticleType type, double x, double y, double velocityX, double velocityY)
    {
        this.type = type;
        X = x;
        Y = y;
        VelocityX = velocityX;
        VelocityY = velocityY;
        Size = 1.0;
        Rotation = 0;
        AngularVelocity = new Random().NextDouble() * 360 - 180;
        LifeTime = 5.0;
    }

    public void Update(double deltaTime)
    {
        type.UpdatePhysics(this, deltaTime);
        LifeTime -= deltaTime;

        // R√©duire la taille avec le temps
        Size = Math.Max(0.1, LifeTime / 5.0);
    }

    public void Render()
    {
        type.Render(X, Y, Size, Rotation);
    }

    public bool IsAlive()
    {
        return LifeTime > 0;
    }
}

// Factory pour g√©rer les types de particules
public class ParticleTypeFactory
{
    private Dictionary<string, ParticleType> types = new Dictionary<string, ParticleType>();

    public ParticleType GetParticleType(string name)
    {
        if (!types.ContainsKey(name))
        {
            switch (name)
            {
                case "fire":
                    types[name] = new ParticleType("fire", "fire.png", 0.1, "Orange");
                    break;
                case "smoke":
                    types[name] = new ParticleType("smoke", "smoke.png", 0.05, "Gray");
                    break;
                case "explosion":
                    types[name] = new ParticleType("explosion", "explosion.png", 0.15, "Yellow");
                    break;
                default:
                    types[name] = new ParticleType(name, "default.png", 0.1, "White");
                    break;
            }
            Console.WriteLine($"Nouveau type de particule cr√©√©: {name}");
        }

        return types[name];
    }

    public int GetTypeCount()
    {
        return types.Count;
    }
}

// Syst√®me de particules
public class ParticleSystem
{
    private List<Particle> particles = new List<Particle>();
    private ParticleTypeFactory typeFactory = new ParticleTypeFactory();
    private Random random = new Random();

    public void CreateExplosion(double x, double y, int count = 50)
    {
        var explosionType = typeFactory.GetParticleType("explosion");
        var fireType = typeFactory.GetParticleType("fire");
        var smokeType = typeFactory.GetParticleType("smoke");

        for (int i = 0; i < count; i++)
        {
            // Angle al√©atoire
            double angle = random.NextDouble() * Math.PI * 2;
            double speed = random.NextDouble() * 100 + 50;

            // Vitesses bas√©es sur l'angle
            double vx = Math.Cos(angle) * speed;
            double vy = Math.Sin(angle) * speed;

            // Choisir le type de particule
            ParticleType type;
            if (i < count * 0.2) type = explosionType;
            else if (i < count * 0.6) type = fireType;
            else type = smokeType;

            particles.Add(new Particle(type, x, y, vx, vy));
        }
    }

    public void Update(double deltaTime)
    {
        for (int i = particles.Count - 1; i >= 0; i--)
        {
            particles[i].Update(deltaTime);

            if (!particles[i].IsAlive())
            {
                particles.RemoveAt(i);
            }
        }
    }

    public void Render()
    {
        Console.WriteLine($"\n--- Frame ---");
        foreach (var particle in particles)
        {
            particle.Render();
        }

        Console.WriteLine($"Particules actives: {particles.Count}");
        Console.WriteLine($"Types de particules: {typeFactory.GetTypeCount()}");
    }
}

// Utilisation
var particleSystem = new ParticleSystem();

// Cr√©er une explosion
particleSystem.CreateExplosion(400, 300, 100);

// Simuler quelques frames
for (int frame = 0; frame < 5; frame++)
{
    particleSystem.Update(0.1);
    particleSystem.Render();
    Console.WriteLine("\n-----------------");
}
```

## R√©sum√© des Patterns Structurels

| Pattern | But principal | Cas d'utilisation typique |
|---------|--------------|--------------------------|
| **Adapter** | Adapter des interfaces | Int√©gration de biblioth√®ques tierces |
| **Bridge** | S√©parer abstraction/impl√©mentation | √âviter l'explosion combinatoire |
| **Composite** | Structures arborescentes | Syst√®mes de fichiers, UI |
| **Decorator** | Ajouter des responsabilit√©s | Ajout de fonctionnalit√©s flexibles |
| **Fa√ßade** | Interface simplifi√©e | Masquer la complexit√© |
| **Proxy** | Contr√¥ler l'acc√®s | Chargement lazy, s√©curit√© |
| **Flyweight** | Partager des donn√©es | Optimisation m√©moire |

## Bonnes pratiques

1. **Choisir le bon pattern** : Analysez votre probl√®me avant de choisir
2. **√âviter la surconception** : N'utilisez pas un pattern s'il complique inutilement le code
3. **Documenter vos choix** : Expliquez pourquoi vous avez choisi un pattern particulier
4. **Tester thoroughly** : Les patterns peuvent introduire de la complexit√©
5. **Combiner avec parcimonie** : Certains patterns fonctionnent bien ensemble, d'autres non

## Exercices pratiques

### Exercice 1 : Adapter pour base de donn√©es
Cr√©ez un adaptateur pour utiliser diff√©rentes bases de donn√©es (MySQL, PostgreSQL, MongoDB) avec une interface commune.

### Exercice 2 : Composite pour menus
Impl√©mentez un syst√®me de menus avec des items simples et des sous-menus en utilisant le pattern Composite.

### Exercice 3 : Decorator pour filtres d'image
Cr√©ez des d√©corateurs pour appliquer diff√©rents filtres √† des images (flou, noir et blanc, luminosit√©).

### Exercice 4 : Fa√ßade pour API complexe
Cr√©ez une fa√ßade pour simplifier l'utilisation d'une API REST complexe.

### Exercice 5 : Proxy pour cache
Impl√©mentez un proxy de cache pour une base de donn√©es qui stocke en m√©moire les r√©sultats fr√©quemment demand√©s.

## Conclusion

Les patterns structurels vous aident √† organiser et assembler des objets de mani√®re efficace. Ils sont particuli√®rement utiles pour :

- Adapter des composants incompatibles
- G√©rer la complexit√© des syst√®mes
- Optimiser les performances
- Cr√©er des structures flexibles et extensibles

N'oubliez pas que ces patterns sont des outils, pas des solutions universelles. Utilisez-les quand ils apportent une r√©elle valeur √† votre projet, et n'h√©sitez pas √† les adapter √† vos besoins sp√©cifiques.
