# 2.3 Variables et constantes en C#

Les variables et les constantes sont des √©l√©ments fondamentaux de tout programme informatique. Elles permettent de stocker, manipuler et r√©utiliser des donn√©es tout au long de l'ex√©cution de votre code. Comprendre comment les d√©clarer, les initialiser et g√©rer leur port√©e est essentiel pour tout d√©veloppeur C#.

## 2.3.1 D√©claration et initialisation

### Qu'est-ce qu'une variable ?

Une variable est un espace nomm√© en m√©moire qui contient une valeur d'un certain type. En C#, chaque variable a :
- Un nom (identificateur)
- Un type (qui d√©termine quelle sorte de donn√©es elle peut contenir)
- Une valeur (qui peut changer au cours du programme)

### D√©claration de variables

Pour d√©clarer une variable en C#, vous devez sp√©cifier son type suivi de son nom :

```csharp
// Syntaxe de base : Type Nom;
int age;
string nom;
bool estActif;
double salaire;
```

### R√®gles de nommage des variables

En C#, les noms de variables doivent suivre certaines r√®gles :

- Ils doivent commencer par une lettre ou un underscore (_)
- Ils peuvent contenir des lettres, des chiffres et des underscores
- Ils sont sensibles √† la casse (age et Age sont deux variables diff√©rentes)
- Ils ne peuvent pas √™tre un mot-cl√© r√©serv√© du langage

**Convention de nommage** : En C#, on utilise g√©n√©ralement la convention "camelCase" pour les variables locales (premi√®re lettre en minuscule, puis majuscule √† chaque nouveau mot).

```csharp
// Bons noms de variables
int compteur;
string nomUtilisateur;
double tauxInteret;
bool estAuthentifie;

// Noms de variables √† √©viter
int a;                 // Trop court, pas assez descriptif
string NOM_UTILISATEUR; // Pas en camelCase
double _123;           // Commence par un chiffre (invalide)
bool is;               // Mot r√©serv√© (invalide)
```

### Initialisation de variables

L'initialisation consiste √† assigner une premi√®re valeur √† une variable. Vous pouvez le faire au moment de la d√©claration ou plus tard :

```csharp
// Initialisation lors de la d√©claration
int age = 25;
string nom = "Marie";

// D√©claration puis initialisation s√©par√©e
double taille;
taille = 1.75;
```

### Initialisation par d√©faut

Si vous ne fournissez pas de valeur initiale, C# assigne des valeurs par d√©faut selon le type :

| Type | Valeur par d√©faut |
|------|------------------|
| Types num√©riques (`int`, `float`, etc.) | 0 |
| `bool` | false |
| `char` | '\0' (caract√®re nul) |
| Types r√©f√©rence (`string`, objets, etc.) | null |

> **üîç Note:** Ces valeurs par d√©faut s'appliquent aux variables membres de classes, mais pas aux variables locales. Les variables locales doivent √™tre explicitement initialis√©es avant utilisation.

### D√©claration de plusieurs variables

Vous pouvez d√©clarer plusieurs variables du m√™me type en une seule ligne :

```csharp
// Plusieurs variables du m√™me type
int x, y, z;

// Avec initialisation
int a = 1, b = 2, c = 3;

// Certaines avec initialisation, d'autres sans
string prenom = "Jean", nom = "Dupont", adresse;
```

### Variables mutables vs variables en lecture seule

Par d√©faut, les variables en C# sont mutables, ce qui signifie que leur valeur peut changer apr√®s l'initialisation. Nous verrons plus tard comment cr√©er des variables en lecture seule avec les mots-cl√©s `readonly` et `const`.

## 2.3.2 Port√©e (scope) des variables

La port√©e (ou scope) d'une variable d√©finit la partie du code o√π cette variable est accessible. En C#, la port√©e est principalement d√©termin√©e par les accolades `{ }` qui entourent le code.

### Types de port√©e

#### 1. Variables locales

Les variables d√©clar√©es √† l'int√©rieur d'une m√©thode, d'un constructeur ou d'un bloc sont des variables locales. Elles sont accessibles uniquement √† l'int√©rieur du bloc o√π elles sont d√©clar√©es.

```csharp
void MaMethode()
{
    int x = 10;  // Variable locale √† la m√©thode
    Console.WriteLine(x);  // OK

    if (x > 5)
    {
        int y = 20;  // Variable locale au bloc if
        Console.WriteLine(y);  // OK
        Console.WriteLine(x);  // OK - x est accessible dans ce bloc
    }

    // Console.WriteLine(y);  // ERREUR - y n'est pas accessible ici
}

// Console.WriteLine(x);  // ERREUR - x n'est pas accessible ici
```

#### 2. Variables membres (champs)

Les variables d√©clar√©es au niveau de la classe (en dehors des m√©thodes) sont des variables membres ou champs. Elles sont accessibles par toutes les m√©thodes de la classe.

```csharp
class MaClasse
{
    int compteur = 0;  // Variable membre (champ)
    string nom;        // Autre variable membre

    void Methode1()
    {
        compteur++;          // OK - compteur est accessible ici
        nom = "Exemple";     // OK - nom est accessible ici
    }

    void Methode2()
    {
        Console.WriteLine(compteur);  // OK - compteur est accessible ici
        Console.WriteLine(nom);       // OK - nom est accessible ici
    }
}
```

#### 3. Variables de param√®tre

Les variables d√©clar√©es comme param√®tres d'une m√©thode ont une port√©e limit√©e au corps de cette m√©thode.

```csharp
void AfficherMessage(string message, int repetitions)
{
    // message et repetitions sont des variables de param√®tre
    for (int i = 0; i < repetitions; i++)
    {
        Console.WriteLine(message);
    }
}
```

### Masquage de variables (variable shadowing)

Lorsqu'une variable locale a le m√™me nom qu'une variable membre, la variable locale "masque" la variable membre dans sa port√©e. C'est g√©n√©ralement une source de confusion √† √©viter.

```csharp
class MaClasse
{
    int compteur = 0;  // Variable membre

    void Methode()
    {
        int compteur = 5;  // Variable locale qui masque la variable membre
        Console.WriteLine(compteur);  // Affiche 5 (variable locale)

        // Pour acc√©der √† la variable membre, utilisez "this"
        Console.WriteLine(this.compteur);  // Affiche 0 (variable membre)
    }
}
```

### Port√©e et dur√©e de vie

Ne confondez pas la port√©e (o√π la variable est accessible) avec la dur√©e de vie (combien de temps elle existe en m√©moire) :

- Les variables locales existent uniquement pendant l'ex√©cution du bloc o√π elles sont d√©clar√©es.
- Les variables membres existent tant que l'instance de la classe existe.
- Les variables statiques existent pendant toute la dur√©e d'ex√©cution du programme.

```csharp
void ExemplePortee()
{
    // D√©but de la port√©e de x
    int x = 10;

    if (x > 5)
    {
        // D√©but de la port√©e de y
        int y = 20;
        Console.WriteLine(y);
        // Fin de la port√©e de y
    }

    // y n'est plus accessible ici, mais x l'est
    Console.WriteLine(x);
    // Fin de la port√©e de x
}
```

## 2.3.3 Conversion de types (cast implicite/explicite)

Souvent, vous aurez besoin de convertir une valeur d'un type √† un autre. C# offre deux types de conversions : implicites et explicites.

### Conversions implicites

Les conversions implicites sont automatiques et ne n√©cessitent pas de syntaxe sp√©ciale. Elles sont permises lorsqu'il n'y a pas de risque de perte de donn√©es.

```csharp
// Conversions implicites
int nombre = 10;
long grandNombre = nombre;       // int ‚Üí long (OK, pas de perte possible)

char caractere = 'A';
int valeurASCII = caractere;     // char ‚Üí int (OK, le code ASCII est un entier)

float petit = 3.14f;
double grand = petit;            // float ‚Üí double (OK, double a plus de pr√©cision)
```

#### Cas courants de conversions implicites :

- `byte` ‚Üí `short` ‚Üí `int` ‚Üí `long` ‚Üí `decimal`
- `int` ‚Üí `double`
- `float` ‚Üí `double`
- N'importe quel type num√©rique ‚Üí `string` (via la concat√©nation)
- Tout type ‚Üí `object` (boxing)

### Conversions explicites (cast)

Les conversions explicites (ou casts) sont n√©cessaires lorsqu'il y a un risque de perte de donn√©es. Vous devez indiquer explicitement au compilateur que vous √™tes conscient de ce risque.

```csharp
// Conversions explicites (casts)
double nombre = 3.14;
int partieEntiere = (int)nombre;     // double ‚Üí int (perte de la partie d√©cimale)
                                    // R√©sultat : 3

int grandNombre = 200;
byte petitNombre = (byte)grandNombre; // int ‚Üí byte (risque de d√©passement)
                                    // OK si la valeur tient dans un byte

long valeur = 1234567890L;
int valeurReduite = (int)valeur;     // long ‚Üí int (risque de d√©passement)
```

#### Syntaxe du cast :

```csharp
destinationType variable = (destinationType)sourceVariable;
```

### M√©thodes de conversion

C# fournit √©galement plusieurs m√©thodes pour effectuer des conversions de fa√ßon s√©curis√©e :

#### 1. Convert.ToXXX()

La classe `Convert` offre des m√©thodes pour convertir entre diff√©rents types :

```csharp
string nombreTexte = "123";
int nombre = Convert.ToInt32(nombreTexte);    // string ‚Üí int

bool valeur = Convert.ToBoolean(1);           // int ‚Üí bool (non-z√©ro = true)
double decimale = Convert.ToDouble("3,14");   // string ‚Üí double
```

#### 2. Parse et TryParse

Les m√©thodes `Parse` et `TryParse` sont utiles pour convertir des cha√Ænes en d'autres types :

```csharp
// Parse - l√®ve une exception si √©chec
string nombreTexte = "123";
int nombre = int.Parse(nombreTexte);      // OK

// TryParse - plus s√ªr, ne l√®ve pas d'exception
string texte = "abc";
bool succes = int.TryParse(texte, out int resultat);
// succes = false, resultat = 0
```

> **üí° Conseil :** Utilisez toujours `TryParse` plut√¥t que `Parse` pour les entr√©es utilisateur afin d'√©viter les exceptions.

#### 3. ToString()

Pour convertir n'importe quel type en cha√Æne, utilisez la m√©thode `ToString()` :

```csharp
int nombre = 42;
string texte = nombre.ToString();      // "42"

double pi = 3.14159;
string piTexte = pi.ToString("F2");    // "3.14" (format √† 2 d√©cimales)
```

### Risques et pi√®ges

#### D√©passement (overflow)

Lors de la conversion d'un type plus large vers un type plus √©troit, il y a un risque de d√©passement :

```csharp
int grandNombre = 1000;
byte petitNombre = (byte)grandNombre;   // D√©passement : 1000 ne tient pas dans un byte (max 255)
                                       // R√©sultat : 232 (1000 % 256)
```

#### Perte de pr√©cision

Lors de la conversion de types √† virgule flottante vers des entiers, la partie d√©cimale est tronqu√©e :

```csharp
double d = 3.99;
int i = (int)d;    // R√©sultat : 3 (pas d'arrondi !)
```

#### Erreurs de format

Lors de la conversion de cha√Ænes, assurez-vous que le format est correct :

```csharp
// G√©n√®re une FormatException
string texte = "abc";
int nombre = int.Parse(texte);    // Erreur !
```

## 2.3.4 var et inf√©rence de type

L'inf√©rence de type permet au compilateur de d√©terminer automatiquement le type d'une variable √† partir de son initialisation. En C#, cela se fait √† l'aide du mot-cl√© `var`.

### Utilisation de var

```csharp
// Au lieu de d√©clarer explicitement le type :
string message = "Bonjour";

// Vous pouvez utiliser var :
var message = "Bonjour";    // Le compilateur inf√®re que message est de type string
```

Le compilateur d√©termine que `message` est de type `string` car il est initialis√© avec une cha√Æne de caract√®res.

### Important √† savoir sur var

- `var` **n'est pas** un type dynamique. Le type est d√©termin√© √† la compilation, pas √† l'ex√©cution.
- La variable doit √™tre initialis√©e imm√©diatement (sur la m√™me ligne).
- Une fois le type inf√©r√©, il ne peut pas √™tre modifi√©.
- `var` ne peut √™tre utilis√© que pour les variables locales, pas pour les champs de classe, les param√®tres ou les retours de m√©thode.

```csharp
// Correct
var age = 25;              // age est de type int
var nom = "Alice";         // nom est de type string
var liste = new List<int>(); // liste est de type List<int>

// Incorrect
var x;                     // Erreur : pas d'initialisation
var y = null;              // Erreur : impossible d'inf√©rer le type
```

### Quand utiliser var ?

`var` est particuli√®rement utile dans les cas suivants :

1. **Types longs ou complexes** :
```csharp
// Sans var
Dictionary<string, List<Customer>> clientsParVille = new Dictionary<string, List<Customer>>();

// Avec var (plus lisible)
var clientsParVille = new Dictionary<string, List<Customer>>();
```

2. **R√©sultats de requ√™tes LINQ** :
```csharp
var resultats = from c in clients
                where c.Age > 30
                select new { c.Nom, c.Age };
```

3. **Quand le type est √©vident** :
```csharp
var message = "Bonjour";   // Clairement une cha√Æne
var nombre = 42;           // Clairement un entier
var liste = new List<int>(); // Clairement une liste d'entiers
```

### Contre-indications

√âvitez `var` quand :
- Le type n'est pas √©vident √† partir de l'initialisation
- La lisibilit√© du code en souffre
- Vous travaillez dans du code qui doit √™tre particuli√®rement explicite

```csharp
// √Ä √©viter
var result = GetData();    // Quel est le type de result ?

// Pr√©f√©rez
SomeSpecificType result = GetData();
```

### var vs dynamic

Ne confondez pas `var` avec `dynamic` :
- `var` : Type d√©termin√© √† la compilation. Fort typage.
- `dynamic` : Type d√©termin√© √† l'ex√©cution. Typage dynamique.

```csharp
var x = 10;      // x est un int, d√©termin√© √† la compilation
x = "texte";     // Erreur de compilation

dynamic y = 10;  // y peut changer de type √† l'ex√©cution
y = "texte";     // OK avec dynamic (mais peut causer des erreurs √† l'ex√©cution)
```

## 2.3.5 readonly et const

C# offre deux fa√ßons principales de cr√©er des valeurs qui ne peuvent pas √™tre modifi√©es : `readonly` et `const`. Bien qu'ils servent un objectif similaire, ils ont des diff√©rences importantes.

### Constantes (const)

Une constante est une valeur d√©termin√©e √† la compilation et qui ne peut jamais changer.

#### Caract√©ristiques des constantes :

- Doivent √™tre initialis√©es au moment de la d√©claration
- Leur valeur est d√©termin√©e √† la compilation
- Ne peuvent contenir que des types primitifs (int, string, etc.) et des expressions constantes
- Sont implicitement statiques (appartiennent √† la classe, pas √† une instance)

```csharp
class MaClasse
{
    // Exemples de constantes
    public const int AGE_MINIMUM = 18;
    public const string MESSAGE_ACCUEIL = "Bienvenue !";
    public const double PI = 3.14159;

    // Expressions constantes
    public const int DOUBLE_AGE = AGE_MINIMUM * 2;

    // Erreur - DateTime n'est pas un type primitif
    // public const DateTime DATE_CREATION = new DateTime(2023, 1, 1);
}
```

#### Utilisation des constantes :

```csharp
// Acc√®s depuis l'ext√©rieur de la classe
int age = MaClasse.AGE_MINIMUM;    // Notez l'acc√®s via le nom de la classe
```

### Variables en lecture seule (readonly)

Une variable `readonly` est une variable dont la valeur ne peut √™tre modifi√©e qu'au moment de sa d√©claration ou dans un constructeur.

#### Caract√©ristiques des variables readonly :

- Peuvent √™tre initialis√©es au moment de la d√©claration ou dans un constructeur
- Leur valeur est d√©termin√©e √† l'ex√©cution (runtime)
- Peuvent √™tre de n'importe quel type
- Par d√©faut, appartiennent √† une instance de la classe (sauf si d√©clar√©es static)

```csharp
class MaClasse
{
    // Exemples de variables readonly
    public readonly int Id;
    public readonly DateTime DateCreation;
    public static readonly List<string> Categories = new List<string> { "A", "B", "C" };

    // Initialisation dans le constructeur
    public MaClasse(int id)
    {
        Id = id;  // OK - dans le constructeur
        DateCreation = DateTime.Now;  // OK - dans le constructeur
    }

    public void ModifierDonnees()
    {
        // Id = 100;  // Erreur - ne peut pas √™tre modifi√© en dehors du constructeur

        // En revanche, on peut modifier le contenu d'un objet readonly
        Categories.Add("D");  // OK - on modifie le contenu, pas la r√©f√©rence
    }
}
```

### Diff√©rences cl√©s entre const et readonly

| Caract√©ristique | const | readonly |
|----------------|-------|----------|
| **Moment de l'initialisation** | D√©claration uniquement | D√©claration ou constructeur |
| **Moment de l'√©valuation** | Compilation | Ex√©cution |
| **Types autoris√©s** | Types primitifs et expressions constantes | Tous types |
| **Statique/Instance** | Toujours statique | Peut √™tre statique ou d'instance |
| **Modification du contenu** | N/A | Possible pour les types r√©f√©rence |

### Quand utiliser const vs readonly ?

- Utilisez **const** pour des valeurs vraiment constantes qui ne changeront jamais (œÄ, constantes math√©matiques, valeurs de configuration fixes).
- Utilisez **readonly** pour des valeurs qui :
  - Doivent √™tre d√©termin√©es √† l'ex√©cution
  - Sont calcul√©es dans le constructeur
  - Sont des types complexes (objets, collections)
  - Doivent √™tre diff√©rentes pour chaque instance

```csharp
class Exemple
{
    // Bon usage de const
    public const double PI = 3.14159;
    public const int JOURS_SEMAINE = 7;

    // Bon usage de readonly
    public readonly Guid Id = Guid.NewGuid();    // Valeur unique par instance
    public readonly DateTime DateCreation = DateTime.Now;
    public static readonly HttpClient Client = new HttpClient();    // Ressource partag√©e
}
```

### readonly vs read-only properties

Ne confondez pas les champs `readonly` avec les propri√©t√©s en lecture seule :

```csharp
class Exemple
{
    // Champ readonly
    private readonly int _id;

    // Propri√©t√© en lecture seule
    public int Id { get; }    // Propri√©t√© avec getter uniquement

    // Autre fa√ßon de d√©finir une propri√©t√© en lecture seule
    public string Nom
    {
        get { return "Exemple"; }
    }

    public Exemple(int id)
    {
        _id = id;
        Id = id;    // OK - initialisation dans le constructeur
    }
}
```

La principale diff√©rence est que les propri√©t√©s en lecture seule peuvent √™tre initialis√©es dans des m√©thodes, alors que les champs `readonly` ne peuvent √™tre initialis√©s que dans leur d√©claration ou dans un constructeur.

## R√©sum√©

- Les **variables** sont des espaces nomm√©s en m√©moire qui stockent des valeurs. Elles doivent √™tre d√©clar√©es avec un type et peuvent √™tre initialis√©es.
- La **port√©e d'une variable** d√©finit o√π elle est accessible dans le code, g√©n√©ralement d√©termin√©e par les accolades `{}`.
- Les **conversions de types** permettent de transformer une valeur d'un type √† un autre :
  - Les conversions implicites sont automatiques et s√ªres
  - Les conversions explicites (casts) n√©cessitent une syntaxe sp√©ciale et peuvent entra√Æner des pertes de donn√©es
- Le mot-cl√© **var** permet l'inf√©rence de type, o√π le compilateur d√©termine le type √† partir de l'initialisation.
- Pour les valeurs immuables :
  - **const** est utilis√© pour des valeurs constantes connues √† la compilation
  - **readonly** est utilis√© pour des valeurs qui ne peuvent √™tre initialis√©es que dans le constructeur

La compr√©hension de ces concepts vous permettra de mieux g√©rer les donn√©es dans vos programmes C# et d'√©viter des erreurs courantes li√©es √† la manipulation des variables.
