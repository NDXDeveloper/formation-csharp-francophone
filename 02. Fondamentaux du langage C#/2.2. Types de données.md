# 2.2 Types de donn√©es en C#

Les types de donn√©es sont un concept fondamental en programmation. Ils d√©finissent la nature des donn√©es que nous manipulons et d√©terminent comment ces donn√©es sont stock√©es en m√©moire. En C#, comprendre les diff√©rents types de donn√©es est essentiel pour √©crire du code efficace et √©viter les erreurs.

## 2.2.1 Types primitifs (int, float, bool, etc.)

Les types primitifs (ou types simples) sont les blocs de construction fondamentaux pour stocker des donn√©es en C#. Ils repr√©sentent des valeurs simples comme des nombres, des caract√®res ou des valeurs bool√©ennes.

### Types num√©riques entiers

Ces types stockent des nombres entiers (sans partie d√©cimale) :

| Type | Taille (octets) | Plage de valeurs | Utilisation |
|------|----------------|------------------|-------------|
| `sbyte` | 1 | -128 √† 127 | Tr√®s petits nombres entiers (sign√©s) |
| `byte` | 1 | 0 √† 255 | Tr√®s petits nombres entiers (non sign√©s) |
| `short` | 2 | -32 768 √† 32 767 | Petits nombres entiers |
| `ushort` | 2 | 0 √† 65 535 | Petits nombres entiers (non sign√©s) |
| `int` | 4 | -2 147 483 648 √† 2 147 483 647 | Nombres entiers (usage courant) |
| `uint` | 4 | 0 √† 4 294 967 295 | Nombres entiers (non sign√©s) |
| `long` | 8 | -9 223 372 036 854 775 808 √† 9 223 372 036 854 775 807 | Tr√®s grands nombres entiers |
| `ulong` | 8 | 0 √† 18 446 744 073 709 551 615 | Tr√®s grands nombres entiers (non sign√©s) |

```csharp
int age = 25;
long populationMondiale = 8000000000L; // Le L indique un litt√©ral de type long
byte octet = 255;
```

### Types num√©riques √† virgule flottante

Ces types stockent des nombres avec une partie d√©cimale :

| Type | Taille (octets) | Pr√©cision | Utilisation |
|------|----------------|-----------|-------------|
| `float` | 4 | ~7 chiffres | Pr√©cision simple (valeurs approch√©es) |
| `double` | 8 | ~15-16 chiffres | Pr√©cision double (valeurs approch√©es) |
| `decimal` | 16 | 28-29 chiffres | Haute pr√©cision (calculs financiers) |

```csharp
float distance = 23.5f;      // Le f indique un litt√©ral de type float
double pi = 3.14159265359;   // Par d√©faut, les d√©cimaux sont des double
decimal prix = 19.99m;       // Le m indique un litt√©ral de type decimal
```

> **üîç Note pour les d√©butants:**
> Les types `float` et `double` peuvent avoir des probl√®mes de pr√©cision avec certaines valeurs d√©cimales (comme 0.1 ou 0.2). Pour les calculs financiers ou lorsque la pr√©cision est critique, utilisez toujours `decimal`.

### Type bool√©en

Le type `bool` repr√©sente une valeur logique qui peut √™tre soit vraie (`true`), soit fausse (`false`) :

```csharp
bool estMajeur = true;
bool estConnecte = false;
```

### Type caract√®re

Le type `char` repr√©sente un caract√®re Unicode unique (lettre, chiffre, symbole, etc.) :

```csharp
char premiereLettreAlphabet = 'a';
char symboleEtoile = '*';
char lettreMajuscule = 'A';
```

Les caract√®res sont entour√©s de guillemets simples (`'`), contrairement aux cha√Ænes de caract√®res qui utilisent des guillemets doubles (`"`).

### Litt√©raux et pr√©fixes/suffixes

Pour indiquer explicitement le type d'un litt√©ral, vous pouvez utiliser des suffixes :

```csharp
// Suffixes pour les nombres entiers
int n1 = 42;       // int par d√©faut
long n2 = 42L;     // L pour long
uint n3 = 42U;     // U pour unsigned
ulong n4 = 42UL;   // UL pour unsigned long

// Suffixes pour les nombres d√©cimaux
float f1 = 3.14F;  // F ou f pour float
double d1 = 3.14;  // Double par d√©faut (pas de suffixe n√©cessaire)
decimal m1 = 3.14M; // M ou m pour decimal
```

### Conversions entre types num√©riques

Il existe deux types de conversions entre types num√©riques :

1. **Conversions implicites** (s√ªres, pas de perte de donn√©es) :
   ```csharp
   int petitNombre = 10;
   long grandNombre = petitNombre;  // Conversion implicite de int vers long
   ```

2. **Conversions explicites** (cast, possibilit√© de perte de donn√©es) :
   ```csharp
   long grandNombre = 1234567890L;
   int petitNombre = (int)grandNombre;  // Conversion explicite, risque de perte de donn√©es
   ```

> **‚ö†Ô∏è Attention aux d√©bordements :**
> Si vous convertissez un nombre vers un type qui ne peut pas le contenir, vous obtiendrez un d√©bordement (overflow). Par exemple, essayer de stocker 300 dans un `byte` provoquera un d√©bordement.

## 2.2.2 Types r√©f√©rence vs types valeur

En C#, tous les types de donn√©es sont class√©s soit comme **types valeur**, soit comme **types r√©f√©rence**. Cette distinction est fondamentale car elle affecte la mani√®re dont les variables sont stock√©es en m√©moire et pass√©es aux m√©thodes.

### Types valeur

Les types valeur stockent directement leurs donn√©es en m√©moire. Ils sont g√©n√©ralement allou√©s sur la pile (stack).

**Caract√©ristiques des types valeur :**
- Stockent directement leurs donn√©es
- Une variable contient la valeur elle-m√™me
- Copi√©s lors d'affectations ou de passages en param√®tre
- G√©n√©ralement plus rapides d'acc√®s
- Ne peuvent pas √™tre `null` (sauf les types nullables, voir section 2.2.5)

**Types valeur en C# :**
- Tous les types primitifs num√©riques (`int`, `float`, `double`, etc.)
- `bool` et `char`
- `struct` (structures personnalis√©es)
- `enum` (√©num√©rations)

```csharp
int a = 10;
int b = a;  // Une copie de la valeur est cr√©√©e
b = 20;     // Modifier b n'affecte pas a
Console.WriteLine(a);  // Affiche 10
Console.WriteLine(b);  // Affiche 20
```

### Types r√©f√©rence

Les types r√©f√©rence stockent une r√©f√©rence (adresse m√©moire) vers l'objet r√©el qui est allou√© sur le tas (heap).

**Caract√©ristiques des types r√©f√©rence :**
- Stockent une r√©f√©rence vers les donn√©es
- Une variable contient l'adresse de l'objet, pas l'objet lui-m√™me
- Lors d'affectation ou de passage en param√®tre, seule la r√©f√©rence est copi√©e
- Peuvent √™tre `null` (absence de r√©f√©rence)
- Nettoy√©s par le garbage collector quand plus aucune r√©f√©rence ne pointe vers eux

**Types r√©f√©rence en C# :**
- Classes (`class`)
- Interfaces (`interface`)
- D√©l√©gu√©s (`delegate`)
- Tableaux (`array`)
- Cha√Ænes de caract√®res (`string`) - cas particulier, voir section 2.2.3

```csharp
// Exemple avec une classe (type r√©f√©rence)
class Personne
{
    public string Nom;
}

// Dans une m√©thode
Personne p1 = new Personne();
p1.Nom = "Alice";

Personne p2 = p1;  // p2 et p1 pointent vers le m√™me objet
p2.Nom = "Bob";    // Modifier via p2 affecte aussi p1

Console.WriteLine(p1.Nom);  // Affiche "Bob"
Console.WriteLine(p2.Nom);  // Affiche "Bob"
```

### Diff√©rence de comportement - Illustration visuelle

![Types valeur vs Types r√©f√©rence](https://i.imgur.com/JVaOcTE.png)

> **üìù Note importante :**
> Comprendre la diff√©rence entre types valeur et types r√©f√©rence est crucial pour √©viter des bugs subtils dans votre code, notamment lors du passage de param√®tres √† des m√©thodes.

### Passage de param√®tres (par valeur ou par r√©f√©rence)

Par d√©faut, C# passe les param√®tres par valeur, ce qui signifie :
- Pour les types valeur : une copie de la valeur est pass√©e
- Pour les types r√©f√©rence : une copie de la r√©f√©rence est pass√©e (mais les deux pointent vers le m√™me objet)

Les mots-cl√©s `ref` et `out` permettent de modifier ce comportement :

```csharp
// Passage par r√©f√©rence avec ref
void DoubleNombre(ref int n)
{
    n = n * 2;
}

int x = 5;
DoubleNombre(ref x);
Console.WriteLine(x);  // Affiche 10, x a √©t√© modifi√©
```

## 2.2.3 Cha√Ænes de caract√®res et leurs m√©thodes

Les cha√Ænes de caract√®res (`string`) sont un type de donn√©es fondamental qui repr√©sente une s√©quence de caract√®res. Bien que techniquement un type r√©f√©rence, les cha√Ænes ont un comportement sp√©cial en C#.

### Cr√©ation de cha√Ænes

```csharp
// Diff√©rentes fa√ßons de cr√©er des cha√Ænes
string nom = "Alice";
string message = "Bonjour, comment allez-vous ?";
string vide = "";
string chemin = @"C:\Users\Documents\fichier.txt";  // Cha√Æne verbatim (@ ignore les s√©quences d'√©chappement)
string multiligne = @"Ligne 1
Ligne 2
Ligne 3";  // Cha√Æne multiligne
```

### Caract√©ristiques sp√©ciales des cha√Ænes

- Les cha√Ænes sont **immuables** : une fois cr√©√©e, une cha√Æne ne peut pas √™tre modifi√©e. Toute op√©ration qui semble modifier une cha√Æne cr√©e en r√©alit√© une nouvelle cha√Æne.
- L'op√©rateur `+` permet de concat√©ner des cha√Ænes.
- Les cha√Ænes peuvent √™tre compar√©es avec `==` et `!=` pour v√©rifier l'√©galit√© de contenu.
- Les cha√Ænes peuvent √™tre nulles (`null`), contrairement aux types valeur.

```csharp
string a = "Bonjour";
string b = a;

a = a + " le monde";  // Cr√©e une nouvelle cha√Æne "Bonjour le monde" et l'assigne √† a
Console.WriteLine(a);  // Affiche "Bonjour le monde"
Console.WriteLine(b);  // Affiche toujours "Bonjour"
```

### M√©thodes et propri√©t√©s utiles

Les cha√Ænes offrent de nombreuses m√©thodes pour manipuler et analyser le texte :

```csharp
string texte = "  Exemple de cha√Æne √† manipuler  ";

// Propri√©t√©s
int longueur = texte.Length;  // 32 (espaces inclus)

// Acc√®s aux caract√®res individuels
char premierChar = texte[2];  // 'E'

// Recherche
bool contient = texte.Contains("cha√Æne");  // true
int position = texte.IndexOf("de");  // 10
int dernierE = texte.LastIndexOf("e");  // 27

// Modification (cr√©e de nouvelles cha√Ænes)
string sansBlancs = texte.Trim();  // "Exemple de cha√Æne √† manipuler"
string majuscules = texte.ToUpper();  // "  EXEMPLE DE CHA√éNE √Ä MANIPULER  "
string minuscules = texte.ToLower();  // "  exemple de cha√Æne √† manipuler  "
string remplace = texte.Replace("cha√Æne", "texte");  // "  Exemple de texte √† manipuler  "

// Extraction
string sousChaine = texte.Substring(10, 10);  // "de cha√Æne "

// Division
string[] mots = texte.Split(' ', StringSplitOptions.RemoveEmptyEntries);  // ["Exemple", "de", "cha√Æne", "√†", "manipuler"]

// V√©rification
bool commence = texte.StartsWith("  Ex");  // true
bool termine = texte.EndsWith("er  ");  // true
bool estVide = string.IsNullOrEmpty(texte);  // false
bool estBlancOuVide = string.IsNullOrWhiteSpace(texte);  // false
```

### Interpolation de cha√Ænes

L'interpolation de cha√Ænes (depuis C# 6.0) permet d'ins√©rer des expressions directement dans des cha√Ænes de caract√®res en utilisant le pr√©fixe `$` :

```csharp
string prenom = "Marie";
int age = 30;
string message = $"Bonjour, je m'appelle {prenom} et j'ai {age} ans.";
// Message contient : "Bonjour, je m'appelle Marie et j'ai 30 ans."
```

### StringBuilder - pour les modifications fr√©quentes

Lorsque vous devez effectuer de nombreuses modifications sur une cha√Æne (dans une boucle par exemple), utilisez `StringBuilder` pour am√©liorer les performances :

```csharp
using System.Text;

StringBuilder sb = new StringBuilder();
for (int i = 0; i < 100; i++)
{
    sb.Append($"Ligne {i}\n");  // Plus efficace que concat√©nation
}
string resultat = sb.ToString();
```

## 2.2.4 Boxing et unboxing

Le boxing et l'unboxing sont des m√©canismes qui permettent de convertir des types valeur en types r√©f√©rence et vice-versa. Ces op√©rations sont importantes √† comprendre car elles peuvent affecter les performances de votre application.

### Boxing (mise en bo√Æte)

Le **boxing** est la conversion d'un type valeur en type r√©f√©rence. Lors du boxing, la valeur est encapsul√©e dans un objet et stock√©e sur le tas (heap).

```csharp
int nombre = 42;           // Type valeur sur la pile
object obj = nombre;       // Boxing : conversion implicite vers object (sur le tas)
```

### Unboxing (d√©ballage)

L'**unboxing** est l'op√©ration inverse : extraire la valeur d'un objet box√© et la convertir en type valeur.

```csharp
object obj = 42;          // Valeur box√©e (r√©f√©rence)
int nombre = (int)obj;    // Unboxing : conversion explicite vers int
```

### Implications du boxing/unboxing

Ces op√©rations ont plusieurs implications :

1. **Performance** : Le boxing et l'unboxing sont co√ªteux en termes de performance car ils impliquent des allocations m√©moire et des copies.

2. **Risques d'erreurs** : L'unboxing peut provoquer des exceptions si le type r√©el de l'objet ne correspond pas au type attendu.

```csharp
object obj = "texte";   // obj contient une cha√Æne, pas un nombre
int nombre = (int)obj;  // ‚ö†Ô∏è InvalidCastException
```

3. **Perte de type** : Lors du boxing, les informations de type sp√©cifiques peuvent √™tre perdues.

### Exemple pratique

```csharp
// Collection non g√©n√©rique (utilise Object)
System.Collections.ArrayList liste = new System.Collections.ArrayList();

// Boxing implicite lors de l'ajout (int ‚Üí object)
liste.Add(10);
liste.Add(20);
liste.Add(30);

// Unboxing explicite lors de la r√©cup√©ration
int premier = (int)liste[0];

// Alternative sans boxing avec les collections g√©n√©riques
List<int> listeGenerique = new List<int>();
listeGenerique.Add(10);  // Pas de boxing ici
int valeur = listeGenerique[0];  // Pas d'unboxing
```

> **üí° Conseil :**
> Pour √©viter les probl√®mes de performance li√©s au boxing/unboxing, privil√©giez les collections g√©n√©riques (comme `List<T>`) plut√¥t que les collections non g√©n√©riques (comme `ArrayList`).

## 2.2.5 Types nullables et op√©rateurs associ√©s

Par d√©faut, les types valeur ne peuvent pas avoir la valeur `null`. Cependant, il existe des situations o√π vous pourriez vouloir repr√©senter l'absence de valeur, par exemple pour une date de naissance non renseign√©e ou un prix non d√©fini.

### Types nullables - D√©finition et syntaxe

Un type nullable est un type valeur qui peut √©galement prendre la valeur `null`. On le d√©clare en ajoutant un point d'interrogation (`?`) apr√®s le type.

```csharp
// Types non nullables (par d√©faut)
int compteur = 0;
bool estValide = false;
// compteur = null;  // ‚ùå Erreur de compilation

// Types nullables
int? compteurNullable = 0;
bool? estValideNullable = false;
compteurNullable = null;  // ‚úÖ Valide
estValideNullable = null;  // ‚úÖ Valide
```

### Propri√©t√©s des types nullables

Les types nullables disposent de deux propri√©t√©s importantes :

- `HasValue` : Retourne `true` si le type nullable contient une valeur (diff√©rente de `null`).
- `Value` : Retourne la valeur contenue (g√©n√®re une exception si la valeur est `null`).

```csharp
int? nombre = 42;

if (nombre.HasValue)
{
    int valeur = nombre.Value;  // Acc√®s s√©curis√© √† la valeur
    Console.WriteLine(valeur);  // Affiche 42
}

nombre = null;
// int valeur = nombre.Value;  // ‚ö†Ô∏è InvalidOperationException
```

### Op√©rateur de fusion null (`??`)

L'op√©rateur `??` (fusion null ou null-coalescing) permet de sp√©cifier une valeur par d√©faut √† utiliser lorsqu'un type nullable est `null`.

```csharp
int? a = null;
int b = a ?? 0;  // Si a est null, b prend la valeur 0

string nom = null;
string nomAffiche = nom ?? "Anonyme";  // Si nom est null, nomAffiche est "Anonyme"
```

### Op√©rateur de propagation null (`?.`)

L'op√©rateur `?.` (propagation null ou null-conditional) permet d'acc√©der en toute s√©curit√© √† un membre (propri√©t√©, m√©thode) d'un objet potentiellement null. Si l'objet est null, l'expression enti√®re devient null au lieu de g√©n√©rer une exception.

```csharp
// Sans l'op√©rateur ?., on doit v√©rifier manuellement
string texte = null;
int? longueur = null;

if (texte != null)
{
    longueur = texte.Length;
}

// Avec l'op√©rateur ?., c'est plus concis
longueur = texte?.Length;  // Si texte est null, longueur est null

// On peut encha√Æner les op√©rateurs
class Personne
{
    public Adresse Adresse { get; set; }
}

class Adresse
{
    public string Ville { get; set; }
}

Personne p = null;
string ville = p?.Adresse?.Ville;  // Null si p ou p.Adresse est null
```

### Combinaison des op√©rateurs `?.` et `??`

Ces op√©rateurs sont souvent utilis√©s ensemble pour acc√©der en toute s√©curit√© √† des propri√©t√©s et fournir des valeurs par d√©faut :

```csharp
Personne p = GetPersonne();  // Peut retourner null
string ville = p?.Adresse?.Ville ?? "Ville inconnue";
```

Dans cet exemple, `ville` vaudra "Ville inconnue" si `p` est null, si `p.Adresse` est null, ou si `p.Adresse.Ville` est null.

### Types nullables et C# 8.0+ : Nullable Reference Types

√Ä partir de C# 8.0, Microsoft a introduit les "Nullable Reference Types" qui permettent d'indiquer si un type r√©f√©rence peut ou non contenir null. Cette fonctionnalit√© aide √† pr√©venir les erreurs de r√©f√©rence nulle (`NullReferenceException`).

```csharp
// Avec nullable reference types activ√©s
string nonNullable = "texte";  // Ne devrait jamais √™tre null
string? nullable = null;       // Peut √™tre null

nonNullable = null;  // ‚ö†Ô∏è Warning du compilateur
```

Pour activer cette fonctionnalit√©, vous pouvez utiliser la directive `#nullable enable` ou la configurer au niveau du projet.

## R√©sum√©

- Les **types primitifs** sont les blocs de construction fondamentaux pour stocker des valeurs simples.
- Les **types valeur** stockent directement leurs donn√©es tandis que les **types r√©f√©rence** stockent une r√©f√©rence vers les donn√©es.
- Les **cha√Ænes de caract√®res** sont un type r√©f√©rence sp√©cial avec de nombreuses m√©thodes utiles.
- Le **boxing** et l'**unboxing** permettent de convertir entre types valeur et types r√©f√©rence, mais peuvent impacter les performances.
- Les **types nullables** permettent aux types valeur d'accepter la valeur `null`, avec des op√©rateurs associ√©s (`??` et `?.`) pour manipuler ces valeurs de mani√®re s√©curis√©e.

En ma√Ætrisant ces concepts, vous serez mieux √©quip√© pour choisir les types appropri√©s et √©viter les erreurs courantes dans vos programmes C#.
