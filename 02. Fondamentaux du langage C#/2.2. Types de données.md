 
# 2.2. Types de données

![Types de données en C#](https://via.placeholder.com/600x150?text=Types+de+donn%C3%A9es+en+C%23)

Les types de données sont les éléments fondamentaux qui permettent de représenter et manipuler différentes sortes d'informations dans un programme. C# est un langage fortement typé, ce qui signifie que chaque variable et chaque expression a un type bien défini. Cette caractéristique permet au compilateur de détecter de nombreuses erreurs dès la phase de compilation, renforçant ainsi la robustesse du code.

## 2.2.1. Types primitifs (int, float, bool, etc.)

C# dispose d'un ensemble de types de données primitifs intégrés qui correspondent aux types fondamentaux du système. Ces types sont directement pris en charge par le compilateur et représentent les blocs de construction de base pour toutes les opérations de données.

### Vue d'ensemble des types primitifs

| Type C# | Type .NET | Taille | Plage de valeurs | Description |
|---------|-----------|--------|-----------------|-------------|
| `bool`  | `System.Boolean` | 1 octet | `true` ou `false` | Valeur booléenne |
| `byte`  | `System.Byte` | 1 octet | 0 à 255 | Entier non signé 8 bits |
| `sbyte` | `System.SByte` | 1 octet | -128 à 127 | Entier signé 8 bits |
| `char`  | `System.Char` | 2 octets | U+0000 à U+FFFF | Caractère Unicode 16 bits |
| `short` | `System.Int16` | 2 octets | -32,768 à 32,767 | Entier signé 16 bits |
| `ushort`| `System.UInt16` | 2 octets | 0 à 65,535 | Entier non signé 16 bits |
| `int`   | `System.Int32` | 4 octets | -2,147,483,648 à 2,147,483,647 | Entier signé 32 bits |
| `uint`  | `System.UInt32` | 4 octets | 0 à 4,294,967,295 | Entier non signé 32 bits |
| `long`  | `System.Int64` | 8 octets | -9,223,372,036,854,775,808 à 9,223,372,036,854,775,807 | Entier signé 64 bits |
| `ulong` | `System.UInt64` | 8 octets | 0 à 18,446,744,073,709,551,615 | Entier non signé 64 bits |
| `float` | `System.Single` | 4 octets | ±1.5 × 10^−45 à ±3.4 × 10^38 | Nombre à virgule flottante 32 bits |
| `double`| `System.Double` | 8 octets | ±5.0 × 10^−324 à ±1.7 × 10^308 | Nombre à virgule flottante 64 bits |
| `decimal`| `System.Decimal` | 16 octets | ±1.0 × 10^−28 à ±7.9 × 10^28 | Nombre décimal 128 bits (haute précision) |

### Déclaration et initialisation

En C#, vous pouvez déclarer et initialiser des variables de types primitifs de plusieurs façons :

```
// Déclaration simple
int age;
double salaire;
bool estActif;

// Déclaration et initialisation
int compteur = 0;
double pi = 3.14159;
bool estTerminé = false;
char première = 'A';

// Déclaration multiple de variables du même type
int x = 10, y = 20, z = 30;

// Conversion explicite (cast)
double nombre = 15.75;
int partieEntière = (int)nombre;  // Résultat : 15
```


### Suffixes littéraux

Pour spécifier le type exact d'une valeur littérale, C# utilise des suffixes :

```
long grandNombre = 123456789L;  // L pour long
float petit = 12.34F;           // F pour float
decimal montant = 1234.56M;     // M pour decimal
uint positif = 1000U;           // U pour uint
ulong trèsPositif = 10000UL;    // UL pour ulong
```


### Limites et constantes spéciales

Chaque type numérique a des valeurs limites et parfois des constantes spéciales :

```
// Valeurs limites
int maxInt = int.MaxValue;      // 2,147,483,647
int minInt = int.MinValue;      // -2,147,483,648
double maxDouble = double.MaxValue;  // 1.7976931348623157 × 10^308

// Constantes spéciales pour les flottants
double infini = double.PositiveInfinity;
double pasUnNombre = double.NaN;  // Not a Number

// Vérification
bool estNaN = double.IsNaN(pasUnNombre);  // true
bool estInfini = double.IsInfinity(infini);  // true
```


### Différences entre .NET Framework 4.7.2 et .NET 8

Les types primitifs fondamentaux sont identiques entre .NET Framework 4.7.2 et .NET 8. Cependant, .NET 8 offre des améliorations de performance et des optimisations internes, notamment dans le traitement des nombres à virgule flottante et des opérations sur les chaînes de caractères.

## 2.2.2. Types référence vs types valeur

Une distinction fondamentale en C# concerne les types valeur et les types référence. Cette différence affecte la façon dont les variables sont stockées en mémoire et comment elles se comportent lorsqu'elles sont assignées ou passées en paramètres.

### Types valeur

Les types valeur stockent directement leurs données dans la pile (stack). Lorsque vous assignez un type valeur à une autre variable, une copie de la valeur est créée.

**Caractéristiques des types valeur :**
- Stockés directement dans la pile
- Affectation par copie de valeur
- Destruction automatique lorsqu'ils sortent de portée
- Ne peuvent pas être `null` (sauf s'ils sont déclarés comme types nullables)

**Types valeur en C# :**
- Tous les types primitifs (sauf `string`)
- Les structures (`struct`)
- Les énumérations (`enum`)
- Les tuples

Exemple de comportement des types valeur :

```
// Types valeur : comportement par copie
int a = 10;
int b = a;  // b reçoit une copie de la valeur de a
a = 20;     // Modifier a n'affecte pas b
Console.WriteLine($"a = {a}, b = {b}");  // Affiche: a = 20, b = 10

// Structures (également des types valeur)
struct Point
{
    public int X;
    public int Y;
}

Point p1 = new Point { X = 10, Y = 20 };
Point p2 = p1;  // p2 reçoit une copie de p1
p1.X = 30;      // Modifier p1 n'affecte pas p2
Console.WriteLine($"p1.X = {p1.X}, p2.X = {p2.X}");  // Affiche: p1.X = 30, p2.X = 10
```


### Types référence

Les types référence stockent une référence (adresse mémoire) qui pointe vers les données réelles stockées dans le tas (heap). Lorsque vous assignez un type référence, vous copiez la référence, pas les données.

**Caractéristiques des types référence :**
- Stockent une référence (pointeur) vers les données dans le tas
- Affectation par copie de référence
- Gérés par le garbage collector
- Peuvent être `null`

**Types référence en C# :**
- Les classes (`class`)
- Les interfaces (`interface`)
- Les délégués (`delegate`)
- Les tableaux (`array`)
- Les chaînes de caractères (`string`, bien que spécial)

Exemple de comportement des types référence :

```
// Types référence : comportement par référence
class Personne
{
    public string Nom;
    public int Age;
}

Personne p1 = new Personne { Nom = "Alice", Age = 30 };
Personne p2 = p1;  // p2 référence le même objet que p1
p1.Age = 31;       // Modifier p1 affecte également p2
Console.WriteLine($"p1.Age = {p1.Age}, p2.Age = {p2.Age}");  // Affiche: p1.Age = 31, p2.Age = 31

// Les tableaux sont des types référence
int[] tableau1 = { 1, 2, 3 };
int[] tableau2 = tableau1;   // tableau2 référence le même tableau que tableau1
tableau1[0] = 99;            // Modifier tableau1 affecte également tableau2
Console.WriteLine($"tableau1[0] = {tableau1[0]}, tableau2[0] = {tableau2[0]}");  // Affiche: tableau1[0] = 99, tableau2[0] = 99
```


### Différences pratiques et implications

Comprendre la différence entre types valeur et types référence est crucial pour éviter des bugs subtils :

```
// Passage de paramètres
public void ModifierValeur(int x)
{
    x = 100;  // N'affecte que la copie locale
}

public void ModifierReference(Personne p)
{
    p.Age = 100;  // Affecte l'objet original
}

int nombre = 5;
ModifierValeur(nombre);
Console.WriteLine(nombre);  // Affiche: 5 (inchangé)

Personne jean = new Personne { Nom = "Jean", Age = 25 };
ModifierReference(jean);
Console.WriteLine(jean.Age);  // Affiche: 100 (modifié)
```


### Le cas spécial de `string`

Bien que `string` soit un type référence, il possède des caractéristiques spéciales :

- Les chaînes sont immuables (ne peuvent pas être modifiées après création)
- Les littéraux de chaîne identiques peuvent partager la même instance en mémoire (string interning)
- Les opérations qui semblent modifier une chaîne créent en réalité une nouvelle chaîne

```
string a = "hello";
string b = a;
a = a + " world";  // Crée une nouvelle chaîne, ne modifie pas l'originale
Console.WriteLine(a);  // Affiche: hello world
Console.WriteLine(b);  // Affiche: hello (inchangé)
```


## 2.2.3. Chaînes de caractères et leurs méthodes

Les chaînes de caractères (`string`) sont l'un des types de données les plus utilisés en programmation. En C#, elles offrent de nombreuses méthodes et fonctionnalités puissantes.

### Création et initialisation

```
// Différentes façons de créer des chaînes
string message1 = "Bonjour";
string message2 = new string('A', 5);        // "AAAAA"
string message3 = string.Empty;              // Chaîne vide ""
string message4 = null;                      // Chaîne nulle

// Concaténation
string nomComplet = "Jean" + " " + "Dupont"; // "Jean Dupont"

// Interpolation (C# 6+)
string nom = "Marie";
int age = 30;
string présentation = $"{nom} a {age} ans";  // "Marie a 30 ans"

// Chaînes textuelles littérales (C# 11+, .NET 7+)
string chemin = @"C:\Users\Documents\Fichiers";  // Pas besoin d'échapper les \
string requêteSQL = @"
    SELECT *
    FROM Utilisateurs
    WHERE Age > 18";  // Préserve les sauts de ligne

// Chaînes brutes (Raw string literals, C# 11+, .NET 7+)
string json = """
    {
        "nom": "Jean",
        "age": 30,
        "adresse": {
            "rue": "123 Rue Principale",
            "ville": "Paris"
        }
    }
    """;
```


### Méthodes communes pour les chaînes

Les chaînes en C# disposent d'une riche bibliothèque de méthodes :

```
string texte = "Bonjour le monde";

// Longueur
int longueur = texte.Length;  // 17

// Accès aux caractères (par index)
char premier = texte[0];      // 'B'
char dernier = texte[texte.Length - 1];  // 'e'

// Recherche
bool contient = texte.Contains("monde");      // true
int position = texte.IndexOf("le");           // 8
int dernière = texte.LastIndexOf("o");        // 11
bool commence = texte.StartsWith("Bonjour");  // true
bool termine = texte.EndsWith("Monde");       // false (sensible à la casse)

// Modification (crée de nouvelles chaînes)
string majuscules = texte.ToUpper();          // "BONJOUR LE MONDE"
string minuscules = texte.ToLower();          // "bonjour le monde"
string remplacé = texte.Replace("monde", "C#");  // "Bonjour le C#"
string taillé = texte.Trim();                 // Supprime les espaces au début et à la fin
string extrait = texte.Substring(8, 2);       // "le"

// Division
string[] mots = texte.Split(' ');             // ["Bonjour", "le", "monde"]

// Jointure
string[] fruits = { "pomme", "orange", "banane" };
string liste = string.Join(", ", fruits);     // "pomme, orange, banane"

// Vérifications
bool estVide = string.IsNullOrEmpty(texte);           // false
bool estBlanche = string.IsNullOrWhiteSpace(texte);   // false

// Formattage
string formaté = string.Format("Prix: {0:C2}", 29.99);  // "Prix: 29,99 €" (dépend de la culture)
```


### Chaînes et performances

Comme les chaînes sont immuables, les opérations répétées de concaténation peuvent être inefficaces. Pour les scénarios où vous construisez des chaînes dynamiquement, utilisez `StringBuilder` :

```
using System.Text;

// Inefficace pour de nombreuses concaténations
string résultat = "";
for (int i = 0; i < 10000; i++)
{
    résultat += i + ", ";  // Crée une nouvelle chaîne à chaque itération
}

// Beaucoup plus efficace
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++)
{
    sb.Append(i).Append(", ");
}
string résultatOptimisé = sb.ToString();
```


### Comparaison de chaînes

La comparaison de chaînes nécessite une attention particulière en raison des considérations de casse et de culture :

```
string s1 = "hello";
string s2 = "HELLO";

// Comparaison par défaut (sensible à la casse)
bool égal1 = (s1 == s2);                      // false
bool égal2 = s1.Equals(s2);                   // false

// Comparaison insensible à la casse
bool égal3 = s1.Equals(s2, StringComparison.OrdinalIgnoreCase);  // true

// Comparaison avec culture
bool égal4 = string.Compare(s1, s2, CultureInfo.CurrentCulture,
                           CompareOptions.IgnoreCase) == 0;  // true

// Ordre alphabétique
int ordre = string.Compare(s1, s2);  // Valeur négative (s1 vient avant s2 en ordre alphabétique)
```


### Différences entre .NET Framework 4.7.2 et .NET 8

.NET 8 introduit plusieurs améliorations pour les chaînes :

- **Performance** : Optimisations des opérations sur les chaînes
- **Nouvelles méthodes** : Méthodes d'extension supplémentaires comme `Contains` avec `StringComparison`
- **Chaînes brutes** (C# 11+) : Syntaxe simplifiée pour les chaînes multi-lignes avec délimiteurs
- **Interpolation améliorée** : Nouvelles options de formatage et de mise en forme

```
// En .NET 8
string recherche = "monde";
bool trouvé = texte.Contains(recherche, StringComparison.OrdinalIgnoreCase);  // true

// En .NET Framework 4.7.2, il fallait utiliser:
bool trouvé472 = texte.IndexOf(recherche, StringComparison.OrdinalIgnoreCase) >= 0;
```


## 2.2.4. Boxing et unboxing

Le boxing et l'unboxing sont des opérations qui permettent de convertir entre types valeur et types référence. Ces opérations sont importantes à comprendre car elles peuvent avoir un impact significatif sur les performances.

### Boxing

Le boxing est le processus de conversion d'un type valeur en type référence. Concrètement, cela signifie qu'une valeur stockée sur la pile est encapsulée dans un objet sur le tas.

```
int nombre = 123;  // Type valeur (stocké sur la pile)
object obj = nombre;  // Boxing : crée un objet sur le tas contenant la valeur 123
```


Quand le boxing se produit :
- Une allocation mémoire a lieu sur le tas
- La valeur est copiée de la pile vers cette nouvelle allocation
- La référence à cet objet est retournée

### Unboxing

L'unboxing est le processus inverse : extraire la valeur d'un objet boxé pour la convertir en type valeur.

```
object obj = 123;       // Un entier boxé
int nombre = (int)obj;  // Unboxing : extrait la valeur du tas vers la pile
```


L'unboxing nécessite :
- Vérification du type à l'exécution
- Extraction de la valeur de l'objet
- Copie de cette valeur sur la pile

### Implications de performance

Le boxing et l'unboxing peuvent avoir un impact significatif sur les performances, surtout dans des scénarios à haute fréquence :

```
// Exemple qui génère beaucoup de boxing/unboxing
ArrayList liste = new ArrayList();  // Utilise object en interne
for (int i = 0; i < 1000000; i++)
{
    liste.Add(i);        // Boxing de chaque entier
    int x = (int)liste[i];  // Unboxing à chaque accès
}

// Alternative sans boxing avec les collections génériques
List<int> listeGénérique = new List<int>();
for (int i = 0; i < 1000000; i++)
{
    listeGénérique.Add(i);        // Pas de boxing
    int x = listeGénérique[i];    // Pas d'unboxing
}
```


### Situations courantes de boxing

Le boxing se produit souvent dans des scénarios comme :

```
// 1. Utilisation de collections non génériques
ArrayList liste = new ArrayList();
liste.Add(42);  // Boxing

// 2. Utilisation de paramètres de type object
void AfficherObjet(object obj)
{
    Console.WriteLine(obj);
}
AfficherObjet(42);  // Boxing

// 3. Inférence de type avec var et dynamic
var nombre = 42;     // Pas de boxing (var devient int)
dynamic nombre2 = 42;  // Boxing (dynamic est basé sur object)

// 4. Interfaces sur types valeur
int nombre = 42;
IComparable comparable = nombre;  // Boxing
```


### Éviter le boxing

En .NET moderne, il existe plusieurs façons d'éviter le boxing :

```
// Utiliser des collections génériques
List<int> nombres = new List<int>();  // Pas de boxing

// Utiliser des interfaces génériques
IEnumerable<int> séquence = nombres;  // Pas de boxing

// Utiliser des méthodes génériques
void Afficher<T>(T valeur)
{
    Console.WriteLine(valeur);
}
Afficher(42);  // Pas de boxing
```


### Différences entre .NET Framework 4.7.2 et .NET 8

.NET 8 offre davantage d'API qui évitent le boxing par rapport à .NET Framework 4.7.2, notamment :

- Extensions de méthodes génériques supplémentaires
- Utilisation plus répandue de `Span<T>` et `ReadOnlySpan<T>`
- Implémentations d'interfaces plus efficaces pour les types valeur
- Méthodes d'assistance pour éviter les allocations inutiles

## 2.2.5. Types nullables et opérateurs associés

Dans C#, les types valeur ne peuvent normalement pas avoir la valeur `null`. Les types nullables résolvent ce problème en permettant aux types valeur d'accepter également `null`.

### Types valeur nullables

La syntaxe pour déclarer un type valeur nullable utilise soit `Nullable<T>`, soit le raccourci `T?` :

```
// Deux façons équivalentes de déclarer un int nullable
Nullable<int> âge1 = null;
int? âge2 = null;

// Initialisation avec une valeur
int? compteur = 5;

// Vérification si la valeur est null
if (compteur.HasValue)
{
    Console.WriteLine($"Valeur: {compteur.Value}");
}
else
{
    Console.WriteLine("Aucune valeur (null)");
}

// Accès direct (lève une exception si null)
int valeur = compteur.Value;

// Utilisation d'une valeur par défaut
int valeurOuZéro = compteur ?? 0;
```


### Opérateur de coalescence nulle (??)

L'opérateur `??` permet de spécifier une valeur par défaut à utiliser lorsqu'une expression est `null` :

```
// Syntaxe: expression1 ?? expression2
// Retourne expression1 si non-null, sinon expression2

string nom = GetNom() ?? "Inconnu";
int? quantité = GetQuantité() ?? 0;

// Chaînage possible
string titre = GetTitre() ?? GetAlternatif() ?? "Sans titre";
```


### Opérateur d'accès conditionnel aux membres (?.)

Introduit dans C# 6, cet opérateur permet d'accéder aux membres d'un objet uniquement si celui-ci n'est pas `null` :

```
// Sans opérateur ?. (vérification explicite)
if (client != null)
{
    if (client.Adresse != null)
    {
        Console.WriteLine(client.Adresse.Ville);
    }
}

// Avec opérateur ?. (plus concis)
Console.WriteLine(client?.Adresse?.Ville);  // null si client ou Adresse est null

// Combinaison avec ??
string ville = client?.Adresse?.Ville ?? "Ville inconnue";
```


### Opérateur d'index null-conditionnel (?[])

Cet opérateur permet d'accéder aux éléments d'une collection uniquement si celle-ci n'est pas `null` :

```
// Sans opérateur ?[]
if (tableau != null && index < tableau.Length)
{
    Console.WriteLine(tableau[index]);
}

// Avec opérateur ?[]
Console.WriteLine(tableau?[index]);  // null si tableau est null

// Combinaison avec autres opérateurs
string premier = liste?.FirstOrDefault()?.Nom ?? "Aucun élément";
```


### Types référence nullables (C# 8+, .NET Core 3.0+)

C# 8 a introduit une fonctionnalité majeure : les types référence nullables. Disponible dans .NET Core 3.0+ et .NET 8, mais pas dans .NET Framework 4.7.2.

Cette fonctionnalité permet de déclarer si un type référence peut ou non contenir `null` :

```
// Activer la fonctionnalité dans le projet (.csproj)
<PropertyGroup>
    <Nullable>enable</Nullable>
</PropertyGroup>

// Ou activer pour un fichier spécifique
#nullable enable

// string non-nullable (ne devrait jamais être null)
string nom = "Jean";
nom = null;  // Avertissement du compilateur

// string nullable (peut être null)
string? prénom = "Pierre";
prénom = null;  // OK

// Vérification au compilateur
void Traiter(string nonNullable, string? nullable)
{
    // Le compilateur sait que nonNullable n'est jamais null
    Console.WriteLine(nonNullable.Length);  // OK

    // Pour nullable, une vérification est nécessaire
    Console.WriteLine(nullable.Length);  // Avertissement
    Console.WriteLine(nullable?.Length);  // OK

    // Ou avec une vérification explicite
    if (nullable != null)
    {
        Console.WriteLine(nullable.Length);  // OK
    }
}
```


### Opérateur d'assertion non-null (!)

L'opérateur `!` (post-fixe) permet d'indiquer au compilateur qu'une variable nullable n'est pas `null` à ce point du code :

```
string? texte = GetTexte();

// Si vous êtes sûr que texte n'est pas null
int longueur = texte!.Length;  // Désactive l'avertissement
```


Cet opérateur ne fait aucune vérification à l'exécution - il indique simplement au compilateur de ne pas générer d'avertissement. Si la valeur est effectivement `null`, une exception `NullReferenceException` sera levée.

### Bonnes pratiques avec les nullables

- **En .NET Framework 4.7.2** : Utilisez les types valeur nullables (`int?`, etc.) pour représenter des données optionnelles
- **En .NET 8** :
  - Activez `Nullable` dans votre projet
  - Utilisez des types non-nullables par défaut
  - Réservez les types nullables pour les données vraiment optionnelles
  - Utilisez les opérateurs `?.`, `??` et `?[]` pour un code plus concis
  - N'utilisez l'opérateur `!` que lorsque vous êtes absolument certain qu'une valeur n'est pas `null`

### Syntaxe avancée avec les nullables

```
// Opérations sur valeurs nullables
int? a = 5;
int? b = 10;
int? somme = a + b;      // 15
int? produit = a * b;    // 50
bool? comparaison = a < b;  // true

// Si l'un des opérandes est null, le résultat est null
int? c = null;
int? résultat = a + c;   // null

// Cast depuis nullable vers non-nullable
int? nullable = 42;
int nonNullable = (int)nullable;  // OK si nullable a une valeur
                                 // Exception si nullable est null

// Pattern matching (C# 7+)
if (compteur is int valeurCompteur)
{
    // valeurCompteur est de type int (non-nullable)
    Console.WriteLine($"Le compteur vaut {valeurCompteur}");
}
```


---

Les types de données sont les éléments fondamentaux de tout programme C#. Une bonne compréhension des types primitifs, de la distinction entre types valeur et types référence, des chaînes de caractères, du boxing/unboxing et des types nullables vous permettra d'écrire du code plus efficace et plus robuste. Dans la prochaine section, nous explorerons les opérateurs et expressions qui vous permettront de manipuler ces types de données.
