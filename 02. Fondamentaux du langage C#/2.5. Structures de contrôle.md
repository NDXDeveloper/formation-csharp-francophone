# 2.5 Structures de contr√¥le en C#

Les structures de contr√¥le sont les blocs de construction qui permettent √† vos programmes de prendre des d√©cisions, de r√©p√©ter des actions et de contr√¥ler le flux d'ex√©cution. Sans elles, les programmes s'ex√©cuteraient simplement de haut en bas sans aucune intelligence ou adaptabilit√©. Comprendre ces structures est essentiel pour tout d√©veloppeur C#.

## 2.5.1 Conditionnelles (if, else, switch)

Les structures conditionnelles permettent √† votre programme de prendre des d√©cisions en ex√©cutant diff√©rents blocs de code selon qu'une condition est vraie ou fausse.

### Instruction if

L'instruction `if` est la conditionnelle la plus simple. Elle ex√©cute un bloc de code uniquement si une condition est √©valu√©e √† `true`.

```csharp
if (condition)
{
    // Ce code s'ex√©cute uniquement si la condition est vraie
}
```

Exemple pratique :

```csharp
int age = 20;

if (age >= 18)
{
    Console.WriteLine("Vous √™tes majeur.");
}
```

Si le bloc de code ne contient qu'une seule instruction, les accolades sont optionnelles, mais il est g√©n√©ralement recommand√© de les conserver pour plus de clart√© :

```csharp
if (age >= 18)
    Console.WriteLine("Vous √™tes majeur.");  // Fonctionne, mais moins lisible
```

### Instruction if-else

L'instruction `if-else` permet d'ex√©cuter un bloc de code si la condition est vraie, et un autre bloc si elle est fausse.

```csharp
if (condition)
{
    // Ce code s'ex√©cute si la condition est vraie
}
else
{
    // Ce code s'ex√©cute si la condition est fausse
}
```

Exemple pratique :

```csharp
int age = 15;

if (age >= 18)
{
    Console.WriteLine("Vous √™tes majeur.");
}
else
{
    Console.WriteLine("Vous √™tes mineur.");
}
```

### Instruction if-else if-else

Vous pouvez encha√Æner plusieurs conditions avec `else if` pour tester plusieurs cas successifs.

```csharp
if (condition1)
{
    // Code ex√©cut√© si condition1 est vraie
}
else if (condition2)
{
    // Code ex√©cut√© si condition1 est fausse ET condition2 est vraie
}
else if (condition3)
{
    // Code ex√©cut√© si condition1 et condition2 sont fausses ET condition3 est vraie
}
else
{
    // Code ex√©cut√© si toutes les conditions pr√©c√©dentes sont fausses
}
```

Exemple pratique :

```csharp
int note = 85;

if (note >= 90)
{
    Console.WriteLine("Excellent !");
}
else if (note >= 80)
{
    Console.WriteLine("Tr√®s bien !");
}
else if (note >= 70)
{
    Console.WriteLine("Bien.");
}
else if (note >= 60)
{
    Console.WriteLine("Passable.");
}
else
{
    Console.WriteLine("√âchec.");
}
```

> **üîç Note importante :**
> Les conditions sont √©valu√©es dans l'ordre. D√®s qu'une condition est vraie, son bloc de code est ex√©cut√© et les conditions suivantes ne sont pas √©valu√©es.

### Conditions imbriqu√©es

Vous pouvez imbriquer des instructions `if` √† l'int√©rieur d'autres instructions `if` ou `else`.

```csharp
if (estAuthentifie)
{
    if (estAdmin)
    {
        Console.WriteLine("Bienvenue, administrateur !");
    }
    else
    {
        Console.WriteLine("Bienvenue, utilisateur !");
    }
}
else
{
    Console.WriteLine("Authentification requise.");
}
```

Bien que les conditions imbriqu√©es fonctionnent, elles peuvent rapidement rendre votre code difficile √† lire. Si possible, essayez de simplifier la logique ou d'utiliser des conditions combin√©es :

```csharp
if (estAuthentifie && estAdmin)
{
    Console.WriteLine("Bienvenue, administrateur !");
}
else if (estAuthentifie)
{
    Console.WriteLine("Bienvenue, utilisateur !");
}
else
{
    Console.WriteLine("Authentification requise.");
}
```

### Instruction switch

L'instruction `switch` est utile lorsque vous avez plusieurs choix possibles bas√©s sur la valeur d'une variable. Elle remplace avantageusement une longue s√©rie de `if-else if`.

```csharp
switch (expression)
{
    case valeur1:
        // Code √† ex√©cuter si expression √©gale valeur1
        break;
    case valeur2:
        // Code √† ex√©cuter si expression √©gale valeur2
        break;
    // ... autres cas ...
    default:
        // Code √† ex√©cuter si aucun cas ne correspond
        break;
}
```

Exemple pratique :

```csharp
int jour = 3;
string nomJour;

switch (jour)
{
    case 1:
        nomJour = "Lundi";
        break;
    case 2:
        nomJour = "Mardi";
        break;
    case 3:
        nomJour = "Mercredi";
        break;
    case 4:
        nomJour = "Jeudi";
        break;
    case 5:
        nomJour = "Vendredi";
        break;
    case 6:
        nomJour = "Samedi";
        break;
    case 7:
        nomJour = "Dimanche";
        break;
    default:
        nomJour = "Jour invalide";
        break;
}

Console.WriteLine($"Le jour {jour} est {nomJour}.");
```

#### Points importants sur switch

1. **L'instruction `break`** est n√©cessaire √† la fin de chaque cas pour sortir du switch. Sans elle, l'ex√©cution continue au cas suivant (ce qu'on appelle "fall-through").

2. **Le cas `default`** est optionnel mais recommand√©. Il g√®re les valeurs qui ne correspondent √† aucun cas.

3. **Plusieurs valeurs pour un m√™me cas** (√† partir de C# 7.0) :
   ```csharp
   case 1:
   case 2:
   case 3:
       Console.WriteLine("Premier trimestre");
       break;
   ```

4. **Types support√©s** : Traditionnellement, `switch` fonctionnait avec des types simples (entiers, caract√®res, cha√Ænes), mais les versions r√©centes de C# ont √©tendu ses capacit√©s (voir la section sur le pattern matching).

## 2.5.2 Boucles (for, while, do-while, foreach)

Les boucles permettent d'ex√©cuter un bloc de code plusieurs fois, ce qui est essentiel pour traiter des collections de donn√©es ou r√©p√©ter des actions.

### Boucle for

La boucle `for` est id√©ale quand vous connaissez √† l'avance le nombre d'it√©rations √† effectuer. Elle comporte trois parties : l'initialisation, la condition et l'incr√©mentation.

```csharp
for (initialisation; condition; incr√©mentation)
{
    // Code √† r√©p√©ter tant que la condition est vraie
}
```

Exemple pratique :

```csharp
// Afficher les nombres de 1 √† 5
for (int i = 1; i <= 5; i++)
{
    Console.WriteLine(i);
}
```

Dans cet exemple :
- `int i = 1` : initialise la variable de compteur
- `i <= 5` : la boucle continue tant que cette condition est vraie
- `i++` : incr√©mente la variable apr√®s chaque it√©ration

#### Variations sur la boucle for

1. **Comptage √† rebours** :
   ```csharp
   for (int i = 10; i > 0; i--)
   {
       Console.WriteLine(i);
   }
   Console.WriteLine("D√©collage !");
   ```

2. **Incr√©mentation diff√©rente** :
   ```csharp
   // Afficher les nombres pairs de 0 √† 10
   for (int i = 0; i <= 10; i += 2)
   {
       Console.WriteLine(i);
   }
   ```

3. **Boucle for sans corps** :
   ```csharp
   // Calculer la somme des nombres de 1 √† 100
   int somme = 0;
   for (int i = 1; i <= 100; i++) somme += i;
   ```

4. **Boucle for avec plusieurs variables** :
   ```csharp
   for (int i = 0, j = 10; i < j; i++, j--)
   {
       Console.WriteLine($"i = {i}, j = {j}");
   }
   ```

5. **Boucle for infinie** (√† utiliser avec pr√©caution) :
   ```csharp
   for (;;)
   {
       // Code √† r√©p√©ter ind√©finiment
       // Assurez-vous d'avoir une condition de sortie !
       if (condition) break;
   }
   ```

### Boucle while

La boucle `while` r√©p√®te un bloc de code tant qu'une condition reste vraie. Elle est utile quand vous ne connaissez pas √† l'avance le nombre d'it√©rations n√©cessaires.

```csharp
while (condition)
{
    // Code √† r√©p√©ter tant que la condition est vraie
}
```

Exemple pratique :

```csharp
int compteur = 1;

while (compteur <= 5)
{
    Console.WriteLine(compteur);
    compteur++;
}
```

La boucle `while` √©value la condition avant d'ex√©cuter le bloc. Si la condition est fausse d√®s le d√©but, le bloc ne sera jamais ex√©cut√©.

```csharp
int x = 10;

while (x < 5)
{
    Console.WriteLine("Ce code ne s'ex√©cutera jamais");
}
```

### Boucle do-while

La boucle `do-while` est similaire √† `while`, mais elle √©value la condition apr√®s avoir ex√©cut√© le bloc. Cela garantit que le bloc s'ex√©cute au moins une fois.

```csharp
do
{
    // Code √† ex√©cuter au moins une fois
    // puis √† r√©p√©ter tant que la condition est vraie
} while (condition);
```

Exemple pratique :

```csharp
int compteur = 1;

do
{
    Console.WriteLine(compteur);
    compteur++;
} while (compteur <= 5);
```

M√™me si la condition est fausse d√®s le d√©but, le bloc s'ex√©cute une fois :

```csharp
int x = 10;

do
{
    Console.WriteLine("Ce code s'ex√©cute une fois");
} while (x < 5);
```

La boucle `do-while` est utile pour les sc√©narios o√π vous devez ex√©cuter une action au moins une fois, comme demander une entr√©e utilisateur jusqu'√† ce qu'elle soit valide.

```csharp
string mot;
do
{
    Console.Write("Entrez un mot d'au moins 5 lettres : ");
    mot = Console.ReadLine();
} while (mot.Length < 5);

Console.WriteLine($"Merci, vous avez entr√© : {mot}");
```

### Boucle foreach

La boucle `foreach` est sp√©cialement con√ßue pour parcourir les √©l√©ments d'une collection (tableaux, listes, dictionnaires, etc.) sans se soucier des indices ou du nombre d'√©l√©ments.

```csharp
foreach (type √©l√©ment in collection)
{
    // Code √† ex√©cuter pour chaque √©l√©ment
}
```

Exemple pratique avec un tableau :

```csharp
string[] fruits = { "pomme", "banane", "orange", "fraise", "kiwi" };

foreach (string fruit in fruits)
{
    Console.WriteLine(fruit);
}
```

Exemple avec une liste :

```csharp
List<int> nombres = new List<int> { 1, 2, 3, 4, 5 };

foreach (int nombre in nombres)
{
    Console.WriteLine(nombre * nombre);
}
```

#### Avantages de foreach

1. **Simplicit√©** : Pas besoin de g√©rer les indices ou le comptage
2. **S√©curit√©** : Pas de risque de d√©passer les limites de la collection
3. **Universel** : Fonctionne avec toute collection qui impl√©mente l'interface `IEnumerable`

#### Limitations de foreach

1. **Lecture seule** : Vous ne pouvez pas modifier la collection pendant l'it√©ration
2. **Pas d'indice** : Si vous avez besoin de l'indice, utilisez plut√¥t `for`

> **üí° Conseil :**
> En g√©n√©ral, privil√©giez `foreach` pour parcourir des collections lorsque vous n'avez pas besoin de l'indice ou de modifier la collection pendant l'it√©ration.

## 2.5.3 Instructions de saut (break, continue, return)

Les instructions de saut modifient le flux normal d'ex√©cution d'une boucle ou d'une m√©thode. Elles vous permettent de sortir pr√©matur√©ment d'une boucle, de sauter √† l'it√©ration suivante ou de quitter une m√©thode.

### break

L'instruction `break` termine imm√©diatement la boucle ou le switch dans lequel elle se trouve.

Dans une boucle :

```csharp
for (int i = 1; i <= 10; i++)
{
    if (i == 5)
    {
        break;  // Sort de la boucle quand i atteint 5
    }
    Console.WriteLine(i);
}
// Affiche : 1 2 3 4
```

Dans un switch :

```csharp
switch (jour)
{
    case 1:
        Console.WriteLine("Lundi");
        break;  // Sort du switch
    case 2:
        Console.WriteLine("Mardi");
        break;
    // ...
}
```

L'instruction `break` est utile lorsque vous avez trouv√© ce que vous cherchiez et n'avez pas besoin de continuer l'it√©ration :

```csharp
bool EstPresent(int[] tableau, int valeur)
{
    foreach (int element in tableau)
    {
        if (element == valeur)
        {
            return true;  // Trouv√© !
        }
    }
    return false;  // Non trouv√©
}
```

### continue

L'instruction `continue` saute le reste de l'it√©ration actuelle et passe directement √† l'it√©ration suivante.

```csharp
for (int i = 1; i <= 10; i++)
{
    if (i % 2 == 0)
    {
        continue;  // Saute les nombres pairs
    }
    Console.WriteLine(i);
}
// Affiche : 1 3 5 7 9
```

L'instruction `continue` est utile pour filtrer certains √©l√©ments sans compliquer la structure de votre boucle :

```csharp
foreach (string ligne in fichier)
{
    // Ignorer les lignes vides ou les commentaires
    if (string.IsNullOrWhiteSpace(ligne) || ligne.StartsWith("//"))
    {
        continue;
    }

    // Traiter les lignes normales ici
    TraiterLigne(ligne);
}
```

### return

L'instruction `return` quitte imm√©diatement la m√©thode et renvoie √©ventuellement une valeur.

```csharp
int Calculer(int a, int b)
{
    if (b == 0)
    {
        Console.WriteLine("Division par z√©ro impossible");
        return 0;  // Quitte la m√©thode imm√©diatement
    }

    return a / b;  // Quitte la m√©thode avec le r√©sultat
}
```

L'instruction `return` est particuli√®rement utile pour les retours conditionnels pr√©coces, qui peuvent souvent simplifier la logique de votre code :

```csharp
// Approche avec return pr√©coce
bool EstValide(string texte)
{
    if (string.IsNullOrEmpty(texte))
    {
        return false;
    }

    if (texte.Length < 3)
    {
        return false;
    }

    if (!char.IsUpper(texte[0]))
    {
        return false;
    }

    return true;
}

// Au lieu de :
bool EstValideSansRetourPrecoce(string texte)
{
    bool resultat = true;

    if (string.IsNullOrEmpty(texte))
    {
        resultat = false;
    }
    else if (texte.Length < 3)
    {
        resultat = false;
    }
    else if (!char.IsUpper(texte[0]))
    {
        resultat = false;
    }

    return resultat;
}
```

### goto (√† utiliser avec pr√©caution)

L'instruction `goto` transf√®re directement l'ex√©cution √† une √©tiquette sp√©cifi√©e. Elle est g√©n√©ralement d√©conseill√©e car elle rend le code difficile √† suivre, mais elle peut √™tre utile dans certains cas sp√©cifiques, comme sortir de boucles imbriqu√©es.

```csharp
for (int i = 0; i < 10; i++)
{
    for (int j = 0; j < 10; j++)
    {
        if (i * j > 50)
        {
            goto FinDesBoucles;  // Sort des deux boucles √† la fois
        }
        Console.WriteLine($"{i} * {j} = {i * j}");
    }
}

FinDesBoucles:
Console.WriteLine("Boucles termin√©es");
```

> **‚ö†Ô∏è Attention :**
> L'utilisation de `goto` est g√©n√©ralement consid√©r√©e comme une mauvaise pratique car elle peut rendre le code difficile √† comprendre et √† maintenir. Pr√©f√©rez les autres structures de contr√¥le quand c'est possible.

## 2.5.4 Pattern matching (√† partir de C# 7.0)

Le pattern matching, introduit avec C# 7.0 et am√©lior√© dans les versions suivantes, permet d'examiner un objet et d'agir diff√©remment selon son type, sa structure ou sa valeur.

### Pattern matching avec is

L'op√©rateur `is` v√©rifie si un objet est d'un type sp√©cifique, mais en plus, il peut assigner le r√©sultat √† une variable si le test r√©ussit (pattern matching de type).

```csharp
// Avant C# 7.0
if (animal is Dog)
{
    Dog dog = (Dog)animal;
    dog.Bark();
}

// Avec pattern matching (C# 7.0+)
if (animal is Dog dog)
{
    dog.Bark();  // La variable dog est d√©j√† typ√©e et disponible
}
```

### Pattern matching avec constantes

Vous pouvez √©galement faire correspondre une variable √† une valeur constante :

```csharp
if (obj is 42)
{
    Console.WriteLine("La valeur est 42");
}

if (obj is null)
{
    Console.WriteLine("L'objet est null");
}
```

### Pattern matching dans switch

Le pattern matching est particuli√®rement puissant dans les instructions switch, o√π il permet de v√©rifier √† la fois le type et les propri√©t√©s d'un objet :

```csharp
switch (shape)
{
    case Circle circle when circle.Radius > 10:
        Console.WriteLine($"Grand cercle de rayon {circle.Radius}");
        break;

    case Circle circle:
        Console.WriteLine($"Cercle de rayon {circle.Radius}");
        break;

    case Rectangle rectangle when rectangle.Width == rectangle.Height:
        Console.WriteLine($"Carr√© de c√¥t√© {rectangle.Width}");
        break;

    case Rectangle rectangle:
        Console.WriteLine($"Rectangle de dimensions {rectangle.Width}x{rectangle.Height}");
        break;

    case null:
        Console.WriteLine("La forme est null");
        break;

    default:
        Console.WriteLine($"Autre forme: {shape.GetType().Name}");
        break;
}
```

Dans cet exemple :
- Nous v√©rifions d'abord si `shape` est un `Circle` avec un rayon sup√©rieur √† 10
- Sinon, nous v√©rifions si c'est un `Circle` quelconque
- Ensuite, nous v√©rifions si c'est un `Rectangle` avec largeur √©gale √† la hauteur (un carr√©)
- Et ainsi de suite...

### Pattern matching avec la d√©construction (C# 8.0+)

Vous pouvez combiner le pattern matching avec la d√©construction pour examiner plusieurs propri√©t√©s d'un objet en une seule fois :

```csharp
// Avec une classe qui supporte la d√©construction
if (point is (0, 0))
{
    Console.WriteLine("Point √† l'origine");
}

switch (point)
{
    case (0, 0):
        Console.WriteLine("Point √† l'origine");
        break;
    case (var x, 0):
        Console.WriteLine($"Point sur l'axe X √† {x}");
        break;
    case (0, var y):
        Console.WriteLine($"Point sur l'axe Y √† {y}");
        break;
    case (var x, var y) when x == y:
        Console.WriteLine($"Point sur la diagonale √† ({x}, {y})");
        break;
    default:
        Console.WriteLine($"Point √† ({point.X}, {point.Y})");
        break;
}
```

### Property pattern (C# 8.0+)

Le property pattern permet d'examiner les propri√©t√©s d'un objet de mani√®re concise :

```csharp
// V√©rifier si une personne est un adulte de nationalit√© fran√ßaise
if (personne is { Age: >= 18, Nationalite: "Fran√ßaise" })
{
    Console.WriteLine("Adulte de nationalit√© fran√ßaise");
}

// √âquivalent en switch
switch (personne)
{
    case { Age: >= 18, Nationalite: "Fran√ßaise" }:
        Console.WriteLine("Adulte de nationalit√© fran√ßaise");
        break;
    case { Age: < 18 }:
        Console.WriteLine("Mineur");
        break;
    default:
        Console.WriteLine("Adulte d'une autre nationalit√©");
        break;
}
```

## 2.5.5 Switch expressions (C# 8+)

C# 8.0 a introduit les expressions switch, une forme plus concise et expressive des instructions switch traditionnelles. Elles sont particuli√®rement utiles lorsque vous voulez assigner une valeur bas√©e sur diff√©rents cas.

### Syntaxe de base

```csharp
// Instruction switch traditionnelle
string GetMessageClassique(int code)
{
    switch (code)
    {
        case 200:
            return "OK";
        case 404:
            return "Not Found";
        case 500:
            return "Server Error";
        default:
            return "Unknown";
    }
}

// √âquivalent avec une expression switch
string GetMessage(int code) => code switch
{
    200 => "OK",
    404 => "Not Found",
    500 => "Server Error",
    _ => "Unknown"    // _ est le motif par d√©faut
};
```

Points cl√©s √† noter :
- La variable √† tester (`code`) est plac√©e avant le mot-cl√© `switch`
- Chaque cas utilise la syntaxe `motif => r√©sultat`
- Le underscore `_` repr√©sente le cas par d√©faut
- La ponctuation est diff√©rente : virgules entre les cas et point-virgule √† la fin

### Utilisation avec le pattern matching

Les expressions switch sont encore plus puissantes lorsqu'elles sont combin√©es avec le pattern matching :

```csharp
string FormatPerson(object obj) => obj switch
{
    Person { FirstName: "John", LastName: "Doe" } => "C'est John Doe !",
    Person { LastName: var name } => $"Bonjour M. {name}",
    Student { Major: "Computer Science", Year: > 3 } => "√âtudiant en derni√®re ann√©e d'informatique",
    Student { Year: var year } => $"√âtudiant en ann√©e {year}",
    null => "Objet null",
    _ => "Objet inconnu"
};
```

### Utilisation avec la d√©construction

```csharp
string GetQuadrant(Point p) => p switch
{
    (0, 0) => "Origine",
    (> 0, > 0) => "Quadrant 1",
    (< 0, > 0) => "Quadrant 2",
    (< 0, < 0) => "Quadrant 3",
    (> 0, < 0) => "Quadrant 4",
    (0, _) => "Axe Y",
    (_, 0) => "Axe X",
    _ => "Impossible"    // N√©cessaire m√™me si tous les cas sont couverts
};
```

### Expressions switch pour les calculs

Les expressions switch sont tr√®s utiles pour remplacer les longues cha√Ænes d'instructions `if-else if` lors du calcul de valeurs :

```csharp
// Calculer le nombre de jours dans un mois
int GetDaysInMonth(int month, bool isLeapYear) => month switch
{
    1 or 3 or 5 or 7 or 8 or 10 or 12 => 31,
    4 or 6 or 9 or 11 => 30,
    2 => isLeapYear ? 29 : 28,
    _ => throw new ArgumentOutOfRangeException(nameof(month), "Mois invalide")
};
```

### Utilisation avec les tuples

Vous pouvez utiliser des tuples pour faire correspondre plusieurs valeurs √† la fois :

```csharp
string GetGameResult(string player1, string player2) => (player1, player2) switch
{
    ("pierre", "ciseaux") => "Joueur 1 gagne",
    ("papier", "pierre") => "Joueur 1 gagne",
    ("ciseaux", "papier") => "Joueur 1 gagne",
    ("pierre", "pierre") => "√âgalit√©",
    ("papier", "papier") => "√âgalit√©",
    ("ciseaux", "ciseaux") => "√âgalit√©",
    _ => "Joueur 2 gagne"
};
```

### Astuces et bonnes pratiques

1. **Exhaustivit√©** : Les expressions switch doivent couvrir tous les cas possibles, sinon le compilateur g√©n√®re une erreur. Utilisez le motif `_` pour couvrir les cas restants.

2. **Ordre des cas** : L'ordre des cas est important. Le premier cas correspondant est choisi.

3. **Exceptions** : Vous pouvez lancer des exceptions dans les expressions switch pour les cas invalides.

4. **Pas d'instructions, seulement des expressions** : Les expressions switch doivent retourner une valeur, pas ex√©cuter des instructions.

5. **Lisibilit√©** : Les expressions switch peuvent am√©liorer la lisibilit√© pour les logiques complexes de branchement, mais n'abusez pas des fonctionnalit√©s avanc√©es si cela rend le code difficile √† comprendre.

### Imbrication de conditionnels

Vous pouvez avoir des logiques conditionnelles complexes dans les r√©sultats :

```csharp
decimal CalculerPrix(Product produit, Customer client) => produit switch
{
    { Category: "√âlectronique" } => client.IsPremium ? produit.Price * 0.9m : produit.Price,
    { Category: "Livres" } => produit.Price * 0.95m,
    { IsDiscounted: true } => produit.Price * 0.8m,
    _ => produit.Price
};
```

## R√©sum√©

- Les **conditionnelles** (`if`, `else`, `switch`) permettent d'ex√©cuter diff√©rents blocs de code selon des conditions.
- Les **boucles** (`for`, `while`, `do-while`, `foreach`) permettent de r√©p√©ter des blocs de code.
- Les **instructions de saut** (`break`, `continue`, `return`) modifient le flux d'ex√©cution normal.
- Le **pattern matching** permet d'examiner un objet et d'agir diff√©remment selon son type, sa structure ou sa valeur.
- Les **expressions switch** offrent une syntaxe concise pour assigner des valeurs bas√©es sur diff√©rents cas.

Ces structures de contr√¥le sont les outils fondamentaux qui vous permettent de cr√©er des programmes C# dynamiques et r√©actifs. En ma√Ætrisant ces concepts, vous serez capable de concevoir des solutions √©l√©gantes √† des probl√®mes complexes.
