# 2.5. Structures de contrôle

![Structures de contrôle en C#](https://via.placeholder.com/600x150?text=Structures+de+contr%C3%B4le+en+C%23)

Les structures de contrôle permettent de diriger le flux d'exécution d'un programme en fonction de conditions ou de répéter des blocs de code. C# offre un ensemble complet de structures de contrôle similaires à celles d'autres langages de la famille C, mais avec certaines particularités et améliorations.

## 2.5.1. Conditionnelles (if, else, switch)

Les structures conditionnelles permettent d'exécuter différents blocs de code en fonction de conditions spécifiques.

### Instruction if-else

L'instruction `if` exécute un bloc de code si une condition est évaluée comme vraie :

```
int âge = 20;

// If simple
if (âge >= 18)
{
    Console.WriteLine("Vous êtes majeur.");
}

// If-else
if (âge >= 18)
{
    Console.WriteLine("Vous êtes majeur.");
}
else
{
    Console.WriteLine("Vous êtes mineur.");
}

// If-else if-else (chaînage de conditions)
if (âge < 13)
{
    Console.WriteLine("Enfant");
}
else if (âge < 18)
{
    Console.WriteLine("Adolescent");
}
else if (âge < 65)
{
    Console.WriteLine("Adulte");
}
else
{
    Console.WriteLine("Senior");
}
```


Les accolades `{}` sont optionnelles pour les blocs contenant une seule instruction, mais il est généralement recommandé de les utiliser pour une meilleure lisibilité :

```
// Sans accolades (déconseillé)
if (âge >= 18)
    Console.WriteLine("Majeur");
else
    Console.WriteLine("Mineur");

// Avec accolades (recommandé)
if (âge >= 18)
{
    Console.WriteLine("Majeur");
}
else
{
    Console.WriteLine("Mineur");
}
```


### Opérateurs logiques dans les conditions

Vous pouvez combiner plusieurs conditions à l'aide des opérateurs logiques :

```
int âge = 25;
bool estÉtudiant = true;

// Opérateur ET (&&)
if (âge >= 18 && âge <= 30)
{
    Console.WriteLine("Jeune adulte");
}

// Opérateur OU (||)
if (âge < 18 || estÉtudiant)
{
    Console.WriteLine("Tarif réduit applicable");
}

// Opérateur NON (!)
if (!estÉtudiant)
{
    Console.WriteLine("Tarif standard");
}

// Combinaison complexe
if ((âge >= 18 && !estÉtudiant) || (âge >= 25 && estÉtudiant))
{
    Console.WriteLine("Critères spécifiques satisfaits");
}
```


### Instruction switch

L'instruction `switch` permet de sélectionner un bloc de code à exécuter parmi plusieurs alternatives basées sur la valeur d'une expression :

```
int jour = 3;
string nomJour;

switch (jour)
{
    case 1:
        nomJour = "Lundi";
        break;
    case 2:
        nomJour = "Mardi";
        break;
    case 3:
        nomJour = "Mercredi";
        break;
    case 4:
        nomJour = "Jeudi";
        break;
    case 5:
        nomJour = "Vendredi";
        break;
    case 6:
        nomJour = "Samedi";
        break;
    case 7:
        nomJour = "Dimanche";
        break;
    default:
        nomJour = "Jour invalide";
        break;
}

Console.WriteLine($"Aujourd'hui c'est {nomJour}");
```


Points importants sur `switch` :
- Chaque `case` doit se terminer par une instruction de sortie comme `break`, `return`, `throw` ou `goto`
- L'instruction `default` est exécutée si aucun `case` ne correspond
- Plusieurs valeurs peuvent partager le même bloc de code

```
// Regroupement de cas
string typeDJour;
switch (jour)
{
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        typeDJour = "Jour ouvrable";
        break;
    case 6:
    case 7:
        typeDJour = "Week-end";
        break;
    default:
        typeDJour = "Jour invalide";
        break;
}
```


### Switch avec types et conditions (C# 7.0+)

À partir de C# 7.0, l'instruction `switch` a été considérablement améliorée pour prendre en charge les types et les conditions :

```
object objet = "Hello";

switch (objet)
{
    case string s when s.Length > 10:
        Console.WriteLine("Longue chaîne de caractères");
        break;
    case string s:
        Console.WriteLine($"Chaîne de caractères: {s}");
        break;
    case int i:
        Console.WriteLine($"Entier: {i}");
        break;
    case DateTime d:
        Console.WriteLine($"Date: {d.ToShortDateString()}");
        break;
    case null:
        Console.WriteLine("Valeur null");
        break;
    default:
        Console.WriteLine($"Autre type: {objet.GetType().Name}");
        break;
}
```


## 2.5.2. Boucles (for, while, do-while, foreach)

Les boucles permettent d'exécuter répétitivement un bloc de code tant qu'une condition est vraie ou pour un nombre défini d'itérations.

### Boucle for

La boucle `for` est généralement utilisée lorsque le nombre d'itérations est connu à l'avance :

```
// Structure de base: for (initialisation; condition; itération)
for (int i = 0; i < 5; i++)
{
    Console.WriteLine($"Itération {i}");
}

// Boucle for avec plusieurs variables
for (int i = 0, j = 10; i < j; i++, j--)
{
    Console.WriteLine($"i = {i}, j = {j}");
}

// Boucle for sans corps (peu courant)
int somme = 0;
for (int i = 1; i <= 100; somme += i, i++);
Console.WriteLine($"Somme: {somme}");  // 5050

// Boucle for sans partie d'initialisation
int k = 0;
for (; k < 5; k++)
{
    Console.WriteLine(k);
}

// Boucle for sans condition (boucle infinie avec break)
for (int i = 0; ; i++)
{
    if (i >= 5)
        break;
    Console.WriteLine(i);
}
```


### Boucle while

La boucle `while` exécute un bloc de code tant qu'une condition est vraie. La condition est évaluée avant chaque itération :

```
// Structure de base
int compteur = 0;
while (compteur < 5)
{
    Console.WriteLine($"Compteur: {compteur}");
    compteur++;
}

// Lecture d'un fichier ligne par ligne
using (StreamReader reader = new StreamReader("fichier.txt"))
{
    string ligne;
    while ((ligne = reader.ReadLine()) != null)
    {
        Console.WriteLine(ligne);
    }
}

// Boucle infinie (à utiliser avec précaution)
/*
while (true)
{
    Console.WriteLine("Boucle infinie");
    // Nécessite une condition de sortie comme break
    if (Console.KeyAvailable)
        break;
}
*/
```


### Boucle do-while

La boucle `do-while` est similaire à `while`, mais la condition est évaluée après chaque itération, garantissant que le bloc de code est exécuté au moins une fois :

```
// Structure de base
int compteur = 0;
do
{
    Console.WriteLine($"Compteur: {compteur}");
    compteur++;
} while (compteur < 5);

// Validation d'entrée utilisateur
string réponse;
do
{
    Console.Write("Entrez 'oui' ou 'non': ");
    réponse = Console.ReadLine().ToLower();
} while (réponse != "oui" && réponse != "non");

// Même si la condition est initialement fausse, le bloc s'exécute une fois
int x = 10;
do
{
    Console.WriteLine("Cette ligne s'affiche une fois");
} while (x < 10);
```


### Boucle foreach

La boucle `foreach` permet de parcourir tous les éléments d'une collection ou d'un objet implémentant `IEnumerable` :

```
// Parcourir un tableau
string[] fruits = { "Pomme", "Banane", "Orange", "Fraise" };
foreach (string fruit in fruits)
{
    Console.WriteLine(fruit);
}

// Parcourir une collection
List<int> nombres = new List<int> { 1, 2, 3, 4, 5 };
foreach (int nombre in nombres)
{
    Console.WriteLine(nombre * nombre);
}

// Parcourir une chaîne de caractères
string message = "Bonjour";
foreach (char lettre in message)
{
    Console.WriteLine(lettre);
}

// Parcourir un dictionnaire
Dictionary<string, int> âges = new Dictionary<string, int>
{
    { "Alice", 30 },
    { "Bob", 25 },
    { "Charlie", 35 }
};
foreach (KeyValuePair<string, int> personne in âges)
{
    Console.WriteLine($"{personne.Key} a {personne.Value} ans");
}

// Syntaxe alternative pour les dictionnaires (C# 7.0+)
foreach (var (nom, âge) in âges)
{
    Console.WriteLine($"{nom} a {âge} ans");
}
```


Points importants sur `foreach` :
- La variable d'itération est en lecture seule
- Vous ne pouvez pas modifier la collection pendant l'itération

```
// Erreur de compilation: la variable d'itération est en lecture seule
foreach (int nombre in nombres)
{
    // nombre = 0;  // Erreur
}

// Erreur d'exécution: modification de la collection pendant l'itération
/*
foreach (int nombre in nombres)
{
    nombres.Remove(nombre);  // Lève une InvalidOperationException
}
*/

// Solution: utiliser une copie ou parcourir en sens inverse avec for
for (int i = nombres.Count - 1; i >= 0; i--)
{
    if (nombres[i] % 2 == 0)
    {
        nombres.RemoveAt(i);
    }
}
```


## 2.5.3. Instructions de saut (break, continue, return)

Les instructions de saut modifient le flux normal d'exécution des boucles et des méthodes.

### Instruction break

L'instruction `break` termine immédiatement la boucle ou le switch en cours :

```
// Sortir d'une boucle for
for (int i = 0; i < 10; i++)
{
    if (i == 5)
    {
        Console.WriteLine("Interruption de la boucle");
        break;
    }
    Console.WriteLine(i);
}  // Affiche: 0, 1, 2, 3, 4, "Interruption de la boucle"

// Sortir d'une boucle while
int j = 0;
while (j < 10)
{
    Console.WriteLine(j);
    if (j == 3)
    {
        break;
    }
    j++;
}  // Affiche: 0, 1, 2, 3

// Sortir d'une boucle imbriquée (seulement la boucle la plus proche)
for (int a = 0; a < 3; a++)
{
    for (int b = 0; b < 3; b++)
    {
        if (a == 1 && b == 1)
        {
            Console.WriteLine("Break interne");
            break;  // Sort uniquement de la boucle interne
        }
        Console.WriteLine($"a={a}, b={b}");
    }
}
```


### Instruction continue

L'instruction `continue` passe directement à l'itération suivante de la boucle, en sautant les instructions restantes dans l'itération actuelle :

```
// Sauter les nombres pairs
for (int i = 0; i < 10; i++)
{
    if (i % 2 == 0)
    {
        continue;
    }
    Console.WriteLine(i);
}  // Affiche: 1, 3, 5, 7, 9

// Utilisation dans une boucle while
int j = 0;
while (j < 10)
{
    j++;
    if (j % 2 == 0)
    {
        continue;
    }
    Console.WriteLine(j);
}  // Affiche: 1, 3, 5, 7, 9

// Filtrage de données dans une boucle foreach
string[] noms = { "Alice", "Bob", "", "Charlie", null, "David" };
foreach (string nom in noms)
{
    if (string.IsNullOrEmpty(nom))
    {
        continue;
    }
    Console.WriteLine($"Nom: {nom}");
}
```


### Instruction return

L'instruction `return` termine immédiatement l'exécution de la méthode courante et retourne éventuellement une valeur :

```
// Retourner une valeur
public int Addition(int a, int b)
{
    return a + b;
}

// Retour conditionnel
public bool EstPremier(int nombre)
{
    if (nombre <= 1)
    {
        return false;  // Retour immédiat pour les cas triviaux
    }

    if (nombre == 2)
    {
        return true;  // Nombre premier
    }

    if (nombre % 2 == 0)
    {
        return false;  // Les nombres pairs > 2 ne sont pas premiers
    }

    for (int i = 3; i <= Math.Sqrt(nombre); i += 2)
    {
        if (nombre % i == 0)
        {
            return false;  // Divisible par i, donc pas premier
        }
    }

    return true;  // Nombre premier
}

// Méthode void
public void Traiter(int[] nombres)
{
    if (nombres == null || nombres.Length == 0)
    {
        Console.WriteLine("Tableau vide ou null");
        return;  // Termine la méthode sans retourner de valeur
    }

    // Traitement...
}
```


### Instruction goto

L'instruction `goto` permet de sauter à un point spécifique du code marqué par une étiquette. Son utilisation est généralement déconseillée car elle peut rendre le code difficile à comprendre et à maintenir :

```
// Exemple d'utilisation simple de goto
int i = 0;
début:
i++;
Console.WriteLine(i);
if (i < 5)
{
    goto début;  // Revient à l'étiquette "début"
}

// Usage dans un switch (plus acceptable)
string couleur = "vert";
switch (couleur)
{
    case "rouge":
        Console.WriteLine("Arrêt");
        break;
    case "jaune":
        Console.WriteLine("Ralentir");
        break;
    case "vert":
        Console.WriteLine("Avancer");
        goto case "bleu";  // Exécute aussi le code du cas "bleu"
    case "bleu":
        Console.WriteLine("Ciel dégagé");
        break;
    default:
        Console.WriteLine("Couleur inconnue");
        break;
}
```


## 2.5.4. Pattern matching (à partir de C# 7.0)

Le pattern matching permet de tester si une valeur correspond à certaines formes et d'extraire des informations de cette valeur. C# a considérablement amélioré ses capacités de pattern matching depuis la version 7.0.

### Pattern matching avec is

```
// Pattern matching de base (C# 7.0+)
object obj = "Hello, world!";

// Version traditionnelle
if (obj is string)
{
    string s = (string)obj;
    Console.WriteLine(s.Length);
}

// Version avec pattern matching
if (obj is string s)
{
    Console.WriteLine(s.Length);  // La variable s est déjà typée et initialisée
}

// Avec des conditions supplémentaires
if (obj is string message && message.Length > 10)
{
    Console.WriteLine("Message long: " + message);
}

// Avec des types nuls
if (obj is string text)
{
    // text est garanti non-null ici
}
else if (obj is null)
{
    // obj est null
}
```


### Pattern matching dans les switch

```
// Pattern matching dans un switch (C# 7.0+)
object item = 123;

switch (item)
{
    case 0:
        Console.WriteLine("Zéro");
        break;
    case int i when i < 0:
        Console.WriteLine($"Nombre négatif: {i}");
        break;
    case int i:
        Console.WriteLine($"Nombre positif: {i}");
        break;
    case string s when s.Length == 0:
        Console.WriteLine("Chaîne vide");
        break;
    case string s:
        Console.WriteLine($"Chaîne: {s}");
        break;
    case null:
        Console.WriteLine("Null");
        break;
    default:
        Console.WriteLine("Autre type");
        break;
}
```


### Pattern matching avec tuples (C# 8.0+)

```
// Uniquement disponible dans .NET Core 3.0+ et .NET 8
var point = (5, 10);

switch (point)
{
    case (0, 0):
        Console.WriteLine("À l'origine");
        break;
    case (var x, var y) when x == y:
        Console.WriteLine("Sur la diagonale");
        break;
    case (var x, var y) when x > 0 && y > 0:
        Console.WriteLine("Premier quadrant");
        break;
    case (var x, _) when x < 0:
        Console.WriteLine("Du côté gauche");
        break;
    default:
        Console.WriteLine("Autre position");
        break;
}
```


### Property patterns (C# 8.0+)

```
// Uniquement disponible dans .NET Core 3.0+ et .NET 8
public class Adresse
{
    public string Ville { get; set; }
    public string Pays { get; set; }
}

public class Personne
{
    public string Nom { get; set; }
    public int Age { get; set; }
    public Adresse Adresse { get; set; }
}

void TraiterPersonne(Personne personne)
{
    // Property pattern
    if (personne is { Age: >= 18, Adresse: { Pays: "France" } })
    {
        Console.WriteLine("Adulte français");
    }

    switch (personne)
    {
        case { Age: < 18 }:
            Console.WriteLine("Mineur");
            break;
        case { Adresse: { Ville: "Paris" } }:
            Console.WriteLine("Parisien");
            break;
        case { Adresse: null }:
            Console.WriteLine("Adresse inconnue");
            break;
        default:
            Console.WriteLine("Autre personne");
            break;
    }
}
```


### Positional patterns (C# 8.0+)

```
// Uniquement disponible dans .NET Core 3.0+ et .NET 8
public class Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y) => (X, Y) = (x, y);

    // Déconstruction pour le pattern matching positionnel
    public void Deconstruct(out int x, out int y) => (x, y) = (X, Y);
}

void ClassifierPoint(Point point)
{
    switch (point)
    {
        case (0, 0):
            Console.WriteLine("À l'origine");
            break;
        case (var x, var y) when x > 0 && y > 0:
            Console.WriteLine($"Premier quadrant: ({x}, {y})");
            break;
        case (var x, var y) when x < 0 && y > 0:
            Console.WriteLine($"Deuxième quadrant: ({x}, {y})");
            break;
        default:
            Console.WriteLine("Autre position");
            break;
    }
}
```


### Recursive patterns (C# 9.0+)

```
// Uniquement disponible dans .NET 5+ et .NET 8 (pas dans .NET Framework 4.7.2)
public record Personne(string Nom, int Age, Adresse Adresse);
public record Adresse(string Rue, string Ville, string Pays);

void TraiterPersonne2(Personne personne)
{
    // Recursive pattern - nécessite C# 9.0+ (.NET 5+)
    if (personne is { Age: >= 18, Adresse: { Pays: "France", Ville: "Paris" } })
    {
        Console.WriteLine("Adulte parisien");
    }
}
```


### Pattern combinators (C# 9.0+)

```
// Uniquement disponible dans .NET 5+ et .NET 8
object obj = 7;

// Combinaison de patterns avec les opérateurs and, or et not
if (obj is not string and (int or double))
{
    Console.WriteLine("Nombre mais pas une chaîne");
}

string message = obj switch
{
    int n when n < 0 => "Nombre négatif",
    int n or double n when n > 0 => "Nombre positif", // Combinaison de patterns
    string s => $"Chaîne: {s}",
    null => "Valeur null",
    _ => "Autre type"  // Pattern discard (attrape-tout)
};
```


## 2.5.5. Switch expressions (C# 8+)

Les expressions switch, introduites dans C# 8.0, offrent une syntaxe plus concise et fonctionnelle pour les instructions switch traditionnelles. Elles sont particulièrement utiles pour transformer des valeurs.

### Syntaxe de base

```
// Uniquement disponible dans .NET Core 3.0+ et .NET 8
enum Saison { Printemps, Été, Automne, Hiver }

// Expression switch (retourne une valeur)
Saison saison = Saison.Hiver;

string message = saison switch
{
    Saison.Printemps => "Les fleurs s'épanouissent",
    Saison.Été       => "Il fait chaud",
    Saison.Automne   => "Les feuilles tombent",
    Saison.Hiver     => "Il neige",
    _                => "Saison inconnue"  // Pattern discard (équivalent à default)
};

Console.WriteLine(message);  // "Il neige"

// Expression switch (comme expression)
int température = saison switch
{
    Saison.Hiver     => -5,
    Saison.Printemps => 15,
    Saison.Été       => 25,
    Saison.Automne   => 10,
    _                => 0
};
```


### Avec pattern matching

```
// Uniquement disponible dans .NET Core 3.0+ et .NET 8
public class Forme {}
public class Rectangle : Forme
{
    public double Longueur { get; set; }
    public double Largeur { get; set; }
}
public class Cercle : Forme
{
    public double Rayon { get; set; }
}

double CalculerAire(Forme forme) => forme switch
{
    Rectangle r => r.Longueur * r.Largeur,
    Cercle c    => Math.PI * c.Rayon * c.Rayon,
    null        => throw new ArgumentNullException(nameof(forme)),
    _           => throw new ArgumentException("Forme inconnue", nameof(forme))
};

// Property patterns dans switch expression
string ClassifierRectangle(Rectangle r) => r switch
{
    { Longueur: 0, Largeur: 0 }          => "Point",
    { Longueur: var l, Largeur: var w } when l == w => "Carré",
    { Longueur: > 10 }                   => "Long rectangle",
    { Largeur: > 10 }                    => "Large rectangle",
    _                                    => "Rectangle ordinaire"
};
```


### Avec tuples

```
// Uniquement disponible dans .NET Core 3.0+ et .NET 8
string ClassifierPoint(int x, int y) => (x, y) switch
{
    (0, 0)                  => "Origine",
    (var a, var b) when a == b  => "Sur la diagonale",
    (> 0, > 0)               => "Premier quadrant",
    (< 0, > 0)               => "Deuxième quadrant",
    (< 0, < 0)               => "Troisième quadrant",
    (> 0, < 0)               => "Quatrième quadrant",
    (0, _)                  => "Sur l'axe X",
    (_, 0)                  => "Sur l'axe Y",
    _                       => "Position quelconque"
};

// Expression switch avec deconstruction
public record Coordonnées(int X, int Y);

string ClassifierCoordonnées(Coordonnées coords) => coords switch
{
    (0, 0)                     => "Origine",
    (var x, var y) when x == y => "Sur la diagonale",
    (> 0, > 0)                 => "Premier quadrant",
    _                          => "Autre position"
};
```


### Avec discard pattern

```
// Uniquement disponible dans .NET Core 3.0+ et .NET 8
// Le pattern discard (_) ignore la valeur
bool EstPoint(Coordonnées coords) => coords switch
{
    (0, 0) => true,
    _      => false
};

// Discard partiel avec tuple
string DécrirePosition((int, int, int) position) => position switch
{
    (0, 0, 0)       => "Origine",
    (var x, 0, 0)   => $"Sur l'axe X à {x}",
    (0, var y, 0)   => $"Sur l'axe Y à {y}",
    (0, 0, var z)   => $"Sur l'axe Z à {z}",
    (_, _, > 100)   => "Point éloigné sur l'axe Z",
    (> 10, > 10, _) => "Point éloigné sur X et Y",
    _               => "Point quelconque"
};
```


### Simulation dans .NET Framework 4.7.2

Les switch expressions ne sont pas disponibles en .NET Framework 4.7.2, mais on peut simuler leur comportement avec des méthodes et des instructions switch traditionnelles :

```
// En .NET Framework 4.7.2 (simulation)
enum Saison { Printemps, Été, Automne, Hiver }

string ObtenirMessageSaison(Saison saison)
{
    switch (saison)
    {
        case Saison.Printemps: return "Les fleurs s'épanouissent";
        case Saison.Été: return "Il fait chaud";
        case Saison.Automne: return "Les feuilles tombent";
        case Saison.Hiver: return "Il neige";
        default: return "Saison inconnue";
    }
}

int ObtenirTempératureSaison(Saison saison)
{
    switch (saison)
    {
        case Saison.Hiver: return -5;
        case Saison.Printemps: return 15;
        case Saison.Été: return 25;
        case Saison.Automne: return 10;
        default: return 0;
    }
}
```


### Avantages des switch expressions

Les switch expressions offrent plusieurs avantages par rapport aux instructions switch traditionnelles :

1. **Concision** : Syntaxe plus compacte, particulièrement avec les flèches d'expression (`=>`)
2. **Sécurité** : Pas besoin de `break` pour éviter la cascade d'exécution
3. **Expressivité** : Peuvent être utilisées dans des expressions et retourner des valeurs directement
4. **Pattern matching avancé** : Support de tous les types de patterns (type, property, tuple, etc.)
5. **Exhaustivité** : Le compilateur peut vérifier que tous les cas sont couverts

---

Les structures de contrôle sont les blocs de construction fondamentaux de la logique de programmation. C# offre un ensemble complet de structures conditionnelles et de boucles, ainsi que des fonctionnalités modernes comme le pattern matching et les switch expressions. Ces dernières, disponibles uniquement dans les versions récentes de C#, permettent d'écrire du code plus expressif et concis. La maîtrise de ces structures est essentielle pour développer des applications efficaces et maintenues en C#.
