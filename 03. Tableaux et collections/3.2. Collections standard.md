# 3.2. Collections standard

![Collections standard en C#](https://via.placeholder.com/600x150?text=Collections+standard+en+C%23)

Les collections standard en C# offrent des structures de données plus flexibles que les tableaux traditionnels. Contrairement aux tableaux qui ont une taille fixe, la plupart des collections peuvent grandir dynamiquement selon les besoins. Le framework .NET fournit un riche ensemble de collections génériques, offrant sécurité de type et meilleures performances.

Toutes les collections standard sont regroupées principalement dans l'espace de noms `System.Collections.Generic`.

## 3.2.1. List<T>

`List<T>` est l'une des collections les plus utilisées. Elle représente une liste fortement typée d'objets accessibles par index, similaire à un tableau mais avec une taille dynamique.

### Création et initialisation

```
// Différentes façons de créer une List<T>
List<int> nombres = new List<int>();                  // Liste vide
List<string> noms = new List<string>                  // Avec initialisation
{
    "Alice",
    "Bob",
    "Charlie"
};
List<double> valeurs = new List<double>(100);         // Capacité initiale
List<char> lettres = new List<char>(new[] { 'a', 'b', 'c' });  // À partir d'un tableau

// Avec inférence de type (à partir de C# 3.0)
var fruits = new List<string> { "Pomme", "Banane", "Orange" };
```


### Ajout et insertion d'éléments

```
List<string> animaux = new List<string>();

// Ajout à la fin de la liste
animaux.Add("Chat");
animaux.Add("Chien");

// Ajout de plusieurs éléments à la fois
animaux.AddRange(new[] { "Lapin", "Hamster" });

// Insertion à un index spécifique
animaux.Insert(1, "Oiseau");        // Insère "Oiseau" à l'index 1
animaux.InsertRange(3, new[] { "Poisson", "Tortue" });  // Insère à partir de l'index 3

// Résultat: [Chat, Oiseau, Chien, Poisson, Tortue, Lapin, Hamster]
```


### Accès aux éléments

```
List<int> nombres = new List<int> { 10, 20, 30, 40, 50 };

// Accès par index (comme un tableau)
int premier = nombres[0];            // 10
int dernier = nombres[nombres.Count - 1];  // 50

// Modification par index
nombres[1] = 25;                     // La liste devient [10, 25, 30, 40, 50]

// Accès .NET 8 (Index et Range) - non disponible en .NET Framework 4.7.2
// int dernierElement = nombres[^1];    // 50 (dernier élément)
// List<int> sous = nombres[1..4];      // [25, 30, 40] (du second au quatrième)

// Propriétés
int taille = nombres.Count;          // Nombre d'éléments (5)
int capacité = nombres.Capacity;     // Capacité interne (peut être > Count)
```


### Recherche d'éléments

```
List<string> fruits = new List<string> { "Pomme", "Banane", "Orange", "Pomme", "Kiwi" };

// Recherche de base
bool contient = fruits.Contains("Banane");        // true
int index = fruits.IndexOf("Pomme");              // 0 (premier index)
int dernierIndex = fruits.LastIndexOf("Pomme");   // 3 (dernier index)
int indexIntrouvable = fruits.IndexOf("Ananas");  // -1 (non trouvé)

// Recherche avec prédicat
string premier = fruits.Find(f => f.StartsWith("O"));        // "Orange"
List<string> tous = fruits.FindAll(f => f.Length > 5);       // ["Banane", "Orange"]
int indexTrouvé = fruits.FindIndex(f => f.Contains("wi"));   // 4 (index de "Kiwi")
int dernierIndexTrouvé = fruits.FindLastIndex(f => f.Length == 5);  // 3 ("Pomme")
```


### Modification et suppression

```
List<int> nombres = new List<int> { 10, 20, 30, 40, 50 };

// Suppression par valeur (première occurrence)
nombres.Remove(30);                  // Supprime 30, retourne true si trouvé
                                     // Liste devient [10, 20, 40, 50]

// Suppression par index
nombres.RemoveAt(0);                 // Supprime l'élément à l'index 0 (10)
                                     // Liste devient [20, 40, 50]

// Suppression par plage
nombres.RemoveRange(1, 1);           // Supprime 1 élément à partir de l'index 1
                                     // Liste devient [20, 50]

// Suppression par prédicat
nombres.RemoveAll(n => n > 30);      // Supprime tous les éléments > 30
                                     // Liste devient [20]

// Suppression de tous les éléments
nombres.Clear();                     // Liste vide []
```


### Tri et autres opérations

```
List<string> noms = new List<string> { "David", "Alice", "Charlie", "Bob" };

// Tri de la liste (modifie la liste originale)
noms.Sort();                         // ["Alice", "Bob", "Charlie", "David"]

// Tri avec comparateur personnalisé
noms.Sort((a, b) => a.Length.CompareTo(b.Length));  // Tri par longueur

// Inversion de l'ordre
noms.Reverse();                      // Inverse l'ordre actuel

// Applicataion d'une action à chaque élément
noms.ForEach(nom => Console.WriteLine(nom));

// Conversion en tableau
string[] tableau = noms.ToArray();

// Efficacité mémoire
noms.TrimExcess();                   // Réduit la capacité pour correspondre au Count
```


### Performances et complexité

```
// Bonnes pratiques pour les performances
List<int> grands = new List<int>(10000);  // Allocation avec capacité initiale

// Performances des opérations:
// Add/Insert à la fin: O(1) en moyenne (amortie)
// Insert au début/milieu: O(n)
// RemoveAt: O(n)
// IndexOf/Contains: O(n)
// Sort: O(n log n)
// Accès par index: O(1)
```


## 3.2.2. Dictionary<TKey, TValue>

`Dictionary<TKey, TValue>` implémente une table de hachage qui associe des clés à des valeurs, permettant un accès rapide par clé.

### Création et initialisation

```
// Création de base
Dictionary<string, int> âges = new Dictionary<string, int>();

// Avec initialisation
Dictionary<int, string> codes = new Dictionary<int, string>
{
    { 200, "OK" },
    { 404, "Not Found" },
    { 500, "Internal Server Error" }
};

// Initialisation avec KeyValuePair (C# 6.0+)
Dictionary<string, bool> paramètres = new Dictionary<string, bool>
{
    ["debug"] = true,
    ["cache"] = false,
    ["notifications"] = true
};

// Avec comparateur de clés personnalisé
Dictionary<string, double> scores = new Dictionary<string, double>(
    StringComparer.OrdinalIgnoreCase);  // Insensible à la casse
```


### Ajout et modification

```
Dictionary<string, int> notes = new Dictionary<string, int>();

// Ajout d'éléments
notes.Add("Alice", 85);              // Ajoute une paire clé-valeur

// Syntaxe d'indexation (ajoute ou modifie)
notes["Bob"] = 92;                   // Ajoute si la clé n'existe pas
notes["Alice"] = 87;                 // Modifie la valeur si la clé existe

// Ajout conditionnel
if (!notes.ContainsKey("Charlie"))
{
    notes.Add("Charlie", 78);
}

// TryAdd (.NET Standard 2.1+, .NET Core 2.0+ et .NET 8)
// Non disponible en .NET Framework 4.7.2
// notes.TryAdd("David", 90);         // Retourne true si l'ajout réussit
```


### Accès aux éléments

```
Dictionary<string, int> notes = new Dictionary<string, int>
{
    { "Alice", 85 },
    { "Bob", 92 },
    { "Charlie", 78 }
};

// Accès par clé (lance KeyNotFoundException si la clé n'existe pas)
int noteAlice = notes["Alice"];      // 85

// Vérification avant accès
if (notes.ContainsKey("David"))
{
    int noteDavid = notes["David"];
}

// Méthode recommandée : TryGetValue
if (notes.TryGetValue("Bob", out int noteBob))
{
    Console.WriteLine($"Note de Bob: {noteBob}");
}
else
{
    Console.WriteLine("Bob n'est pas dans le dictionnaire");
}
```


### Suppression d'éléments

```
Dictionary<string, int> notes = new Dictionary<string, int>
{
    { "Alice", 85 },
    { "Bob", 92 },
    { "Charlie", 78 }
};

// Suppression par clé
bool supprimé = notes.Remove("Bob");  // Supprime et retourne true si la clé existait

// Suppression avec pattern out et vérification (.NET Core 2.0+ et .NET 8)
// Non disponible en .NET Framework 4.7.2
// if (notes.Remove("Charlie", out int ancienneValeur))
// {
//     Console.WriteLine($"Valeur supprimée: {ancienneValeur}");
// }

// Suppression de tous les éléments
notes.Clear();
```


### Parcours du dictionnaire

```
Dictionary<string, int> notes = new Dictionary<string, int>
{
    { "Alice", 85 },
    { "Bob", 92 },
    { "Charlie", 78 }
};

// Parcours complet
foreach (KeyValuePair<string, int> paire in notes)
{
    Console.WriteLine($"{paire.Key}: {paire.Value}");
}

// Syntaxe de décomposition (C# 7.0+)
foreach (var (nom, note) in notes)
{
    Console.WriteLine($"{nom}: {note}");
}

// Parcours des clés uniquement
foreach (string nom in notes.Keys)
{
    Console.WriteLine(nom);
}

// Parcours des valeurs uniquement
foreach (int note in notes.Values)
{
    Console.WriteLine(note);
}

// Conversion en collections
ICollection<string> noms = notes.Keys;
ICollection<int> toutesNotes = notes.Values;
```


### Performances et complexité

```
// Meilleures pratiques
Dictionary<string, int> grand = new Dictionary<string, int>(10000);  // Capacité initiale

// Performances des opérations:
// Add/TryGetValue/ContainsKey: O(1) en moyenne
// Énumération: O(n)
// Redimensionnement interne: coûteux, éviter avec une bonne capacité initiale
```


## 3.2.3. HashSet<T>

`HashSet<T>` représente un ensemble de valeurs uniques sans ordre particulier, optimisé pour les opérations d'ensemble (union, intersection, etc.).

### Création et initialisation

```
// Création de base
HashSet<int> ensemble = new HashSet<int>();

// Avec initialisation
HashSet<string> fruits = new HashSet<string>
{
    "Pomme",
    "Banane",
    "Orange"
};

// À partir d'une collection existante
string[] légumes = { "Carotte", "Tomate", "Carotte" };  // Note: doublon
HashSet<string> ensembleLégumes = new HashSet<string>(légumes);
// Contient uniquement "Carotte" et "Tomate" (les doublons sont éliminés)

// Avec comparateur personnalisé
HashSet<string> motsInsensibles = new HashSet<string>(
    StringComparer.OrdinalIgnoreCase);  // Insensible à la casse
```


### Ajout et suppression d'éléments

```
HashSet<int> nombres = new HashSet<int>();

// Ajout d'éléments (retourne true si l'élément a été ajouté)
bool ajouté1 = nombres.Add(10);      // true
bool ajouté2 = nombres.Add(20);      // true
bool ajouté3 = nombres.Add(10);      // false (déjà présent)

// Suppression d'éléments
bool supprimé = nombres.Remove(20);  // true (20 a été supprimé)
bool nonSupprimé = nombres.Remove(30);  // false (30 n'était pas présent)

// Suppression par prédicat
nombres.RemoveWhere(n => n > 15);    // Supprime tous les éléments > 15

// Suppression de tous les éléments
nombres.Clear();
```


### Opérations d'ensemble

```
HashSet<int> ensemble1 = new HashSet<int> { 1, 2, 3, 4, 5 };
HashSet<int> ensemble2 = new HashSet<int> { 3, 4, 5, 6, 7 };

// Test d'appartenance
bool contient = ensemble1.Contains(3);  // true

// Union (modifie ensemble1)
ensemble1.UnionWith(ensemble2);      // {1, 2, 3, 4, 5, 6, 7}

// Intersection (modifie ensemble1)
ensemble1 = new HashSet<int> { 1, 2, 3, 4, 5 };  // Réinitialisation
ensemble1.IntersectWith(ensemble2);  // {3, 4, 5}

// Différence (modifie ensemble1)
ensemble1 = new HashSet<int> { 1, 2, 3, 4, 5 };  // Réinitialisation
ensemble1.ExceptWith(ensemble2);     // {1, 2}

// Différence symétrique (modifie ensemble1)
ensemble1 = new HashSet<int> { 1, 2, 3, 4, 5 };  // Réinitialisation
ensemble1.SymmetricExceptWith(ensemble2);  // {1, 2, 6, 7}

// Tests sur les ensembles
bool estSousEnsemble = ensemble1.IsSubsetOf(ensemble2);  // false
bool estSuperEnsemble = ensemble1.IsSupersetOf(ensemble2);  // false
bool sontDisjoints = ensemble1.IsProperSubsetOf(ensemble2);  // false
bool seChevauchent = ensemble1.Overlaps(ensemble2);  // true
```


### Parcours et conversion

```
HashSet<string> fruits = new HashSet<string> { "Pomme", "Banane", "Orange" };

// Parcours (ordre non garanti)
foreach (string fruit in fruits)
{
    Console.WriteLine(fruit);
}

// Conversion en tableau ou liste
string[] tableau = fruits.ToArray();
List<string> liste = fruits.ToList();

// Vérification d'une condition sur tous les éléments
bool tousPlusDe4Lettres = fruits.All(f => f.Length > 4);
bool auMoinsUn5Lettres = fruits.Any(f => f.Length == 5);
```


### Performances et complexité

```
// Meilleures pratiques
HashSet<string> grand = new HashSet<string>(10000);  // Capacité initiale

// Performances des opérations:
// Add/Remove/Contains: O(1) en moyenne
// UnionWith/IntersectWith: O(n)
// SetEquals: O(n)
```


## 3.2.4. Queue<T> et Stack<T>

Ces collections implémentent respectivement une file d'attente (FIFO - First In, First Out) et une pile (LIFO - Last In, First Out).

### Queue<T> (File d'attente)

```
// Création et initialisation
Queue<string> file = new Queue<string>();
Queue<int> nombres = new Queue<int>(new[] { 1, 2, 3 });

// Ajout d'éléments (à la fin de la file)
file.Enqueue("Premier");
file.Enqueue("Deuxième");
file.Enqueue("Troisième");  // État: ["Premier", "Deuxième", "Troisième"]

// Consultation sans suppression (élément en tête)
string prochain = file.Peek();  // "Premier" (lance InvalidOperationException si vide)

// Suppression et récupération (de la tête)
string premier = file.Dequeue();  // "Premier" (lance InvalidOperationException si vide)
                                  // État: ["Deuxième", "Troisième"]

// Vérification
bool contient = file.Contains("Deuxième");  // true
int compteur = file.Count;  // 2

// Parcours sécurisé
while (file.Count > 0)
{
    string élément = file.Dequeue();
    Console.WriteLine(élément);
}

// TryDequeue et TryPeek (.NET Standard 2.1+, .NET Core 2.0+ et .NET 8)
// Non disponibles en .NET Framework 4.7.2
// if (file.TryDequeue(out string résultat))
// {
//     Console.WriteLine(résultat);
// }
```


### Stack<T> (Pile)

```
// Création et initialisation
Stack<int> pile = new Stack<int>();
Stack<char> caractères = new Stack<char>(new[] { 'a', 'b', 'c' });
// Notez que les éléments sont empilés dans l'ordre inverse, donc 'c' sera au sommet

// Ajout d'éléments (au sommet)
pile.Push(1);
pile.Push(2);
pile.Push(3);  // État: [3, 2, 1] (3 est au sommet)

// Consultation sans suppression (sommet)
int sommet = pile.Peek();  // 3 (lance InvalidOperationException si vide)

// Suppression et récupération (du sommet)
int premier = pile.Pop();  // 3 (lance InvalidOperationException si vide)
                           // État: [2, 1]

// Vérification
bool contient = pile.Contains(1);  // true
int compteur = pile.Count;  // 2

// Parcours sécurisé (du sommet vers le bas)
while (pile.Count > 0)
{
    int élément = pile.Pop();
    Console.WriteLine(élément);
}

// TryPop et TryPeek (.NET Standard 2.1+, .NET Core 2.0+ et .NET 8)
// Non disponibles en .NET Framework 4.7.2
// if (pile.TryPop(out int valeur))
// {
//     Console.WriteLine(valeur);
// }
```


### Cas d'utilisation

```
// Exemple d'utilisation de Queue<T> : file d'attente d'impression
Queue<string> fileImpression = new Queue<string>();
fileImpression.Enqueue("Document1.pdf");
fileImpression.Enqueue("Photo.jpg");
fileImpression.Enqueue("Rapport.docx");

void TraiterImpression()
{
    if (fileImpression.Count > 0)
    {
        string document = fileImpression.Dequeue();
        Console.WriteLine($"Impression de {document}");
    }
}

// Exemple d'utilisation de Stack<T> : historique de navigation
Stack<string> historique = new Stack<string>();
historique.Push("https://www.exemple.com/accueil");
historique.Push("https://www.exemple.com/produits");
historique.Push("https://www.exemple.com/produits/details");

void RetourArrière()
{
    if (historique.Count > 1)
    {
        historique.Pop();  // Page courante
        string pagePrécédente = historique.Peek();
        Console.WriteLine($"Retour à {pagePrécédente}");
    }
}
```


## 3.2.5. LinkedList<T>

`LinkedList<T>` implémente une liste doublement chaînée, permettant des insertions et suppressions efficaces à n'importe quelle position.

### Création et initialisation

```
// Création de base
LinkedList<int> liste = new LinkedList<int>();

// Avec initialisation à partir d'une collection
LinkedList<string> mots = new LinkedList<string>(
    new[] { "premier", "deuxième", "troisième" });
```


### Ajout d'éléments

```
LinkedList<string> liste = new LinkedList<string>();

// Ajout au début et à la fin
liste.AddFirst("Début");              // ["Début"]
liste.AddLast("Fin");                 // ["Début", "Fin"]

// Obtention des nœuds
LinkedListNode<string> premier = liste.First;
LinkedListNode<string> dernier = liste.Last;

// Ajout relatif à un nœud
liste.AddAfter(premier, "Milieu");    // ["Début", "Milieu", "Fin"]
liste.AddBefore(dernier, "AvantFin"); // ["Début", "Milieu", "AvantFin", "Fin"]

// Résultat final: ["Début", "Milieu", "AvantFin", "Fin"]
```


### Accès et navigation

```
LinkedList<string> liste = new LinkedList<string>(
    new[] { "un", "deux", "trois", "quatre" });

// Accès au premier et dernier nœud
LinkedListNode<string> premier = liste.First;
LinkedListNode<string> dernier = liste.Last;

// Accès aux valeurs
string valeurPremier = premier.Value;    // "un"
string valeurDernier = dernier.Value;    // "quatre"

// Navigation entre nœuds
LinkedListNode<string> deuxième = premier.Next;
LinkedListNode<string> avantDernier = dernier.Previous;

// Parcours de la liste vers l'avant
LinkedListNode<string> courant = liste.First;
while (courant != null)
{
    Console.WriteLine(courant.Value);
    courant = courant.Next;
}

// Parcours de la liste vers l'arrière
courant = liste.Last;
while (courant != null)
{
    Console.WriteLine(courant.Value);
    courant = courant.Previous;
}
```


### Recherche et suppression

```
LinkedList<string> liste = new LinkedList<string>(
    new[] { "un", "deux", "trois", "deux", "quatre" });

// Recherche de nœuds
LinkedListNode<string> nœud = liste.Find("deux");         // Premier "deux"
LinkedListNode<string> dernierNœud = liste.FindLast("deux");  // Dernier "deux"

// Vérification de présence
bool contient = liste.Contains("trois");  // true

// Suppression par valeur (première occurrence)
liste.Remove("deux");                     // ["un", "trois", "deux", "quatre"]

// Suppression par nœud
LinkedListNode<string> nœudTrois = liste.Find("trois");
if (nœudTrois != null)
{
    liste.Remove(nœudTrois);              // ["un", "deux", "quatre"]
}

// Suppression du premier et dernier
liste.RemoveFirst();                      // ["deux", "quatre"]
liste.RemoveLast();                       // ["deux"]

// Suppression de tous les éléments
liste.Clear();
```


### Cas d'utilisation

```
// Implémentation d'un cache LRU (Least Recently Used)
public class LRUCache<TKey, TValue>
{
    private readonly int _capacité;
    private readonly Dictionary<TKey, LinkedListNode<KeyValuePair<TKey, TValue>>> _cache;
    private readonly LinkedList<KeyValuePair<TKey, TValue>> _listeUtilisation;

    public LRUCache(int capacité)
    {
        _capacité = capacité;
        _cache = new Dictionary<TKey, LinkedListNode<KeyValuePair<TKey, TValue>>>(capacité);
        _listeUtilisation = new LinkedList<KeyValuePair<TKey, TValue>>();
    }

    public TValue Get(TKey clé)
    {
        if (!_cache.TryGetValue(clé, out var nœud))
        {
            return default;
        }

        // Déplacer vers le début (marqué comme récemment utilisé)
        _listeUtilisation.Remove(nœud);
        _listeUtilisation.AddFirst(nœud);
        return nœud.Value.Value;
    }

    public void Set(TKey clé, TValue valeur)
    {
        if (_cache.TryGetValue(clé, out var existant))
        {
            // Mettre à jour valeur existante
            _listeUtilisation.Remove(existant);
            var nœud = _listeUtilisation.AddFirst(new KeyValuePair<TKey, TValue>(clé, valeur));
            _cache[clé] = nœud;
            return;
        }

        // Vérifier la capacité
        if (_cache.Count >= _capacité)
        {
            // Supprimer le moins récemment utilisé
            var dernier = _listeUtilisation.Last;
            _listeUtilisation.RemoveLast();
            _cache.Remove(dernier.Value.Key);
        }

        // Ajouter nouvel élément
        var nouveauNœud = _listeUtilisation.AddFirst(new KeyValuePair<TKey, TValue>(clé, valeur));
        _cache.Add(clé, nouveauNœud);
    }
}
```


## 3.2.6. SortedList<TKey, TValue> et SortedDictionary<TKey, TValue>

Ces deux collections stockent des paires clé-valeur triées par clé, mais avec des implémentations différentes.

### SortedList<TKey, TValue>

`SortedList<TKey, TValue>` utilise un tableau trié en interne.

```
// Création et initialisation
SortedList<string, int> listeTriée = new SortedList<string, int>();
SortedList<int, string> codes = new SortedList<int, string>
{
    { 404, "Not Found" },
    { 200, "OK" },
    { 500, "Internal Server Error" }
};  // Sera automatiquement trié par clé: [200, 404, 500]

// Avec comparateur personnalisé
SortedList<string, double> scores = new SortedList<string, double>(
    StringComparer.OrdinalIgnoreCase);  // Insensible à la casse

// Ajout d'éléments
listeTriée.Add("Charlie", 35);
listeTriée.Add("Alice", 30);       // Les éléments sont automatiquement triés
listeTriée.Add("Bob", 25);         // État: [Alice:30, Bob:25, Charlie:35]

// Syntaxe d'indexation
listeTriée["David"] = 40;          // Ajoute si la clé n'existe pas
listeTriée["Bob"] = 28;            // Modifie si la clé existe

// Accès par index (spécifique à SortedList)
string premièreClé = listeTriée.Keys[0];    // "Alice"
int premièreValeur = listeTriée.Values[0];  // 30

// Accès par clé
int âgeCharlie = listeTriée["Charlie"];     // 35

// Accès sécurisé
if (listeTriée.TryGetValue("Eve", out int âgeEve))
{
    Console.WriteLine(âgeEve);
}

// Suppression
listeTriée.Remove("Bob");          // Supprime par clé
listeTriée.RemoveAt(0);            // Supprime par index (spécifique à SortedList)
```


### SortedDictionary<TKey, TValue>

`SortedDictionary<TKey, TValue>` utilise un arbre binaire de recherche en interne.

```
// Création et initialisation
SortedDictionary<string, int> dictionnaireTrié = new SortedDictionary<string, int>();
SortedDictionary<int, string> codes = new SortedDictionary<int, string>
{
    { 404, "Not Found" },
    { 200, "OK" },
    { 500, "Internal Server Error" }
};  // Sera automatiquement trié par clé: [200, 404, 500]

// Avec comparateur personnalisé
SortedDictionary<string, double> scores = new SortedDictionary<string, double>(
    StringComparer.OrdinalIgnoreCase);  // Insensible à la casse

// Les opérations sont identiques à Dictionary<TKey, TValue>
dictionnaireTrié.Add("Charlie", 35);
dictionnaireTrié.Add("Alice", 30);    // Les éléments sont automatiquement triés
dictionnaireTrié.Add("Bob", 25);      // État: [Alice:30, Bob:25, Charlie:35]

dictionnaireTrié["David"] = 40;       // Ajoute si la clé n'existe pas
dictionnaireTrié["Bob"] = 28;         // Modifie si la clé existe

// Accès sécurisé
if (dictionnaireTrié.TryGetValue("Alice", out int âgeAlice))
{
    Console.WriteLine(âgeAlice);
}

// Parcours (toujours dans l'ordre des clés)
foreach (var paire in dictionnaireTrié)
{
    Console.WriteLine($"{paire.Key}: {paire.Value}");
}
```


### Différences et choix entre SortedList et SortedDictionary

```
// SortedList vs SortedDictionary:

// 1. Structure interne:
// - SortedList: deux tableaux parallèles (clés et valeurs)
// - SortedDictionary: arbre binaire de recherche

// 2. Utilisation de mémoire:
// - SortedList: plus efficace en mémoire lorsque la taille est stable
// - SortedDictionary:
```
