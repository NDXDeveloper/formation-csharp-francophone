 
# 3.3. Collections spécialisées

![Collections spécialisées en C#](https://via.placeholder.com/600x150?text=Collections+sp%C3%A9cialis%C3%A9es+en+C%23)

Au-delà des collections standard comme `List<T>` et `Dictionary<TKey, TValue>`, le framework .NET offre des collections spécialisées conçues pour des scénarios particuliers comme la programmation concurrente, les données immuables, ou l'observation de changements. Cette section explore ces collections spécialisées et leurs cas d'utilisation.

## 3.3.1. Collections concurrentes (ConcurrentDictionary, etc.)

Les collections concurrentes dans l'espace de noms `System.Collections.Concurrent` sont conçues pour les scénarios multi-threads, offrant des opérations thread-safe sans nécessiter de verrouillage explicite.

### ConcurrentDictionary<TKey, TValue>

La plus utilisée des collections concurrentes, qui permet des accès simultanés en lecture et écriture de plusieurs threads.

```
using System.Collections.Concurrent;

// Création
var utilisateurs = new ConcurrentDictionary<string, User>();
var compteurs = new ConcurrentDictionary<string, int>();

// Ajout ou mise à jour atomique
bool ajouté = utilisateurs.TryAdd("user1", new User { Name = "Alice" });

// GetOrAdd - récupère la valeur si elle existe, sinon ajoute la nouvelle valeur
User alice = utilisateurs.GetOrAdd("user1", key => new User { Name = "Alice" });

// Mise à jour atomique avec fonction de transformation
int nouveauCompteur = compteurs.AddOrUpdate(
    "clics", // clé
    1,       // valeur à ajouter si la clé n'existe pas
    (key, oldValue) => oldValue + 1  // fonction à appliquer si la clé existe
);

// Suppression thread-safe
bool supprimé = utilisateurs.TryRemove("user1", out User utilisateurSupprimé);

// Mise à jour conditionnelle (compare-and-swap)
bool misÀJour = compteurs.TryUpdate("clics", 101, 100);  // Met à jour seulement si la valeur actuelle est 100

// Parcours thread-safe
foreach (var paire in utilisateurs)
{
    // Le dictionnaire peut être modifié en parallèle pendant l'énumération
    Console.WriteLine($"{paire.Key}: {paire.Value.Name}");
}
```


### ConcurrentQueue<T>

File d'attente thread-safe pour les scénarios producteur-consommateur.

```
// Création
var tâches = new ConcurrentQueue<string>();

// Ajout à la fin de la file (thread-safe)
tâches.Enqueue("Tâche 1");
tâches.Enqueue("Tâche 2");
tâches.Enqueue("Tâche 3");

// Tentative de récupération (sans lever d'exception)
if (tâches.TryDequeue(out string tâche))
{
    Console.WriteLine($"Traitement de: {tâche}");
}
else
{
    Console.WriteLine("La file est vide");
}

// Consultation sans suppression
if (tâches.TryPeek(out string prochaineTâche))
{
    Console.WriteLine($"Prochaine tâche: {prochaineTâche}");
}

// Vérification
bool estVide = tâches.IsEmpty;
int compteur = tâches.Count;  // Attention: cette valeur peut changer immédiatement après l'accès

// Exemple d'utilisation dans un environnement multi-threads
Task[] producteurs = new Task[3];
Task[] consommateurs = new Task[2];

for (int i = 0; i < producteurs.Length; i++)
{
    producteurs[i] = Task.Run(() =>
    {
        for (int j = 0; j < 100; j++)
        {
            tâches.Enqueue($"Tâche {Guid.NewGuid()}");
            Thread.Sleep(10);  // Simulation de travail
        }
    });
}

for (int i = 0; i < consommateurs.Length; i++)
{
    consommateurs[i] = Task.Run(() =>
    {
        while (!tâches.IsEmpty || !Task.WhenAll(producteurs).IsCompleted)
        {
            if (tâches.TryDequeue(out string tâche))
            {
                Console.WriteLine($"Traitement: {tâche}");
                Thread.Sleep(20);  // Simulation de traitement
            }
            else
            {
                Thread.Sleep(1);  // Attente courte
            }
        }
    });
}

Task.WhenAll(producteurs.Concat(consommateurs)).Wait();
```


### ConcurrentStack<T>

Pile thread-safe qui implémente un comportement LIFO (Last-In-First-Out).

```
// Création
var historique = new ConcurrentStack<string>();

// Ajout au sommet (thread-safe)
historique.Push("Page d'accueil");
historique.Push("Catalogue");
historique.Push("Détail produit");

// Tentative de récupération (sans lever d'exception)
if (historique.TryPop(out string dernièrePage))
{
    Console.WriteLine($"Retour à la page: {dernièrePage}");
}

// Push et Pop multiples (optimisé)
string[] nouvelles = { "Panier", "Paiement", "Confirmation" };
historique.PushRange(nouvelles);

string[] dernières = new string[2];
int récupérées = historique.TryPopRange(dernières);
Console.WriteLine($"Récupéré {récupérées} pages");
```


### ConcurrentBag<T>

Collection non ordonnée thread-safe qui permet les doublons.

```
// Création
var résultats = new ConcurrentBag<int>();

// Ajout (thread-safe)
résultats.Add(10);
résultats.Add(20);
résultats.Add(10);  // Les doublons sont autorisés

// Tentative de récupération (ordre non garanti)
if (résultats.TryTake(out int valeur))
{
    Console.WriteLine($"Valeur récupérée: {valeur}");
}

// Exemple pratique - calcul parallèle
Parallel.For(0, 1000, i =>
{
    int résultat = ExpensiveCalculation(i);
    résultats.Add(résultat);
});

Console.WriteLine($"Total des résultats: {résultats.Count}");

int ExpensiveCalculation(int input)
{
    // Simulation de calcul
    Thread.Sleep(1);
    return input * input;
}
```


### BlockingCollection<T>

Wrapper autour des collections concurrentes avec fonctionnalités de blocage pour les scénarios producteur-consommateur.

```
// Création avec une capacité maximale (utilise ConcurrentQueue<T> par défaut)
using var messages = new BlockingCollection<string>(boundedCapacity: 100);

// Producteur (bloque quand la collection est pleine)
Task producteur = Task.Run(() =>
{
    try
    {
        for (int i = 0; i < 200; i++)
        {
            string message = $"Message {i}";
            // Ajoute l'élément, attend si la collection est pleine
            messages.Add(message);
            Console.WriteLine($"Produit: {message}");
            Thread.Sleep(10);
        }
    }
    finally
    {
        // Signale qu'aucun élément ne sera plus ajouté
        messages.CompleteAdding();
    }
});

// Consommateurs (bloquent quand la collection est vide)
Task[] consommateurs = Enumerable.Range(0, 3).Select(_ => Task.Run(() =>
{
    // Traite les éléments jusqu'à ce que CompleteAdding soit appelé et que la collection soit vide
    foreach (string message in messages.GetConsumingEnumerable())
    {
        Console.WriteLine($"Consommé: {message} par {Task.CurrentId}");
        Thread.Sleep(50);  // Consommation plus lente que la production
    }
})).ToArray();

// Attendre que tout soit terminé
Task.WhenAll(producteur).Wait();
Task.WhenAll(consommateurs).Wait();
```


### Différences entre .NET Framework 4.7.2 et .NET 8

Les collections concurrentes sont disponibles dans les deux versions, mais .NET 8 apporte quelques améliorations :

```
// Disponible dans les deux versions
using System.Collections.Concurrent;

var dict = new ConcurrentDictionary<string, int>();

// .NET Core 2.0+ et .NET 8 (pas en .NET Framework 4.7.2)
// dict.TryRemove("key", out int _);  // Version sans capturer la valeur

// En .NET 8, certaines méthodes ont des performances améliorées
// et une meilleure intégration avec les fonctionnalités récentes comme Span<T>
```


## 3.3.2. Collections immuables (ImmutableList, etc.)

Les collections immuables, disponibles dans l'espace de noms `System.Collections.Immutable`, ne peuvent pas être modifiées après leur création. Chaque "modification" crée une nouvelle instance.

> **Note:** Pour .NET Framework 4.7.2, les collections immuables sont disponibles via le package NuGet `System.Collections.Immutable`. Dans .NET Core et .NET 8, elles sont intégrées au framework.

### ImmutableArray<T>

Collection immuable optimisée pour les lectures rapides.

```
using System.Collections.Immutable;

// Création
ImmutableArray<int> nombres = ImmutableArray.Create(1, 2, 3, 4, 5);
ImmutableArray<string> vide = ImmutableArray<string>.Empty;

// À partir d'une collection existante
var liste = new List<int> { 1, 2, 3 };
ImmutableArray<int> immuable = liste.ToImmutableArray();

// "Modification" (crée une nouvelle instance)
ImmutableArray<int> ajouté = nombres.Add(6);        // Originale inchangée
ImmutableArray<int> inséré = nombres.Insert(0, 0);  // Originale inchangée
ImmutableArray<int> retiré = nombres.RemoveAt(0);   // Originale inchangée

// Accès (comme un tableau normal)
int premier = nombres[0];  // 1

// Parcours
foreach (int n in nombres)
{
    Console.WriteLine(n);
}

// Conversion
int[] tableau = nombres.ToArray();
List<int> liste2 = nombres.ToList();
```


### ImmutableList<T>

Liste immuable avec insertion et suppression efficaces.

```
// Création
ImmutableList<string> fruits = ImmutableList.Create("Pomme", "Banane", "Orange");
ImmutableList<double> vide = ImmutableList<double>.Empty;

// À partir d'une collection existante
var liste = new List<string> { "A", "B", "C" };
ImmutableList<string> immuable = liste.ToImmutableList();

// "Modification" (crée une nouvelle instance)
ImmutableList<string> ajouté = fruits.Add("Kiwi");
ImmutableList<string> inséré = fruits.Insert(1, "Fraise");
ImmutableList<string> retiré = fruits.Remove("Banane");
ImmutableList<string> remplacé = fruits.Replace("Orange", "Ananas");

// Chaînage d'opérations
ImmutableList<string> modifié = fruits
    .Add("Kiwi")
    .AddRange(new[] { "Mangue", "Citron" })
    .Remove("Banane");

// Builder pattern pour des modifications multiples
var builder = fruits.ToBuilder();
builder.Add("Kiwi");
builder.Remove("Banane");
builder.Insert(0, "Fraise");
ImmutableList<string> résultat = builder.ToImmutable();
```


### ImmutableDictionary<TKey, TValue>

Dictionnaire immuable.

```
// Création
ImmutableDictionary<string, int> âges = ImmutableDictionary.Create<string, int>()
    .Add("Alice", 30)
    .Add("Bob", 25)
    .Add("Charlie", 35);

ImmutableDictionary<int, string> vide = ImmutableDictionary<int, string>.Empty;

// À partir d'un dictionnaire existant
var dict = new Dictionary<string, bool> { { "A", true }, { "B", false } };
ImmutableDictionary<string, bool> immuable = dict.ToImmutableDictionary();

// "Modification" (crée une nouvelle instance)
ImmutableDictionary<string, int> ajouté = âges.Add("David", 28);
ImmutableDictionary<string, int> retiré = âges.Remove("Bob");
ImmutableDictionary<string, int> modifié = âges.SetItem("Alice", 31);

// Accès
if (âges.TryGetValue("Alice", out int âgeAlice))
{
    Console.WriteLine($"Alice a {âgeAlice} ans");
}

// Parcours
foreach (var paire in âges)
{
    Console.WriteLine($"{paire.Key}: {paire.Value}");
}
```


### Autres collections immuables

```
// ImmutableHashSet<T>
ImmutableHashSet<int> ensemble = ImmutableHashSet.Create(1, 2, 3, 4);
ImmutableHashSet<int> ajouté = ensemble.Add(5);
ImmutableHashSet<int> retiré = ensemble.Remove(1);
ImmutableHashSet<int> union = ensemble.Union(ImmutableHashSet.Create(5, 6, 7));

// ImmutableSortedDictionary<TKey, TValue>
ImmutableSortedDictionary<string, int> triéDict = ImmutableSortedDictionary
    .Create<string, int>(StringComparer.OrdinalIgnoreCase)
    .Add("Charlie", 35)
    .Add("Alice", 30)
    .Add("Bob", 25);  // Sera trié par clé

// ImmutableSortedSet<T>
ImmutableSortedSet<string> triéSet = ImmutableSortedSet
    .Create<string>(StringComparer.OrdinalIgnoreCase, "Charlie", "Alice", "Bob");

// ImmutableQueue<T>
ImmutableQueue<string> file = ImmutableQueue.Create("Premier", "Deuxième");
ImmutableQueue<string> ajoutéFile = file.Enqueue("Troisième");
ImmutableQueue<string> retiréFile = ajoutéFile.Dequeue(out string valeur);

// ImmutableStack<T>
ImmutableStack<string> pile = ImmutableStack.Create("Sommet", "Milieu");
ImmutableStack<string> ajoutéPile = pile.Push("Nouveau sommet");
ImmutableStack<string> retiréPile = ajoutéPile.Pop(out string sommet);
```


### Cas d'utilisation des collections immuables

```
// 1. Caching de données partagées en lecture seule
public class ArticleService
{
    // Collection partagée thread-safe sans verrouillage
    private ImmutableDictionary<int, Article> _articlesCache = ImmutableDictionary<int, Article>.Empty;

    public void MettreÀJourCache(IEnumerable<Article> articles)
    {
        // Création atomique d'un nouveau cache (thread-safe)
        ImmutableDictionary<int, Article>.Builder builder = _articlesCache.ToBuilder();

        foreach (var article in articles)
        {
            builder[article.Id] = article;
        }

        // Remplacement atomique (les autres threads continuent à utiliser l'ancienne version)
        Interlocked.Exchange(ref _articlesCache, builder.ToImmutable());
    }

    public Article ObtenirArticle(int id)
    {
        return _articlesCache.TryGetValue(id, out var article) ? article : null;
    }
}

// 2. Historique de modifications (Undo/Redo)
public class DocumentEditor
{
    private ImmutableList<string> _contenuCourant = ImmutableList<string>.Empty;
    private Stack<ImmutableList<string>> _historique = new Stack<ImmutableList<string>>();
    private Stack<ImmutableList<string>> _annulations = new Stack<ImmutableList<string>>();

    public void AjouterLigne(string ligne)
    {
        _historique.Push(_contenuCourant);
        _contenuCourant = _contenuCourant.Add(ligne);
        _annulations.Clear();
    }

    public bool Annuler()
    {
        if (_historique.Count > 0)
        {
            _annulations.Push(_contenuCourant);
            _contenuCourant = _historique.Pop();
            return true;
        }
        return false;
    }

    public bool Rétablir()
    {
        if (_annulations.Count > 0)
        {
            _historique.Push(_contenuCourant);
            _contenuCourant = _annulations.Pop();
            return true;
        }
        return false;
    }
}
```


## 3.3.3. Collections observables (ObservableCollection)

Les collections observables permettent d'être notifié lorsque leur contenu change. Elles sont particulièrement utiles dans les applications avec interface utilisateur comme WPF, UWP et Xamarin.Forms.

### ObservableCollection<T>

La classe `ObservableCollection<T>` implémente les interfaces `INotifyPropertyChanged` et `INotifyCollectionChanged`.

```
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Collections.Specialized;

// Création
var personnes = new ObservableCollection<string> { "Alice", "Bob", "Charlie" };

// Abonnement aux événements de changement
personnes.CollectionChanged += (sender, e) =>
{
    switch (e.Action)
    {
        case NotifyCollectionChangedAction.Add:
            Console.WriteLine($"Ajouté: {string.Join(", ", e.NewItems.Cast<string>())}");
            break;
        case NotifyCollectionChangedAction.Remove:
            Console.WriteLine($"Supprimé: {string.Join(", ", e.OldItems.Cast<string>())}");
            break;
        case NotifyCollectionChangedAction.Replace:
            Console.WriteLine($"Remplacé: {string.Join(", ", e.OldItems.Cast<string>())} par {string.Join(", ", e.NewItems.Cast<string>())}");
            break;
        case NotifyCollectionChangedAction.Move:
            Console.WriteLine($"Déplacé depuis {e.OldStartingIndex} vers {e.NewStartingIndex}");
            break;
        case NotifyCollectionChangedAction.Reset:
            Console.WriteLine("Collection réinitialisée");
            break;
    }
};

// Modifications (déclenchent les événements)
personnes.Add("David");          // Déclenche CollectionChanged (Add)
personnes.Remove("Bob");         // Déclenche CollectionChanged (Remove)
personnes[0] = "Alice Smith";    // Déclenche CollectionChanged (Replace)
personnes.Move(0, 2);            // Déclenche CollectionChanged (Move)
personnes.Clear();               // Déclenche CollectionChanged (Reset)

// Utilisé typiquement avec le data binding
// Exemple WPF:
// <ListBox ItemsSource="{Binding Personnes}" />
```


### Classe personnalisée observable

```
// Combinaison d'une collection observable avec des objets observables
public class Personne : INotifyPropertyChanged
{
    private string _nom;
    public string Nom
    {
        get => _nom;
        set
        {
            if (_nom != value)
            {
                _nom = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Nom)));
            }
        }
    }

    private int _âge;
    public int Âge
    {
        get => _âge;
        set
        {
            if (_âge != value)
            {
                _âge = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Âge)));
            }
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;
}

// Utilisation dans un ViewModel
public class MainViewModel
{
    public ObservableCollection<Personne> Personnes { get; } = new ObservableCollection<Personne>();

    public MainViewModel()
    {
        Personnes.Add(new Personne { Nom = "Alice", Âge = 30 });
        Personnes.Add(new Personne { Nom = "Bob", Âge = 25 });
    }

    public void AjouterPersonne(string nom, int âge)
    {
        Personnes.Add(new Personne { Nom = nom, Âge = âge });
    }

    public void VieillirTout()
    {
        foreach (var personne in Personnes)
        {
            personne.Âge++; // Déclenche PropertyChanged sur l'objet personne
        }
    }
}
```


### ReadOnlyObservableCollection<T>

Wrapper en lecture seule pour une collection observable.

```
public class PersonnesViewModel
{
    // Collection interne modifiable
    private ObservableCollection<Personne> _personnes = new ObservableCollection<Personne>();

    // Collection externe en lecture seule mais toujours observable
    private ReadOnlyObservableCollection<Personne> _personnesPubliques;
    public ReadOnlyObservableCollection<Personne> Personnes => _personnesPubliques;

    public PersonnesViewModel()
    {
        _personnesPubliques = new ReadOnlyObservableCollection<Personne>(_personnes);

        // Remplir avec des données initiales
        _personnes.Add(new Personne { Nom = "Alice", Âge = 30 });
        _personnes.Add(new Personne { Nom = "Bob", Âge = 25 });
    }

    // Le ViewModel contrôle les modifications
    public void AjouterPersonne(Personne personne)
    {
        _personnes.Add(personne);
        // La collection externe _personnesPubliques notifie automatiquement les observateurs
    }
}
```

## 3.3.4. ReadOnlyCollection et autres wrappers en lecture seule

Les wrappers en lecture seule permettent d'exposer des collections sans en autoriser la modification. Ils sont particulièrement utiles pour encapsuler des données internes et implémenter le principe du moindre privilège dans la conception d'API.

### ReadOnlyCollection<T>

`ReadOnlyCollection<T>` est un wrapper qui empêche la modification directe d'une collection, tout en permettant d'accéder à ses éléments.

```
using System.Collections.ObjectModel;

// Collection originale (privée)
List<int> données = new List<int> { 1, 2, 3, 4, 5 };

// Création d'un wrapper en lecture seule
ReadOnlyCollection<int> donnéesPubliques = new ReadOnlyCollection<int>(données);

// Tentative de modification (échoue à la compilation)
// donnéesPubliques.Add(6);        // Erreur de compilation
// donnéesPubliques[0] = 10;       // Erreur de compilation
// donnéesPubliques.Clear();       // Erreur de compilation

// Lecture autorisée
int premier = donnéesPubliques[0];   // 1
int taille = donnéesPubliques.Count; // 5
bool contient = donnéesPubliques.Contains(3); // true
int index = donnéesPubliques.IndexOf(4);      // 3

// ATTENTION: La collection sous-jacente peut toujours être modifiée
données.Add(6);
// Le wrapper reflète les changements de la collection source
Console.WriteLine(donnéesPubliques.Count); // 6
```


### ReadOnlyDictionary<TKey, TValue>

`ReadOnlyDictionary<TKey, TValue>` est l'équivalent pour les dictionnaires.

```
using System.Collections.ObjectModel;

// Dictionnaire original (privé)
Dictionary<string, int> scoresDictionary = new Dictionary<string, int>
{
    { "Alice", 95 },
    { "Bob", 80 },
    { "Charlie", 85 }
};

// Création d'un wrapper en lecture seule
ReadOnlyDictionary<string, int> scoresPublics =
    new ReadOnlyDictionary<string, int>(scoresDictionary);

// Tentative de modification (échoue à la compilation)
// scoresPublics.Add("David", 90);     // Erreur de compilation
// scoresPublics["Alice"] = 100;       // Erreur de compilation
// scoresPublics.Remove("Bob");        // Erreur de compilation

// Lecture autorisée
int scoreAlice = scoresPublics["Alice"];  // 95
bool contient = scoresPublics.ContainsKey("Bob"); // true
bool trouvé = scoresPublics.TryGetValue("Charlie", out int scoreCharlie); // true, scoreCharlie = 85

// Accès aux collections de clés et valeurs
IEnumerable<string> noms = scoresPublics.Keys;
IEnumerable<int> scores = scoresPublics.Values;

// Comme pour ReadOnlyCollection, la source peut être modifiée
scoresDictionary["David"] = 90;
Console.WriteLine(scoresPublics.ContainsKey("David")); // true
```


### Interfaces IReadOnlyList<T> et IReadOnlyDictionary<TKey, TValue>

Ces interfaces, introduites avec .NET Framework 4.5, permettent de travailler avec des collections en lecture seule de manière polymorphique.

```
// Méthode qui accepte n'importe quelle implémentation de IReadOnlyList<T>
void AfficherDonnées(IReadOnlyList<int> données)
{
    Console.WriteLine($"Nombre d'éléments: {données.Count}");

    for (int i = 0; i < données.Count; i++)
    {
        Console.WriteLine($"données[{i}] = {données[i]}");
    }
}

// Utilisation avec différentes collections
List<int> liste = new List<int> { 1, 2, 3 };
AfficherDonnées(liste);  // List<T> implémente IReadOnlyList<T>

ReadOnlyCollection<int> ro = new ReadOnlyCollection<int>(liste);
AfficherDonnées(ro);     // ReadOnlyCollection<T> implémente IReadOnlyList<T>

int[] tableau = { 4, 5, 6 };
AfficherDonnées(tableau);  // Les tableaux implémentent aussi IReadOnlyList<T>

// Méthode qui accepte n'importe quelle implémentation de IReadOnlyDictionary
void AfficherConfiguration(IReadOnlyDictionary<string, string> config)
{
    foreach (var paire in config)
    {
        Console.WriteLine($"{paire.Key} = {paire.Value}");
    }

    if (config.TryGetValue("timeout", out string timeout))
    {
        Console.WriteLine($"Timeout trouvé: {timeout}");
    }
}

// Utilisation
Dictionary<string, string> paramètres = new Dictionary<string, string>
{
    { "timeout", "30" },
    { "maxRetries", "3" }
};

AfficherConfiguration(paramètres);  // Dictionary<K,V> implémente IReadOnlyDictionary<K,V>
```


### Méthodes d'extension AsReadOnly() et AsReadOnlyList()

```
// AsReadOnly() pour les listes
List<string> mots = new List<string> { "un", "deux", "trois" };
ReadOnlyCollection<string> motsEnLectureSeulement = mots.AsReadOnly();

// L'extension AsReadOnlyList() (disponible via LINQ) retourne IReadOnlyList<T>
IReadOnlyList<string> motsReadOnly = mots.AsReadOnlyList();

// Les deux reflètent les changements de la source
mots.Add("quatre");
Console.WriteLine(motsEnLectureSeulement.Count);  // 4
Console.WriteLine(motsReadOnly.Count);            // 4
```


### Collections réellement immuables vs wrappers

Il est important de comprendre la différence entre les wrappers en lecture seule et les collections immuables :

```
// 1. Wrapper en lecture seule
List<int> source = new List<int> { 1, 2, 3 };
ReadOnlyCollection<int> readOnly = new ReadOnlyCollection<int>(source);

// 2. Collection réellement immuable (voir section 3.3.2)
using System.Collections.Immutable;
ImmutableList<int> immutable = ImmutableList.Create(1, 2, 3);
// ou
ImmutableList<int> fromSource = source.ToImmutableList();

// Différence clé: la modification de la source
source.Add(4);

Console.WriteLine(readOnly.Count);     // 4 - Le wrapper reflète les changements
Console.WriteLine(fromSource.Count);   // 3 - La collection immuable est une copie indépendante

// Avec les wrappers, l'encapsulation peut être brisée si la référence à la source est accessible
```


### Implémentation d'une encapsulation robuste

Pour une encapsulation efficace, combinez les wrappers en lecture seule avec une gestion prudente des références internes :

```
public class Catalogue
{
    // Collection interne privée
    private List<Produit> _produits = new List<Produit>();

    // Wrapper en lecture seule mis en cache
    private ReadOnlyCollection<Produit> _produitsReadOnly;

    // Propriété publique qui expose les données en lecture seule
    public ReadOnlyCollection<Produit> Produits
    {
        get
        {
            // Création à la demande (lazy initialization)
            return _produitsReadOnly ??= new ReadOnlyCollection<Produit>(_produits);
        }
    }

    // Méthodes contrôlées pour modifier la collection
    public void AjouterProduit(Produit produit)
    {
        if (produit == null) throw new ArgumentNullException(nameof(produit));

        // Validation supplémentaire si nécessaire
        if (string.IsNullOrEmpty(produit.Nom))
            throw new ArgumentException("Le nom du produit ne peut être vide");

        _produits.Add(produit);
    }

    public bool SupprimerProduit(int id)
    {
        return _produits.RemoveAll(p => p.Id == id) > 0;
    }

    // Ou encore mieux pour les types modifiables: retourner des copies défensives
    public List<Produit> ObtenirCopieDesProduits()
    {
        return _produits.Select(p => p.Clone()).ToList();
    }
}
```


### Création de collections typées en lecture seule

```
// Collection spécialisée en lecture seule
public class ProduitsCatalogue : ReadOnlyCollection<Produit>
{
    public ProduitsCatalogue(IList<Produit> liste) : base(liste)
    {
    }

    // Ajout de méthodes spécifiques qui préservent la nature "lecture seule"
    public IEnumerable<Produit> ParCatégorie(string catégorie)
    {
        return this.Where(p => p.Catégorie == catégorie);
    }

    public decimal PrixTotal()
    {
        return this.Sum(p => p.Prix);
    }

    public bool ContientCatégorie(string catégorie)
    {
        return this.Any(p => p.Catégorie == catégorie);
    }
}
```


### Pattern de wrapper générique

Pour faciliter la création de wrappers, vous pouvez implémenter un pattern réutilisable :

```
public class CollectionEnLectureSeule<T>
{
    private readonly List<T> _items = new List<T>();
    private readonly ReadOnlyCollection<T> _readOnlyView;

    public CollectionEnLectureSeule()
    {
        _readOnlyView = new ReadOnlyCollection<T>(_items);
    }

    public CollectionEnLectureSeule(IEnumerable<T> items)
    {
        _items = new List<T>(items);
        _readOnlyView = new ReadOnlyCollection<T>(_items);
    }

    public ReadOnlyCollection<T> AsReadOnly => _readOnlyView;

    // Méthodes de modification contrôlée
    public void Add(T item) => _items.Add(item);
    public void Remove(T item) => _items.Remove(item);
    public void Clear() => _items.Clear();
}

// Utilisation
var clients = new CollectionEnLectureSeule<Client>();
clients.Add(new Client { Id = 1, Nom = "Dupont" });

// Exposition externe sécurisée
public ReadOnlyCollection<Client> Clients => clients.AsReadOnly;
```


### Cas d'utilisation typiques

```
// 1. API publique sécurisée
public class Configuration
{
    private Dictionary<string, string> _paramètres = new Dictionary<string, string>();

    // Exposition sécurisée
    public IReadOnlyDictionary<string, string> Paramètres =>
        new ReadOnlyDictionary<string, string>(_paramètres);

    // Ou via l'interface
    public IReadOnlyDictionary<string, string> ParamètresViaDictionary => _paramètres;

    // Contrôle des modifications
    public void DéfinirParamètre(string clé, string valeur)
    {
        if (string.IsNullOrEmpty(clé))
            throw new ArgumentException("La clé ne peut être vide", nameof(clé));

        _paramètres[clé] = valeur;
        // Logique additionnelle (validation, notification, etc.)
    }
}

// 2. Modèle de données avec relation parent-enfant
public class Département
{
    private List<Employé> _employés = new List<Employé>();

    public string Nom { get; set; }

    // Accès en lecture seule
    public ReadOnlyCollection<Employé> Employés =>
        new ReadOnlyCollection<Employé>(_employés);

    // Le département contrôle l'ajout/suppression d'employés
    public void AjouterEmployé(Employé e)
    {
        e.Département = this;  // Maintient la cohérence bidirectionnelle
        _employés.Add(e);
    }

    public void SupprimerEmployé(Employé e)
    {
        if (_employés.Remove(e))
        {
            e.Département = null;
        }
    }
}
```


### Performances et considérations

```
// 1. Création à la demande (lazy) vs création immédiate
public class OptimisationExemple
{
    private List<Item> _items = new List<Item>();

    // Option 1: Création à chaque accès (peu efficace si accès fréquent)
    public ReadOnlyCollection<Item> ItemsNonOptimisé =>
        new ReadOnlyCollection<Item>(_items);

    // Option 2: Création unique et mise en cache (plus efficace)
    private ReadOnlyCollection<Item> _cachedItems;
    public ReadOnlyCollection<Item> ItemsOptimisé
    {
        get
        {
            if (_cachedItems == null)
                _cachedItems = new ReadOnlyCollection<Item>(_items);
            return _cachedItems;
        }
    }

    // Option 3: Création à la demande avec Lazy<T> (thread-safe)
    private Lazy<ReadOnlyCollection<Item>> _lazyItems =
        new Lazy<ReadOnlyCollection<Item>>(() =>
            new ReadOnlyCollection<Item>(new List<Item>()));

    public ReadOnlyCollection<Item> ItemsLazy => _lazyItems.Value;

    // ATTENTION: Si vous modifiez _items et avez déjà créé le wrapper,
    // les modifications seront visibles dans le wrapper mais le wrapper
    // lui-même ne change pas.
}

// 2. Différence entre interfaces et implémentations concrètes
public void DémontrerInterfaces()
{
    // Interface vs implémentation concrète
    IReadOnlyList<int> interface1 = new List<int> { 1, 2, 3 };
    ReadOnlyCollection<int> concrete = new ReadOnlyCollection<int>(new List<int> { 1, 2, 3 });

    // L'interface fournit moins de fonctionnalités que l'implémentation concrète
    int count1 = interface1.Count;
    int count2 = concrete.Count;

    // ReadOnlyCollection fournit quelques méthodes supplémentaires
    // et implémente des interfaces additionnelles comme IReadOnlyList<T>
}
```


### ReadOnlySpan<T> (.NET Core 2.1+ et .NET 8)

Pour les opérations de mémoire à haute performance, .NET moderne propose `ReadOnlySpan<T>`, idéal pour travailler avec des segments de tableaux, de chaînes ou de mémoire sans copie.

```
// Uniquement disponible dans .NET Core 2.1+ et .NET 8
// Non disponible en .NET Framework 4.7.2

// En .NET Core et .NET 8 vous pourriez utiliser:
// byte[] données = new byte[100];
// ReadOnlySpan<byte> vue = données.AsSpan(10, 50);  // Vue en lecture seule des octets 10-59
//
// string texte = "Exemple de texte";
// ReadOnlySpan<char> première = texte.AsSpan(0, 7);  // "Exemple"
//
// foreach (char c in première)
// {
//     Console.Write(c);
// }
```


Les wrappers en lecture seule sont essentiels pour créer des API robustes et sécurisées. Ils permettent d'exposer des données tout en contrôlant précisément comment elles peuvent être modifiées, contribuant ainsi à maintenir l'intégrité des données et à réduire les bugs liés aux modifications non intentionnelles.


Les collections spécialisées de .NET enrichissent considérablement l'arsenal du développeur, offrant des solutions adaptées à des scénarios précis comme la concurrence, l'immutabilité et l'observation de changements. En choisissant la collection appropriée selon votre contexte, vous améliorerez significativement la robustesse, la maintenabilité et les performances de vos applications.
