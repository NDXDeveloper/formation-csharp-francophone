 
### 2.1.1. Espaces de noms (namespaces)
Les espaces de noms (namespaces) sont des conteneurs logiques qui organisent les classes et autres types. Ils permettent d'éviter les conflits de noms et de structurer les applications de manière hiérarchique.
#### Définition et utilisation
Un espace de noms se déclare avec le mot-clé : `namespace`
``` csharp
namespace MonApplication
{
    // Classes, structures, interfaces, etc.
}
```
##### Importation d'espaces de noms
Pour utiliser des types définis dans d'autres espaces de noms, on utilise la directive `using` :
``` csharp
using System;           // Espace de noms fondamental
using System.IO;        // Pour les opérations d'entrée/sortie
using System.Collections.Generic;  // Pour les collections génériques
```
##### Espaces de noms imbriqués
Les espaces de noms peuvent être hiérarchiques, avec une notation par points :
``` csharp
namespace MonEntreprise.MonProduit.ModuleSpecifique
{
    // Classes spécifiques à ce module
}
```
##### Différences entre .NET Framework 4.7.2 et .NET 8
**.NET Framework 4.7.2**
- Organisation traditionnelle des espaces de noms
- Importation explicite requise pour tous les espaces de noms

**.NET 8 (avec C# 10+)**
- Introduction des "global using directives" pour importer des espaces de noms à l'échelle du projet
- "Implicit usings" qui importent automatiquement les espaces de noms communs

Exemple d'usings implicites dans un fichier `.csproj` (.NET 8) :
``` xml
<PropertyGroup>
    <ImplicitUsings>enable</ImplicitUsings>
</PropertyGroup>
```
Cela importe automatiquement des espaces de noms comme , `System.Collections.Generic`, etc., selon le type de projet. `System`
##### Bonnes pratiques
- **Structure hiérarchique** : Utilisez une structure hiérarchique reflétant l'organisation de votre application
- **Nommage** : Utilisez PascalCase et des noms significatifs (généralement nom d'entreprise.nom de produit.module)
- **Évitez les conflits** : Ne créez pas d'espaces de noms qui dupliquent ceux du framework
- **Cohérence** : Gardez une cohérence dans l'organisation de vos espaces de noms

### 2.1.2. Classes et fichiers
En C#, le code est principalement organisé en classes, qui sont généralement définies dans des fichiers individuels portant l'extension `.cs`.
#### Relation entre fichiers et classes
Contrairement à Java, C# n'impose pas que le nom du fichier corresponde au nom de la classe, mais c'est une convention fortement recommandée :
``` csharp
// Fichier: Utilisateur.cs
namespace MonApplication.Modeles
{
    public class Utilisateur
    {
        // Propriétés et méthodes de la classe
    }
}
```
#### Plusieurs classes dans un fichier
Bien que ce ne soit pas recommandé pour les classes importantes, C# permet de définir plusieurs classes dans un même fichier :
``` csharp
// Fichier: EntitesUtilisateur.cs
namespace MonApplication.Modeles
{
    public class Utilisateur
    {
        // Implémentation de la classe Utilisateur
    }

    public class Adresse
    {
        // Implémentation de la classe Adresse
    }
}
```
#### Classes partielles
C# permet de répartir la définition d'une classe sur plusieurs fichiers à l'aide du mot-clé `partial` :
``` csharp
// Fichier: Utilisateur.Donnees.cs
namespace MonApplication.Modeles
{
    public partial class Utilisateur
    {
        // Propriétés et champs
        public string Nom { get; set; }
        public string Email { get; set; }
    }
}

// Fichier: Utilisateur.Methodes.cs
namespace MonApplication.Modeles
{
    public partial class Utilisateur
    {
        // Méthodes
        public bool Valider()
        {
            // Logique de validation
            return !string.IsNullOrEmpty(Nom) && !string.IsNullOrEmpty(Email);
        }
    }
}
```
Les classes partielles sont particulièrement utiles pour :
- Séparer le code généré automatiquement du code écrit manuellement
- Organiser les classes volumineuses par fonctionnalité
- Permettre à plusieurs développeurs de travailler sur différentes parties d'une même classe

#### Organisation des fichiers dans un projet
**.NET Framework 4.7.2** utilise traditionnellement une organisation basée sur des dossiers qui correspondent aux espaces de noms :
```
MonProjet/
│
├── Properties/
│   └── AssemblyInfo.cs
│
├── Models/
│   ├── Utilisateur.cs
│   └── Produit.cs
│
├── Services/
│   └── UtilisateurService.cs
│
└── Program.cs
```
**.NET 8** encourage une organisation similaire mais utilise un fichier de projet plus simple et ne nécessite plus de fichier AssemblyInfo.cs :
```
MonProjet/
│
├── Models/
│   ├── Utilisateur.cs
│   └── Produit.cs
│
├── Services/
│   └── UtilisateurService.cs
│
├── Program.cs
└── MonProjet.csproj
```
### 2.1.3. Point d'entrée (méthode Main)
Le point d'entrée d'une application C# est la méthode . C'est par cette méthode que l'exécution du programme commence. `Main`
#### Signature de la méthode Main
La méthode peut avoir plusieurs signatures valides : `Main`
``` csharp
// Version sans retour et sans arguments
static void Main()
{
    // Code du programme
}

// Version sans retour avec arguments de ligne de commande
static void Main(string[] args)
{
    // Code du programme utilisant args
}

// Version avec retour d'un code d'état
static int Main()
{
    // Code du programme
    return 0; // Code de retour (0 = succès par convention)
}

// Version avec retour et arguments
static int Main(string[] args)
{
    // Code du programme utilisant args
    return 0;
}
```
#### Exemple complet en .NET Framework 4.7.2
``` csharp
using System;

namespace MonApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Bienvenue dans mon application !");

            if (args.Length > 0)
            {
                Console.WriteLine("Arguments passés :");
                foreach (string arg in args)
                {
                    Console.WriteLine($"- {arg}");
                }
            }

            Console.WriteLine("Appuyez sur une touche pour quitter...");
            Console.ReadKey();
        }
    }
}
```
#### Accès aux arguments de ligne de commande
Les arguments passés au programme depuis la ligne de commande sont accessibles via le tableau `args` :
``` csharp
static void Main(string[] args)
{
    // Pour un programme exécuté avec : MonApp.exe fichier.txt -v
    // args[0] contiendra "fichier.txt"
    // args[1] contiendra "-v"

    foreach (string arg in args)
    {
        Console.WriteLine(arg);
    }
}
```
#### Gestion des erreurs dans Main
Le code de retour de la méthode peut être utilisé pour indiquer si le programme s'est terminé avec succès : `Main`
``` csharp
static int Main(string[] args)
{
    try
    {
        // Logique du programme
        Console.WriteLine("Exécution du programme...");
        return 0; // Succès
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Erreur: {ex.Message}");
        return 1; // Échec
    }
}
```
### 2.1.4. Programmes top-level (C# 9+)
À partir de C# 9 (disponible dans .NET 5 et versions ultérieures, incluant .NET 8), Microsoft a introduit les "top-level statements" qui simplifient considérablement l'écriture de petits programmes en éliminant la nécessité de définir explicitement un espace de noms et une classe.
#### Syntaxe simplifiée
Voici un exemple complet en .NET 8 utilisant les top-level statements :
``` csharp
// Program.cs en .NET 8 avec top-level statements
Console.WriteLine("Bienvenue dans mon application !");

// Les args sont disponibles sans déclaration
if (args.Length > 0)
{
    Console.WriteLine("Arguments passés :");
    foreach (string arg in args)
    {
        Console.WriteLine($"- {arg}");
    }
}

// Pas besoin de Console.ReadKey() dans beaucoup de cas modernes
```
#### Règles et restrictions
- Un seul fichier par projet peut contenir des top-level statements
- Ce fichier est généralement nommé `Program.cs`
- Les top-level statements doivent apparaître avant toute déclaration de types (classes, enums, etc.)
- Le compilateur génère automatiquement une classe `Program` et une méthode en coulisses `Main`

#### Utilisation de using avec les top-level statements
Les directives `using` restent en haut du fichier :
``` csharp
using System.IO;
using System.Text.Json;

// Code de top-level
string jsonString = File.ReadAllText("données.json");
var données = JsonSerializer.Deserialize<MesDonnées>(jsonString);
Console.WriteLine($"Données chargées : {données.Titre}");

// Classes peuvent être définies après les top-level statements
public class MesDonnées
{
    public string Titre { get; set; }
}
```
#### Retour de valeur
Pour retourner une valeur dans un programme top-level (équivalent à `int Main()`), utilisez l'instruction `return` directement :
``` csharp
try
{
    // Logique du programme
    return 0; // Succès
}
catch (Exception ex)
{
    Console.Error.WriteLine($"Erreur: {ex.Message}");
    return 1; // Échec
}
```
#### Comparaison avec la syntaxe traditionnelle
**Syntaxe traditionnelle (.NET Framework 4.7.2)**
``` csharp
using System;

namespace MonApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello, World!");
        }
    }
}
```
**Syntaxe top-level (.NET 8)**
``` csharp
// Tout le code au-dessus est généré automatiquement
Console.WriteLine("Hello, World!");
// Pas besoin d'accolades ni de déclarations de classe/méthode
```
#### Cas d'utilisation recommandés
Les top-level statements sont idéals pour :
- Applications console simples
- Scripts et utilitaires
- Petits programmes
- Prototypes et tests

Pour les applications plus complexes, la structure traditionnelle avec des espaces de noms et des classes explicites reste souvent préférable pour la clarté et l'organisation.
#### Utilisation de fonctions locales
Les top-level statements peuvent être organisés avec des fonctions locales :
``` csharp
// Logique principale du programme
Console.WriteLine("Démarrage du programme...");
TraiterFichiers(args);
Console.WriteLine("Fin du traitement.");

// Fonction locale
void TraiterFichiers(string[] fichiers)
{
    foreach (var fichier in fichiers)
    {
        Console.WriteLine($"Traitement du fichier {fichier}");
        // Logique de traitement
    }
}
```
### Résumé des bonnes pratiques
- **Espaces de noms** : Utilisez une structure hiérarchique reflétant l'organisation de votre code
- **Organisation des fichiers** : Un fichier par classe importante, nommé d'après la classe
- **Classes partielles** : Utilisez-les pour séparer le code généré ou pour organiser les classes volumineuses
- **Point d'entrée** : Gardez la méthode simple, déléguant la logique à d'autres classes `Main`
- **Top-level statements** : Privilégiez-les pour les petits programmes et scripts dans .NET 8

Dans la prochaine section, nous explorerons les variables, les types de données et les opérateurs qui constituent les blocs de construction fondamentaux de tout programme C#.
