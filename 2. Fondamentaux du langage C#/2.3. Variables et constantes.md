# 2.3. Variables et constantes

![Variables et constantes](https://via.placeholder.com/600x150?text=Variables+et+constantes+en+C%23)

Les variables et constantes sont des éléments fondamentaux de tout programme C#. Elles permettent de stocker, manipuler et réutiliser des données tout au long de l'exécution d'un programme. Cette section explore en détail comment déclarer, initialiser et utiliser ces éléments de manière efficace.

## 2.3.1. Déclaration et initialisation

En C#, chaque variable doit être déclarée avec un type spécifique avant d'être utilisée. La déclaration réserve un espace mémoire pour stocker la valeur et lui associe un nom.

### Syntaxe de base

La syntaxe de base pour déclarer une variable est :

```
type nomVariable;
```


Pour déclarer et initialiser en même temps :

```
type nomVariable = valeurInitiale;
```


Exemples concrets :

```
// Déclaration simple
int compteur;
string message;
bool estValide;

// Déclaration avec initialisation
int âge = 25;
double prix = 19.99;
string nom = "Jean Dupont";
bool estActif = true;
DateTime dateNaissance = new DateTime(1995, 5, 15);

// Déclaration multiple de variables du même type
int x = 10, y = 20, z = 30;

// Initialisation sur plusieurs lignes
Personne employé = new Personne
{
    Nom = "Martin",
    Prénom = "Sophie",
    Âge = 32
};
```


### Valeurs par défaut

Lorsqu'une variable est déclarée sans initialisation explicite et dans certains contextes (comme les variables de classe), C# lui attribue une valeur par défaut :

```
int nombreNonInitialisé;        // Valeur par défaut : 0
bool booléenNonInitialisé;      // Valeur par défaut : false
string chaîneNonInitialisée;    // Valeur par défaut : null
DateTime dateNonInitialisée;    // Valeur par défaut : 01/01/0001 00:00:00
```


Vous pouvez utiliser `default` pour obtenir la valeur par défaut d'un type :

```
int nombre = default(int);      // 0
bool drapeau = default(bool);   // false

// En C# 7.1+, on peut utiliser la syntaxe raccourcie
double valeur = default;        // 0.0
```


### Initialisation de collections

Pour les tableaux et collections, plusieurs syntaxes d'initialisation sont disponibles :

```
// Tableaux
int[] nombres = new int[5];                   // Tableau de 5 entiers (valeurs par défaut)
int[] séquence = new int[] { 1, 2, 3, 4, 5 }; // Initialisation avec valeurs
int[] valeurs = { 10, 20, 30 };               // Syntaxe raccourcie

// Collections
List<string> fruits = new List<string> { "Pomme", "Banane", "Orange" };
Dictionary<string, int> âges = new Dictionary<string, int>
{
    { "Jean", 30 },
    { "Marie", 25 },
    ["Paul"] = 40               // Syntaxe d'index (C# 6+)
};
```


#### Différence entre .NET Framework 4.7.2 et .NET 8

En .NET 8 (avec C# 12+), vous pouvez utiliser les expressions de collection pour une initialisation plus concise :

```
// En .NET 8 avec C# 12+
int[] nombres = [1, 2, 3, 4, 5];              // Initialisation concise
List<string> fruits = ["Pomme", "Banane", "Orange"]; // Même avec List<T>

// En .NET Framework 4.7.2, il faut utiliser la syntaxe traditionnelle
int[] nombres472 = new int[] { 1, 2, 3, 4, 5 };
List<string> fruits472 = new List<string> { "Pomme", "Banane", "Orange" };
```


### Initialisation de variables dans des méthodes

Les variables locales déclarées dans des méthodes doivent être initialisées avant d'être utilisées :

```
void MéthodeExemple()
{
    int x;          // Déclaration
    // Console.WriteLine(x);  // Erreur de compilation : variable non initialisée

    x = 10;         // Initialisation
    Console.WriteLine(x);  // OK : la variable a été initialisée
}
```


## 2.3.2. Portée (scope) des variables

La portée d'une variable définit la région du code où cette variable est accessible. En C#, les portées principales sont délimitées par des accolades `{ }`.

### Variables locales

Les variables déclarées à l'intérieur d'une méthode sont des variables locales et ne sont accessibles que dans cette méthode :

```
void Méthode1()
{
    int x = 10;     // Variable locale à Méthode1
    Console.WriteLine(x);  // OK
}

void Méthode2()
{
    // Console.WriteLine(x);  // Erreur : x n'est pas défini dans ce contexte
    int y = 20;
}
```


### Portée de bloc

Les variables peuvent avoir une portée encore plus restreinte, limitée à un bloc de code :

```
void ExemplePortéeBloc()
{
    // Variable accessible dans toute la méthode
    int compteurGlobal = 0;

    if (DateTime.Now.DayOfWeek == DayOfWeek.Monday)
    {
        // Variable accessible uniquement dans ce bloc if
        int compteurLundi = 1;
        compteurGlobal++;  // OK : la variable de niveau méthode est accessible
    }

    // compteurLundi++; // Erreur : compteurLundi n'est pas accessible ici

    // Les variables de boucle ont une portée limitée au bloc de la boucle
    for (int i = 0; i < 5; i++)
    {
        Console.WriteLine(i);
    }

    // Console.WriteLine(i);  // Erreur : i n'est pas accessible ici

    // Une nouvelle portée peut être créée avec des accolades
    {
        string message = "Portée limitée";
        Console.WriteLine(message);  // OK
    }

    // Console.WriteLine(message);  // Erreur : message n'est pas accessible ici
}
```


### Variables d'instance et de classe

Les variables déclarées au niveau d'une classe sont soit des variables d'instance (champs), soit des variables de classe (champs statiques) :

```
class Exemple
{
    // Champ d'instance : chaque instance a sa propre copie
    private int compteur = 0;

    // Champ statique : partagé entre toutes les instances
    private static int compteurGlobal = 0;

    // Accessible dans toutes les méthodes de la classe
    public void Incrémenter()
    {
        compteur++;
        compteurGlobal++;
        Console.WriteLine($"Compteur: {compteur}, Global: {compteurGlobal}");
    }

    // Méthode statique avec sa propre portée
    public static void AfficherTotal()
    {
        // Console.WriteLine(compteur);  // Erreur : impossible d'accéder à un champ d'instance
        Console.WriteLine($"Total global: {compteurGlobal}");  // OK
    }
}
```


### Masquage de variables (variable shadowing)

Une variable dans une portée interne peut masquer une variable de même nom dans une portée externe :

```
class ExempleMasquage
{
    private int valeur = 100;  // Champ de classe

    public void Méthode()
    {
        // Cette variable locale masque le champ de classe
        int valeur = 200;
        Console.WriteLine(valeur);      // Affiche 200 (variable locale)
        Console.WriteLine(this.valeur); // Affiche 100 (champ de classe)

        if (true)
        {
            // Masque la variable locale précédente
            string valeur = "texte";
            Console.WriteLine(valeur);  // Affiche "texte"
        }
    }
}
```


### Variables de boucle foreach

Dans les boucles `foreach`, la variable d'itération est en lecture seule à l'intérieur de la boucle :

```
List<int> nombres = new List<int> { 1, 2, 3 };

foreach (int nombre in nombres)
{
    Console.WriteLine(nombre);
    // nombre = 10;  // Erreur : la variable d'itération est en lecture seule
}
```


### Différence entre .NET Framework 4.7.2 et .NET 8

En .NET 8 (avec C# 8+), la portée des variables a été légèrement améliorée avec l'introduction de la déclaration de variables dans les conditions :

```
// En .NET 8 (C# 8+)
if (int.TryParse(entrée, out int résultat) && résultat > 0)
{
    Console.WriteLine($"Valeur positive: {résultat}");
}
// résultat est accessible ici aussi dans le même bloc parent

// En C# 9+, les déclarations pattern permettent également de déclarer des variables
if (obj is string { Length: > 0 } texte)
{
    Console.WriteLine(texte);  // Variable texte créée et accessible
}
```


## 2.3.3. Conversion de types (cast implicite/explicite)

La conversion de types permet de transformer une valeur d'un type en une valeur d'un autre type. C# prend en charge deux types de conversions : implicites et explicites.

### Conversions implicites

Les conversions implicites sont effectuées automatiquement par le compilateur lorsqu'il n'y a aucun risque de perte de données :

```
// Conversions numériques (du plus petit au plus grand)
byte petitNombre = 100;
int nombreMoyen = petitNombre;    // Conversion implicite de byte vers int
long grandNombre = nombreMoyen;   // Conversion implicite de int vers long
float nombreFlottant = grandNombre; // Conversion implicite de long vers float
double nombreDouble = nombreFlottant; // Conversion implicite de float vers double

// Types dérivés vers types de base
class Animal { }
class Chien : Animal { }

Chien monChien = new Chien();
Animal monAnimal = monChien;      // Conversion implicite d'une classe dérivée vers sa classe de base
```


### Conversions explicites (cast)

Les conversions explicites sont nécessaires lorsqu'il y a un risque de perte de données ou lorsque la conversion n'est pas évidente pour le compilateur :

```
// Conversions numériques avec risque de perte (du plus grand au plus petit)
double nombreDouble = 123.45;
float nombreFlottant = (float)nombreDouble;  // Cast explicite
int entier = (int)nombreFlottant;           // Cast explicite, perte de la partie décimale
byte petitNombre = (byte)entier;            // Cast explicite, risque de dépassement

// Types de base vers types dérivés
Animal animal = new Chien();
Chien chien = (Chien)animal;  // Cast explicite, peut échouer si animal n'est pas réellement un Chien

// Cast qui échoue à l'exécution
Animal chat = new Chat();
// Chien erreur = (Chien)chat;  // Lève une InvalidCastException
```


### Méthodes de conversion

C# offre plusieurs méthodes de conversion, en plus des opérateurs de cast :

```
// Méthodes Convert
string nombreTexte = "123";
int nombre = Convert.ToInt32(nombreTexte);  // Conversion de string vers int
double valeurDouble = Convert.ToDouble("123.45");
bool valeurBool = Convert.ToBoolean("True");

// La classe Convert peut aussi gérer les valeurs null
string valeurNull = null;
int résultat = Convert.ToInt32(valeurNull);  // Retourne 0 au lieu de lever une exception

// Méthodes Parse des types
int nombreParInt = int.Parse("456");
double nombreParDouble = double.Parse("456.78");
DateTime date = DateTime.Parse("2023-03-15");

// TryParse pour éviter les exceptions
if (int.TryParse("123abc", out int résultatConversion))
{
    Console.WriteLine("Conversion réussie: " + résultatConversion);
}
else
{
    Console.WriteLine("Échec de la conversion");
}
```


### Opérateur as et is

C# fournit deux opérateurs spéciaux pour manipuler les types référence :

```
// Opérateur is - vérifie le type
if (objet is Chien)
{
    Console.WriteLine("C'est un chien");
}

// Pattern matching avec is (C# 7+)
if (objet is Chien chien)
{
    Console.WriteLine($"C'est un chien qui s'appelle {chien.Nom}");
}

// Opérateur as - tente la conversion mais retourne null en cas d'échec
Chien monChien = objet as Chien;
if (monChien != null)
{
    Console.WriteLine("Conversion réussie");
}
```


### Conversions définies par l'utilisateur

Vous pouvez définir vos propres conversions pour les types personnalisés :

```
public struct Température
{
    private double celsius;

    public Température(double celsius)
    {
        this.celsius = celsius;
    }

    // Conversion implicite de double vers Température
    public static implicit operator Température(double valeur)
    {
        return new Température(valeur);
    }

    // Conversion explicite de Température vers double (retourne la valeur en Celsius)
    public static explicit operator double(Température temp)
    {
        return temp.celsius;
    }

    // Conversion explicite vers Fahrenheit
    public static explicit operator Fahrenheit(Température celsius)
    {
        return new Fahrenheit(celsius.celsius * 9 / 5 + 32);
    }
}

// Utilisation
Température t1 = 25.0;                // Conversion implicite de double
double celsius = (double)t1;          // Conversion explicite vers double
Fahrenheit f = (Fahrenheit)t1;        // Conversion explicite vers un autre type personnalisé
```


## 2.3.4. var et inférence de type

L'inférence de type permet au compilateur de déterminer automatiquement le type d'une variable en fonction de son initialisation, sans avoir à le déclarer explicitement.

### Utilisation de var

Le mot-clé `var` permet d'utiliser l'inférence de type en C# :

```
// Le compilateur infère que x est de type int
var x = 10;

// Inférence avec d'autres types
var nom = "Jean";                    // string
var pi = 3.14159;                    // double
var aujourd'hui = DateTime.Now;      // DateTime
var nombres = new[] { 1, 2, 3 };     // int[]
var dictionnaire = new Dictionary<string, int>();  // Dictionary<string, int>
```


### Points importants sur var

- `var` n'est pas un type dynamique - le type est déterminé à la compilation, pas à l'exécution
- La variable doit être initialisée en même temps que sa déclaration
- Une fois le type inféré, il ne peut pas changer

```
var nombre = 10;   // Type inféré : int
// nombre = "texte";  // Erreur : impossible d'assigner une string à une variable de type int

// Impossible sans initialisation
// var x;  // Erreur : l'initialisation est requise
```


### Quand utiliser var

L'utilisation de `var` est recommandée dans plusieurs cas :

```
// 1. Quand le type est évident dans l'initialisation
var liste = new List<string>();
var dictionnaire = new Dictionary<string, List<Utilisateur>>();

// 2. Avec les types anonymes (obligatoire)
var personne = new { Nom = "Jean", Age = 30 };
Console.WriteLine($"{personne.Nom} a {personne.Age} ans");

// 3. Avec les requêtes LINQ
var résultat = from p in personnes
               where p.Age > 30
               select new { p.Nom, p.Prénom };

// 4. Pour les variables temporaires avec des noms descriptifs
var utilisateurConnecté = récupérerUtilisateurCourant();
```


### Quand éviter var

L'utilisation de `var` n'est pas recommandée dans certains cas :

```
// 1. Quand le type n'est pas évident dans l'initialisation
int résultat = CalculerQuelqueChose();  // Préférable à var résultat = CalculerQuelqueChose();

// 2. Pour les variables sans initialisation claire
IEnumerable<int> nombres = MéthodeQuiRetourneDesNombres();  // Type attendu explicite

// 3. Pour les types primitifs sans contexte clair
int compteur = 0;  // Préférable à var compteur = 0;
```


### Différence avec dynamic

Ne confondez pas `var` avec `dynamic` :

```
// var : type statique déterminé à la compilation
var nombre = 10;
// Le compilateur sait que c'est un int, donc :
int double_nombre = nombre * 2;  // OK

// dynamic : type dynamique déterminé à l'exécution
dynamic valeur = 10;
valeur = "texte";  // OK - le type peut changer
// Le compilateur ne vérifie pas les opérations :
// valeur.MéthodeInexistante();  // Pas d'erreur à la compilation, mais échouera à l'exécution
```


### Différence entre .NET Framework 4.7.2 et .NET 8

L'inférence de type avec `var` fonctionne de manière identique dans .NET Framework 4.7.2 et .NET 8. Cependant, .NET 8 (avec les versions récentes de C#) offre des fonctionnalités supplémentaires liées aux types :

```
// En .NET 8 avec C# 10+
// Propriétés globales et using statiques qui simplifient les types
global using static System.Console;
global using static System.Math;

// Utilisation simplifié
WriteLine(Sqrt(64));  // Au lieu de Console.WriteLine(Math.Sqrt(64));
```


## 2.3.5. readonly et const

C# offre deux moyens principaux pour déclarer des valeurs qui ne changent pas : `readonly` et `const`. Bien qu'ils semblent similaires, ils ont des différences importantes.

### Constantes (const)

Les constantes sont des valeurs déterminées à la compilation et ne peuvent jamais changer :

```
// Constantes au niveau de la classe
public class MathUtils
{
    // Doit être initialisée lors de la déclaration
    public const double PI = 3.14159265359;
    public const string APP_NAME = "Mon Application";
    public const int MAX_USERS = 100;

    // Les constantes peuvent être utilisées dans d'autres constantes
    public const double DEUX_PI = 2 * PI;
}

// Constantes locales dans une méthode
public void Méthode()
{
    const int FACTEUR = 10;
    const string PREFIX = "ID-";
}
```


Caractéristiques des constantes :
- Doivent être initialisées à la déclaration
- Ne peuvent être initialisées qu'avec des valeurs littérales ou d'autres constantes
- Sont évaluées à la compilation (pas à l'exécution)
- Sont implicitment statiques (pas besoin du mot-clé `static`)
- Peuvent être de type primitif, enum ou string

### Variables readonly

Les champs `readonly` sont des variables dont la valeur ne peut être modifiée qu'à la déclaration ou dans un constructeur :

```
public class Configuration
{
    // Peut être initialisée à la déclaration
    public readonly string Environnement = "Production";

    // Ou dans le constructeur
    public readonly string ConnectionString;
    public readonly List<string> Paramètres;
    public readonly DateTime DateDémarrage;

    public Configuration(string connexion)
    {
        ConnectionString = connexion;
        Paramètres = new List<string> { "Param1", "Param2" };
        DateDémarrage = DateTime.Now;

        // Ces assignations sont valides seulement dans le constructeur
    }

    public void Méthode()
    {
        // Erreur : impossible de modifier un champ readonly
        // DateDémarrage = DateTime.Now;

        // Mais on peut modifier le contenu d'un objet readonly
        Paramètres.Add("Param3");  // Valide! Seule la référence est readonly
    }
}
```


Caractéristiques des champs readonly :
- Peuvent être initialisés à la déclaration ou dans un constructeur
- Peuvent être initialisés avec des valeurs calculées à l'exécution
- Peuvent être de n'importe quel type
- Peuvent être des champs d'instance ou des champs statiques

### Comparaison entre const et readonly

| Caractéristique | const | readonly |
|----------------|-------|----------|
| Moment d'évaluation | Compilation | Exécution |
| Types supportés | Types primitifs, enum, string | Tous les types |
| Modification | Jamais | Dans constructeur uniquement |
| Statique | Toujours (implicite) | Optionnel |
| Référence | Copiée au site d'utilisation | Référencée normalement |

```
// Exemple illustrant les différences
public class Exemple
{
    // Évalué à la compilation, toujours le même pour tous les utilisateurs
    public const string VERSION = "1.0.0";

    // Évalué à l'exécution, peut varier selon l'environnement
    public readonly string InstallPath = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
}
```


### readonly struct (C# 7.2+)

En C# 7.2+, vous pouvez déclarer des structures entières comme readonly :

```
// Structure dont toutes les méthodes garantissent de ne pas modifier l'état
public readonly struct Point
{
    public readonly double X { get; }
    public readonly double Y { get; }

    public Point(double x, double y)
    {
        X = x;
        Y = y;
    }

    // Les méthodes ne peuvent pas modifier l'état de l'instance
    public double Distance(Point other)
    {
        double dx = X - other.X;
        double dy = Y - other.Y;
        return Math.Sqrt(dx * dx + dy * dy);
    }

    // this.X = 10; // Erreur : impossible dans une readonly struct
}
```


### readonly members (C# 8+)

En C# 8+, vous pouvez déclarer des membres individuels comme readonly :

```
public struct Rectangle
{
    public double Width;
    public double Height;

    // Propriété calculée readonly qui ne modifie pas l'état
    public readonly double Area => Width * Height;

    // Méthode readonly qui ne modifie pas l'état
    public readonly double Perimeter() => 2 * (Width + Height);

    // Méthode normale qui peut modifier l'état
    public void Scale(double factor)
    {
        Width *= factor;
        Height *= factor;
    }
}
```


### Init-only properties (C# 9+, .NET 5+)

C# 9 a introduit les propriétés init-only, qui combinent les avantages de readonly avec une syntaxe d'initialisation plus flexible :

```
// Disponible dans .NET 5+ (pas dans .NET Framework 4.7.2)
public class Personne
{
    // Propriétés init-only
    public string Nom { get; init; }
    public string Prénom { get; init; }
    public DateTime DateNaissance { get; init; }

    // Peuvent être initialisées soit via constructeur
    public Personne(string nom, string prénom)
    {
        Nom = nom;
        Prénom = prénom;
    }

    // Soit via initialisation d'objet
    // var p = new Personne { Nom = "Dupont", Prénom = "Jean", DateNaissance = new DateTime(1980, 1, 1) };
}
```


### Utilisation avec des collections

Pour les collections qui ne doivent pas être modifiées, plusieurs approches sont possibles :

```
public class ConfigurationApp
{
    // 1. Collection readonly (la référence ne peut pas changer, mais le contenu oui)
    public readonly List<string> Paramètres = new List<string>();

    // 2. Collection immuable (contenu ne peut pas changer)
    public readonly IReadOnlyList<string> Options = new List<string> { "Option1", "Option2" }.AsReadOnly();

    // 3. Collection constante (doit être connue à la compilation)
    // Impossible avec List, mais possible avec des tableaux
    public static readonly string[] COULEURS = { "Rouge", "Vert", "Bleu" };
}
```


### Bonnes pratiques

- Utilisez `const` pour les valeurs véritablement constantes connues à la compilation
- Utilisez `readonly` pour les valeurs qui doivent être calculées à l'exécution mais ne doivent pas changer ensuite
- Pour les collections, envisagez `IReadOnlyList<T>` ou `IReadOnlyDictionary<K,V>` pour empêcher la modification du contenu
- Utilisez les structs readonly pour les types valeur qui ne devraient jamais être modifiés après création
- En .NET 5+ (C# 9+), envisagez d'utiliser les propriétés init-only pour une initialisation plus flexible

---

Les variables et constantes sont les fondements sur lesquels vous construirez vos programmes C#. Une bonne compréhension de leur déclaration, leur portée, les mécanismes de conversion, l'inférence de type et les moyens de créer des données immuables vous aidera à écrire du code plus clair, plus robuste et moins sujet aux erreurs. Dans la section suivante, nous explorerons les opérateurs et expressions qui vous permettront de manipuler ces variables efficacement.
