# 2.4. Opérateurs

![Opérateurs en C#](https://via.placeholder.com/600x150?text=Op%C3%A9rateurs+en+C%23)

Les opérateurs sont des symboles qui indiquent au compilateur d'effectuer des opérations mathématiques, logiques ou de manipulation sur des variables et des valeurs. C# offre un ensemble riche d'opérateurs qui vous permettent d'effectuer diverses opérations sur vos données. Cette section présente en détail les différents types d'opérateurs disponibles en C#.

## 2.4.1. Opérateurs arithmétiques et d'affectation

Les opérateurs arithmétiques permettent d'effectuer des calculs mathématiques de base, tandis que les opérateurs d'affectation assignent des valeurs aux variables.

### Opérateurs arithmétiques

```
int a = 10;
int b = 3;

// Opérateurs arithmétiques de base
int somme = a + b;        // Addition: 13
int différence = a - b;   // Soustraction: 7
int produit = a * b;      // Multiplication: 30
int quotient = a / b;     // Division entière: 3 (attention: division entière!)
int reste = a % b;        // Modulo (reste de division): 1

// Division avec nombres à virgule flottante
double c = 10.0;
double d = 3.0;
double divisionRéelle = c / d;  // 3.3333333333333335

// Incrémentation et décrémentation
int i = 5;
i++;                      // Post-incrémentation: utilise i puis l'incrémente
++i;                      // Pré-incrémentation: incrémente i puis l'utilise
i--;                      // Post-décrémentation: utilise i puis le décrémente
--i;                      // Pré-décrémentation: décrémente i puis l'utilise

// Différence entre pré et post incrémentation
int x = 5;
int y = x++;              // y = 5, x = 6
int z = ++x;              // x = 7, z = 7
```


### Opérateurs d'affectation

```
int a = 10;               // Affectation simple

// Opérateurs d'affectation composés
a += 5;                   // Équivalent à: a = a + 5; (a devient 15)
a -= 3;                   // Équivalent à: a = a - 3; (a devient 12)
a *= 2;                   // Équivalent à: a = a * 2; (a devient 24)
a /= 4;                   // Équivalent à: a = a / 4; (a devient 6)
a %= 4;                   // Équivalent à: a = a % 4; (a devient 2)

// Opérateurs d'affectation bit à bit
int bits = 5;             // 101 en binaire
bits &= 3;                // Équivalent à: bits = bits & 3; (101 & 011 = 001, bits devient 1)
bits |= 6;                // Équivalent à: bits = bits | 6; (001 | 110 = 111, bits devient 7)
bits ^= 2;                // Équivalent à: bits = bits ^ 2; (111 ^ 010 = 101, bits devient 5)
bits <<= 1;               // Équivalent à: bits = bits << 1; (101 << 1 = 1010, bits devient 10)
bits >>= 2;               // Équivalent à: bits = bits >> 2; (1010 >> 2 = 10, bits devient 2)
```


### Débordement arithmétique

Par défaut, C# ne vérifie pas les débordements pour les opérations arithmétiques sur les types entiers :

```
// Débordement sans vérification
int maxInt = int.MaxValue;        // 2,147,483,647
int résultat = maxInt + 1;        // Débordement: -2,147,483,648

// Vérification des débordements avec checked
try
{
    checked
    {
        int résultatVérifié = maxInt + 1;  // Lève OverflowException
    }
}
catch (OverflowException ex)
{
    Console.WriteLine("Débordement détecté: " + ex.Message);
}

// Opérations individuelles
int x = checked(maxInt + 1);      // Lève OverflowException
```


### Opérations sur des types différents

```
// Promotion de type automatique
int entier = 5;
double décimal = 2.5;
double résultat = entier + décimal;  // Résultat: 7.5 (entier promu en double)

// Conversion explicite nécessaire pour revenir à un type plus petit
int sommeEntière = entier + (int)décimal;  // Résultat: 7 (troncation de la partie décimale)
```


## 2.4.2. Opérateurs logiques et bit à bit

Les opérateurs logiques travaillent avec des valeurs booléennes, tandis que les opérateurs bit à bit manipulent les bits individuels des valeurs entières.

### Opérateurs logiques booléens

```
bool a = true;
bool b = false;

// Opérateurs logiques de base
bool et = a && b;         // ET logique: false
bool ou = a || b;         // OU logique: true
bool non = !a;            // NON logique: false

// Évaluation à court-circuit
bool résultat1 = (CalculCouteux() && ValeurFausse());  // CalculCouteux() n'est pas évalué si ValeurFausse() est false
bool résultat2 = (ValeurVraie() || CalculCouteux());   // CalculCouteux() n'est pas évalué si ValeurVraie() est true

// ET et OU non à court-circuit (évaluent toujours les deux opérandes)
bool résultat3 = (a & b);  // ET logique (sans court-circuit): false
bool résultat4 = (a | b);  // OU logique (sans court-circuit): true
bool résultat5 = (a ^ b);  // OU exclusif (XOR): true
```


### Opérateurs bit à bit

```
int x = 5;                // 00000000 00000000 00000000 00000101 en binaire
int y = 3;                // 00000000 00000000 00000000 00000011 en binaire

// Opérations bit à bit
int et = x & y;           // ET: 00000000 00000000 00000000 00000001 (1)
int ou = x | y;           // OU: 00000000 00000000 00000000 00000111 (7)
int xor = x ^ y;          // XOR: 00000000 00000000 00000000 00000110 (6)
int non = ~x;             // NON: 11111111 11111111 11111111 11111010 (-6)

// Décalages de bits
int décalageGauche = x << 1;  // Décalage à gauche: 00000000 00000000 00000000 00001010 (10)
int décalageDroit = x >> 1;   // Décalage à droite: 00000000 00000000 00000000 00000010 (2)

// Opérateur de décalage à droite sans signe (C# 8.0+)
uint z = 0x80000000;      // 10000000 00000000 00000000 00000000
int normalRightShift = (int)z >> 1;  // Extension de signe: 11000000 00000000 00000000 00000000
uint unsignedRightShift = z >>> 1;   // Sans extension: 01000000 00000000 00000000 00000000
```


### Application pratique: opérations sur les drapeaux (flags)

```
// Utilisation d'enum avec l'attribut [Flags]
[Flags]
enum Permissions
{
    Aucune    = 0,        // 0000
    Lecture   = 1 << 0,   // 0001
    Écriture  = 1 << 1,   // 0010
    Exécution = 1 << 2,   // 0100
    TousAccès = Lecture | Écriture | Exécution  // 0111
}

// Manipulation des drapeaux
Permissions p = Permissions.Lecture | Permissions.Écriture;  // 0011

// Vérifier si un drapeau est présent
bool peutLire = (p & Permissions.Lecture) == Permissions.Lecture;  // true
bool peutExécuter = (p & Permissions.Exécution) == Permissions.Exécution;  // false

// Ajouter un drapeau
p |= Permissions.Exécution;  // Ajout de l'exécution (0111)

// Supprimer un drapeau
p &= ~Permissions.Écriture;  // Suppression de l'écriture (0101)

// Basculer un drapeau
p ^= Permissions.Lecture;    // Bascule de la lecture (0100)

// Affichage avec ToString() automatiquement défini pour les enums [Flags]
Console.WriteLine(p);  // "Exécution"
```


### Différence entre .NET Framework 4.7.2 et .NET 8

L'opérateur de décalage à droite sans signe (`>>>`) a été introduit dans C# 8.0 et n'est donc pas disponible dans .NET Framework 4.7.2. Pour obtenir un comportement similaire dans .NET Framework 4.7.2, il faut utiliser une solution de contournement :

```
// En .NET 8 (C# 8.0+)
uint valeur = 0x80000000;
uint résultat = valeur >>> 1;  // Décalage à droite sans signe

// En .NET Framework 4.7.2
uint valeur472 = 0x80000000;
uint résultat472 = (uint)(valeur472 >> 1);  // Simulation du décalage sans signe
```


## 2.4.3. Opérateurs de comparaison et d'égalité

Les opérateurs de comparaison et d'égalité permettent d'évaluer des relations entre valeurs et de comparer l'égalité des objets.

### Opérateurs de comparaison

```
int a = 5;
int b = 10;

// Opérateurs de comparaison de base
bool estÉgal = (a == b);         // Égalité: false
bool estDifférent = (a != b);    // Inégalité: true
bool estPlusPetit = (a < b);     // Inférieur à: true
bool estPlusGrand = (a > b);     // Supérieur à: false
bool estInférieurOuÉgal = (a <= b);  // Inférieur ou égal à: true
bool estSupérieurOuÉgal = (a >= b);  // Supérieur ou égal à: false

// Comparaison de chaînes (sensible à la casse par défaut)
string s1 = "abc";
string s2 = "ABC";
bool chaînesÉgales = (s1 == s2);  // false

// Comparaison de chaînes avec options (insensible à la casse)
bool chaînesÉgalesIgnoreCase = string.Equals(s1, s2, StringComparison.OrdinalIgnoreCase);  // true
```


### Égalité référentielle vs égalité de valeur

```
// Égalité de valeur pour les types valeur
int x1 = 5;
int x2 = 5;
bool entiersSontÉgaux = (x1 == x2);  // true (comparaison de valeurs)

// Égalité référentielle pour les types référence
object obj1 = new object();
object obj2 = new object();
object obj3 = obj1;
bool objetsÉgaux1 = (obj1 == obj2);  // false (références différentes)
bool objetsÉgaux2 = (obj1 == obj3);  // true (même référence)

// Cas spécial: les chaînes comparent leur contenu par défaut
string str1 = "Bonjour";
string str2 = "Bonjour";
string str3 = new string(new char[] { 'B', 'o', 'n', 'j', 'o', 'u', 'r' });
bool chaînesÉgales1 = (str1 == str2);  // true
bool chaînesÉgales2 = (str1 == str3);  // true (compare le contenu)
bool référencesÉgales = ReferenceEquals(str1, str3);  // false (références différentes)
```


### Opérateurs d'égalité pour types référence personnalisés

```
class Personne
{
    public string Nom { get; set; }
    public int Age { get; set; }

    // Surcharge de l'opérateur d'égalité
    public static bool operator ==(Personne p1, Personne p2)
    {
        // Gérer les cas null
        if (ReferenceEquals(p1, null))
            return ReferenceEquals(p2, null);

        return p1.Equals(p2);
    }

    public static bool operator !=(Personne p1, Personne p2)
    {
        return !(p1 == p2);
    }

    // Surcharge de Equals
    public override bool Equals(object obj)
    {
        if (obj is Personne autre)
        {
            return Nom == autre.Nom && Age == autre.Age;
        }
        return false;
    }

    // GetHashCode doit être surchargé quand Equals est surchargé
    public override int GetHashCode()
    {
        return (Nom?.GetHashCode() ?? 0) ^ Age.GetHashCode();
    }
}

// Utilisation
Personne p1 = new Personne { Nom = "Jean", Age = 30 };
Personne p2 = new Personne { Nom = "Jean", Age = 30 };
Personne p3 = new Personne { Nom = "Marie", Age = 25 };

bool égales = (p1 == p2);  // true (même contenu)
bool différentes = (p1 != p3);  // true (contenu différent)
```


### Méthode EqualityComparer<T> et IEquatable<T>

```
class Client : IEquatable<Client>
{
    public int Id { get; set; }
    public string Nom { get; set; }

    // Implémentation de IEquatable<T>
    public bool Equals(Client autre)
    {
        if (autre == null)
            return false;

        return Id == autre.Id;  // Comparaison basée uniquement sur l'Id
    }

    // Surcharge de Equals(object)
    public override bool Equals(object obj)
    {
        return Equals(obj as Client);
    }

    public override int GetHashCode()
    {
        return Id.GetHashCode();
    }
}

// Utilisation avec des collections
var clients = new HashSet<Client>(new ClientIdComparer());

// Comparateur personnalisé
class ClientIdComparer : IEqualityComparer<Client>
{
    public bool Equals(Client x, Client y)
    {
        if (x == null && y == null)
            return true;
        if (x == null || y == null)
            return false;

        return x.Id == y.Id;
    }

    public int GetHashCode(Client obj)
    {
        return obj?.Id.GetHashCode() ?? 0;
    }
}
```


## 2.4.4. Opérateur null-conditionnel (?.) et null-coalescent (??)

Ces opérateurs modernes permettent une gestion élégante des valeurs potentiellement nulles, réduisant le code boilerplate et améliorant la lisibilité.

### Opérateur null-conditionnel (?.)

L'opérateur `?.` (introduit dans C# 6.0) permet d'accéder aux membres d'un objet uniquement si cet objet n'est pas null :

```
// Approche traditionnelle sans ?.
if (client != null)
{
    if (client.Adresse != null)
    {
        Console.WriteLine(client.Adresse.Ville);
    }
}

// Avec l'opérateur ?.
Console.WriteLine(client?.Adresse?.Ville);  // Retourne null si client ou Adresse est null

// Peut être utilisé avec les méthodes
string prénom = client?.ObtenirPrénom();

// Peut être utilisé avec les index de collection
int? premierÉlément = tableau?.Length > 0 ? tableau[0] : null;
// Ou avec l'opérateur ?[] (null-conditional avec indexeur)
int? premierÉlément = tableau?[0];
```


### Opérateur null-coalescent (??)

L'opérateur `??` (introduit dans C# 2.0) permet de fournir une valeur par défaut lorsqu'une expression est null :

```
// Approche traditionnelle sans ??
string nom;
if (client != null)
{
    nom = client.Nom;
}
else
{
    nom = "Inconnu";
}

// Avec l'opérateur ??
string nom = client?.Nom ?? "Inconnu";

// Chaînage de ??
string ville = client?.Adresse?.Ville ?? client?.AdresseSecondaire?.Ville ?? "Ville inconnue";

// Avec des types nullables
int? nombreNullable = null;
int nombreNonNull = nombreNullable ?? 0;  // Si nombreNullable est null, utilise 0
```


### Opérateur d'assignation null-coalescent (??=)

L'opérateur `??=` (introduit dans C# 8.0) assigne la valeur droite à la variable gauche uniquement si celle-ci est null :

```
// Disponible dans .NET Core 3.0+ et .NET 8, mais pas dans .NET Framework 4.7.2
// Équivalent à : if (liste == null) liste = new List<string>();
liste ??= new List<string>();

// Très utile pour l'initialisation paresseuse
private List<Client> _clients;
public List<Client> Clients => _clients ??= ChargerClients();
```


### Combiner les opérateurs null-conditionnels et null-coalescents

```
// Combinaison puissante pour une gestion élégante des nulls
string message = utilisateur?.Messages?.FirstOrDefault()?.Contenu ?? "Aucun message";

// Équivalent verbeux
string message;
if (utilisateur != null && utilisateur.Messages != null)
{
    var premierMessage = utilisateur.Messages.FirstOrDefault();
    if (premierMessage != null)
    {
        message = premierMessage.Contenu;
    }
    else
    {
        message = "Aucun message";
    }
}
else
{
    message = "Aucun message";
}
```


### Différence entre .NET Framework 4.7.2 et .NET 8

L'opérateur d'assignation null-coalescent (`??=`) n'est pas disponible dans .NET Framework 4.7.2 car il a été introduit dans C# 8.0. Pour simuler son comportement dans .NET Framework 4.7.2 :

```
// En .NET 8 (C# 8.0+)
liste ??= new List<string>();

// En .NET Framework 4.7.2
if (liste == null)
{
    liste = new List<string>();
}
```


## 2.4.5. Expression conditionnelle ternaire

L'opérateur ternaire `? :` permet d'écrire une expression conditionnelle concise qui retourne l'une des deux valeurs selon qu'une condition est vraie ou fausse.

### Syntaxe de base

```
// Syntaxe: condition ? valeurSiVrai : valeurSiFaux

// Exemple simple
int a = 10;
int b = 20;
int maximum = (a > b) ? a : b;  // b est plus grand, donc maximum = 20

// Alternative avec if-else
int maximum2;
if (a > b)
{
    maximum2 = a;
}
else
{
    maximum2 = b;
}
```


### Utilisation dans des expressions

```
// Dans une interpolation de chaîne
string message = $"Il y a {compteur} élément{(compteur > 1 ? "s" : "")}";

// Dans une affectation
string statut = âge >= 18 ? "Adulte" : "Mineur";

// Comme argument de méthode
Console.WriteLine(estValide ? "Valide" : "Invalide");

// Dans une expression lambda
Func<int, string> classifierNombre = n => n < 0 ? "Négatif" : n > 0 ? "Positif" : "Zéro";
```


### Expressions ternaires imbriquées

```
// Imbrication de ternaires (à utiliser avec modération pour la lisibilité)
int note = 85;
string mention = note >= 90 ? "Très bien" :
                 note >= 70 ? "Bien" :
                 note >= 50 ? "Passable" :
                 "Insuffisant";

// Équivalent avec if-else
string mention2;
if (note >= 90)
{
    mention2 = "Très bien";
}
else if (note >= 70)
{
    mention2 = "Bien";
}
else if (note >= 50)
{
    mention2 = "Passable";
}
else
{
    mention2 = "Insuffisant";
}
```


### Usage avec null-conditional et null-coalescent

```
// Combinaison avec d'autres opérateurs
string résultat = client?.EstActif == true ? "Actif" : "Inactif";

// Plus complexe
string message = utilisateur != null ?
                 utilisateur.EstConnecté ? "En ligne" : "Hors ligne" :
                 "Non enregistré";

// Alternative utilisant ?. et ??
bool? estConnecté = utilisateur?.EstConnecté;
string message2 = estConnecté == true ? "En ligne" :
                 estConnecté == false ? "Hors ligne" :
                 "Non enregistré";
```


### Bonnes pratiques et pièges courants

```
// 1. Éviter les expressions trop complexes
// Difficile à lire
string résultat = a > b ? c > d ? "A" : e > f ? "B" : "C" : "D";

// Plus lisible avec des variables intermédiaires
bool condition1 = a > b;
bool condition2 = c > d;
bool condition3 = e > f;
string résultatSiCondition1 = condition2 ? "A" : (condition3 ? "B" : "C");
string résultat = condition1 ? résultatSiCondition1 : "D";

// 2. Attention aux types de retour qui doivent être compatibles
// string s = condition ? "texte" : 123;  // Erreur: types incompatibles
string s = condition ? "texte" : 123.ToString();  // OK

// 3. Utilisez les parenthèses pour clarifier la précédence
int valeur = condition1 ? 1 : condition2 ? 2 : 3;  // Peut être ambigu
int valeurClaire = condition1 ? 1 : (condition2 ? 2 : 3);  // Plus clair
```


### Switch expressions (C# 8.0+)

En C# 8.0 et versions ultérieures, les expressions switch offrent une alternative élégante aux expressions conditionnelles ternaires imbriquées :

```
// Disponible dans .NET Core 3.0+ et .NET 8, mais pas dans .NET Framework 4.7.2
enum Saison { Printemps, Été, Automne, Hiver }

// Expression switch (C# 8.0+)
string GetDescription(Saison saison) => saison switch
{
    Saison.Printemps => "Fleurs et renouveau",
    Saison.Été => "Chaleur et vacances",
    Saison.Automne => "Feuilles colorées",
    Saison.Hiver => "Neige et froid",
    _ => "Saison inconnue"  // Pattern de discard (attrape-tout)
};

// Equivalent en .NET Framework 4.7.2 avec opérateur ternaire
string GetDescription472(Saison saison)
{
    return saison == Saison.Printemps ? "Fleurs et renouveau" :
           saison == Saison.Été ? "Chaleur et vacances" :
           saison == Saison.Automne ? "Feuilles colorées" :
           saison == Saison.Hiver ? "Neige et froid" :
           "Saison inconnue";
}
```


---

Les opérateurs sont des outils fondamentaux qui vous permettent de manipuler efficacement les données dans vos programmes C#. Une bonne compréhension des opérateurs arithmétiques, logiques, de comparaison et des opérateurs spéciaux comme null-conditionnel, null-coalescent et l'expression ternaire vous permettra d'écrire du code plus concis, plus lisible et plus robuste. Dans la section suivante, nous explorerons les structures de contrôle qui vous permettront de diriger le flux d'exécution de votre programme en fonction de ces opérations.
